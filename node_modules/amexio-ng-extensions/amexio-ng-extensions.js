import { CommonModule, DOCUMENT, isPlatformBrowser, ÉµparseCookieValue } from '@angular/common';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ComponentFactoryResolver, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Host, HostBinding, HostListener, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Output, PLATFORM_ID, Pipe, Renderer2, TemplateRef, ViewChild, ViewChildren, ViewContainerRef, ViewEncapsulation, forwardRef } from '@angular/core';
import { FormBuilder, FormsModule, NG_VALIDATORS, NG_VALUE_ACCESSOR, NgForm, NgModel, ReactiveFormsModule } from '@angular/forms';
import { DomSanitizer } from '@angular/platform-browser';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}



















function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
    return typeof x === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; });
}

/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError(err);
        }
    },
    complete: function () { }
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
    return x != null && typeof x === 'object';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var errorObject = { e: {} };

/** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject.e = e;
        return errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function UnsubscriptionErrorImpl(errors) {
    Error.call(this);
    this.message = errors ?
        errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
    return this;
}
UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var UnsubscriptionError = UnsubscriptionErrorImpl;

/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */
var Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        while (_parent) {
            _parent.remove(this);
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction(_unsubscribe)) {
            var trial = tryCatch(_unsubscribe).call(this);
            if (trial === errorObject) {
                hasErrors = true;
                errors = errors || (errorObject.e instanceof UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);
            }
        }
        if (isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject(sub)) {
                    var trial = tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject.e;
                        if (err instanceof UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function') {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            this._parent = parent;
        }
        else if (!_parents) {
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = typeof Symbol === 'function'
    ? /*@__PURE__*/ Symbol('rxSubscriber')
    : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();

/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
var Subscriber = /*@__PURE__*/ (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        _this._parentSubscription = null;
        switch (arguments.length) {
            case 0:
                _this.destination = empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        this._parentSubscription = null;
        return this;
    };
    return Subscriber;
}(Subscription));
var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== empty) {
                context = Object.create(observerOrNext);
                if (isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}

/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber]) {
            return nextOrObserver[rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber(empty);
    }
    return new Subscriber(nextOrObserver, error, complete);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }

/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */

function pipeFromArray(fns) {
    if (!fns) {
        return noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}

/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
var Observable = /*@__PURE__*/ (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable$$1 = new Observable();
        observable$$1.source = this;
        observable$$1.operator = operator;
        return observable$$1;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function ObjectUnsubscribedErrorImpl() {
    Error.call(this);
    this.message = 'object unsubscribed';
    this.name = 'ObjectUnsubscribedError';
    return this;
}
ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber));
var Subject = /*@__PURE__*/ (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable));
var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator$1(source));
    };
}
var RefCountOperator$1 = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber$1(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber$1 = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
var ConnectableObservable = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount()(this);
    };
    return ConnectableObservable;
}(Observable));

var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(SubjectSubscriber));
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount$$1 = connectable._refCount;
        if (refCount$$1 <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount$$1 - 1;
        if (refCount$$1 > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */

var GroupByOperator = /*@__PURE__*/ (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber));
var GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber));
var GroupedObservable = /*@__PURE__*/ (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable));
var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
var BehaviorSubject = /*@__PURE__*/ (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject));

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var Action = /*@__PURE__*/ (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
var AsyncAction = /*@__PURE__*/ (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action));

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var QueueAction = /*@__PURE__*/ (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction));

var Scheduler = /*@__PURE__*/ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());

/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
var AsyncScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var QueueScheduler = /*@__PURE__*/ (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
var queue = /*@__PURE__*/ new QueueScheduler(QueueAction);

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });
function empty$1(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        if (!subscriber.closed) {
            subscriber.complete();
        }
    };
};

/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToArray(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var i = 0;
            sub.add(scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                    return;
                }
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    sub.add(this.schedule());
                }
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function scalar(value) {
    var result = new Observable(function (subscriber) {
        subscriber.next(value);
        subscriber.complete();
    });
    result._isScalar = true;
    result.value = value;
    return result;
}

/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler(scheduler)) {
        args.pop();
    }
    else {
        scheduler = undefined;
    }
    switch (args.length) {
        case 0:
            return empty$1(scheduler);
        case 1:
            return scheduler ? fromArray(args, scheduler) : scalar(args[0]);
        default:
            return fromArray(args, scheduler);
    }
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
var Notification = /*@__PURE__*/ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of(this.value);
            case 'E':
                return throwError(this.error);
            case 'C':
                return empty$1();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */

var ObserveOnOperator = /*@__PURE__*/ (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber));
var ObserveOnMessage = /*@__PURE__*/ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
var ReplaySubject = /*@__PURE__*/ (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject));
var ReplayEvent = /*@__PURE__*/ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
var AsyncSubject = /*@__PURE__*/ (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var tasksByHandle = {};
function runIfPresent(handle) {
    var cb = tasksByHandle[handle];
    if (cb) {
        cb();
    }
}
var Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(function () { return runIfPresent(handle); });
        return handle;
    },
    clearImmediate: function (handle) {
        delete tasksByHandle[handle];
    },
};

/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
var AsapAction = /*@__PURE__*/ (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AsapScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
var asap = /*@__PURE__*/ new AsapScheduler(AsapAction);

/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
var animationFrame = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);

/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
            SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
            maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler));
var VirtualAction = /*@__PURE__*/ (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) {
            index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function ArgumentOutOfRangeErrorImpl() {
    Error.call(this);
    this.message = 'argument out of range';
    this.name = 'ArgumentOutOfRangeError';
    return this;
}
ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function EmptyErrorImpl() {
    Error.call(this);
    this.message = 'no elements in sequence';
    this.name = 'EmptyError';
    return this;
}
EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var EmptyError = EmptyErrorImpl;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
var MapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var OuterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var InnerSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, hostReportError);
        return subscriber;
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator$$1 = iterable[iterator]();
        do {
            var item = iterator$$1.next();
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        if (typeof iterator$$1.return === 'function') {
            subscriber.add(function () {
                if (iterator$$1.return) {
                    iterator$$1.return();
                }
            });
        }
        return subscriber;
    };
};

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== 'function') {
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}

/** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
var subscribeTo = function (result) {
    if (result instanceof Observable) {
        return function (subscriber) {
            if (result._isScalar) {
                subscriber.next(result.value);
                subscriber.complete();
                return undefined;
            }
            else {
                return result.subscribe(subscriber);
            }
        };
    }
    else if (result && typeof result[observable] === 'function') {
        return subscribeToObservable(result);
    }
    else if (isArrayLike(result)) {
        return subscribeToArray(result);
    }
    else if (isPromise(result)) {
        return subscribeToPromise(result);
    }
    else if (result && typeof result[iterator] === 'function') {
        return subscribeToIterable(result);
    }
    else {
        var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
    if (destination === void 0) {
        destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    }
    if (destination.closed) {
        return;
    }
    return subscribeTo(result)(destination);
}

/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
var NONE = {};

var CombineLatestOperator = /*@__PURE__*/ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
function isInteropObservable(input) {
    return input && typeof input[observable] === 'function';
}

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
function isIterable(input) {
    return input && typeof input[iterator] === 'function';
}

/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */
function fromPromise(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToPromise(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                return input.then(function (value) {
                    sub.add(scheduler.schedule(function () {
                        subscriber.next(value);
                        sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                    }));
                }, function (err) {
                    sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
                });
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */
function fromIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    if (!scheduler) {
        return new Observable(subscribeToIterable(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var iterator$$1;
            sub.add(function () {
                if (iterator$$1 && typeof iterator$$1.return === 'function') {
                    iterator$$1.return();
                }
            });
            sub.add(scheduler.schedule(function () {
                iterator$$1 = input[iterator]();
                sub.add(scheduler.schedule(function () {
                    if (subscriber.closed) {
                        return;
                    }
                    var value;
                    var done;
                    try {
                        var result = iterator$$1.next();
                        value = result.value;
                        done = result.done;
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                        this.schedule();
                    }
                }));
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */
function fromObservable(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToObservable(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                var observable$$1 = input[observable]();
                sub.add(observable$$1.subscribe({
                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                }));
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable) {
            return input;
        }
        return new Observable(subscribeTo(input));
    }
    if (input != null) {
        if (isInteropObservable(input)) {
            return fromObservable(input, scheduler);
        }
        else if (isPromise(input)) {
            return fromPromise(input, scheduler);
        }
        else if (isArrayLike(input)) {
            return fromArray(input, scheduler);
        }
        else if (isIterable(input) || typeof input === 'string') {
            return fromIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}

/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult(this, ish, value, index, innerSubscriber);
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */

/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_isScheduler,_of,_from,_operators_concatAll PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Observable,_util_isArray,_empty,_util_subscribeToResult,_OuterSubscriber,_operators_map PURE_IMPORTS_END */

var ForkJoinSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ForkJoinSubscriber, _super);
    function ForkJoinSubscriber(destination, sources) {
        var _this = _super.call(this, destination) || this;
        _this.sources = sources;
        _this.completed = 0;
        _this.haveValues = 0;
        var len = sources.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            var source = sources[i];
            var innerSubscription = subscribeToResult(_this, source, null, i);
            if (innerSubscription) {
                _this.add(innerSubscription);
            }
        }
        return _this;
    }
    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        if (!innerSub._hasValue) {
            innerSub._hasValue = true;
            this.haveValues++;
        }
    };
    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
        var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;
        var len = values.length;
        if (!innerSub._hasValue) {
            destination.complete();
            return;
        }
        this.completed++;
        if (this.completed !== len) {
            return;
        }
        if (haveValues === len) {
            destination.next(values);
        }
        destination.complete();
    };
    return ForkJoinSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */

/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
function isNumeric(val) {
    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;
}

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
var NEVER = /*@__PURE__*/ new Observable(noop);

/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var RaceOperator = /*@__PURE__*/ (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
var RaceSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */

var ZipOperator = /*@__PURE__*/ (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
var ZipSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (iterator$$1.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator$$1.subscribe(iterator$$1, i));
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            var result = iterator$$1.next();
            if (iterator$$1.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber));
var StaticIterator = /*@__PURE__*/ (function () {
    function StaticIterator(iterator$$1) {
        this.iterator = iterator$$1;
        this.nextResult = iterator$$1.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = /*@__PURE__*/ (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = /*@__PURE__*/ (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var AuditOperator = /*@__PURE__*/ (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = tryCatch(this.durationSelector)(value);
            if (duration === errorObject) {
                this.destination.error(errorObject.e);
            }
            else {
                var innerSubscription = subscribeToResult(this, duration);
                if (!innerSubscription || innerSubscription.closed) {
                    this.clearThrottle();
                }
                else {
                    this.add(this.throttled = innerSubscription);
                }
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var BufferOperator = /*@__PURE__*/ (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
var BufferSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(subscribeToResult(_this, closingNotifier));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var BufferCountOperator = /*@__PURE__*/ (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
var BufferCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber));
var BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */

var BufferTimeOperator = /*@__PURE__*/ (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = /*@__PURE__*/ (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}

/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */

var BufferToggleOperator = /*@__PURE__*/ (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
var BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var BufferWhenOperator = /*@__PURE__*/ (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
var BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject) {
            this.error(errorObject.e);
        }
        else {
            closingSubscription = new Subscription();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(subscribeToResult(this, closingNotifier));
            this.subscribing = false;
        }
    };
    return BufferWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var CatchOperator = /*@__PURE__*/ (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            this.add(innerSubscriber);
            subscribeToResult(this, result, undefined, undefined, innerSubscriber);
        }
    };
    return CatchSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
function concatMap(project, resultSelector) {
    return mergeMap(project, resultSelector, 1);
}

/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var CountOperator = /*@__PURE__*/ (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
var CountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var DebounceOperator = /*@__PURE__*/ (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
var DebounceSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        _this.durationSubscription = null;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult(this, duration);
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */

var DebounceTimeOperator = /*@__PURE__*/ (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$2, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber));
function dispatchNext$2(subscriber) {
    subscriber.debouncedNext();
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var DefaultIfEmptyOperator = /*@__PURE__*/ (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */

var DelayOperator = /*@__PURE__*/ (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification.createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber));
var DelayMessage = /*@__PURE__*/ (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var DelayWhenOperator = /*@__PURE__*/ (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        var index = this.index++;
        try {
            var delayNotifier = this.delayDurationSelector(value, index);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber));
var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable));
var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.unsubscribe();
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var DeMaterializeOperator = /*@__PURE__*/ (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
var DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var DistinctOperator = /*@__PURE__*/ (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
var DistinctSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add(subscribeToResult(_this, flushes));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */

var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch(this.keySelector)(value);
            if (key === errorObject) {
                return this.destination.error(errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch(this.compare)(this.key, key);
            if (result === errorObject) {
                return this.destination.error(errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */

var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop;
        _this._tapError = noop;
        _this._tapComplete = noop;
        _this._tapError = error || noop;
        _this._tapComplete = complete || noop;
        if (isFunction(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop;
            _this._tapError = observerOrNext.error || noop;
            _this._tapComplete = observerOrNext.complete || noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _tap,_util_EmptyError PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */

var TakeOperator = /*@__PURE__*/ (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var EveryOperator = /*@__PURE__*/ (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
var EverySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var SwitchFirstOperator = /*@__PURE__*/ (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
var SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */

var ExhauseMapOperator = /*@__PURE__*/ (function () {
    function ExhauseMapOperator(project) {
        this.project = project;
    }
    ExhauseMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhauseMapOperator;
}());
var ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result, value, index);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult(this, result, value, index, innerSubscriber);
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var ExpandOperator = /*@__PURE__*/ (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
var ExpandSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            var result = tryCatch(this.project)(value, index);
            if (result === errorObject) {
                destination.error(errorObject.e);
            }
            else if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
            }
            else {
                var state = { subscriber: this, result: result, value: value, index: index };
                var destination_1 = this.destination;
                destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */

var FinallyOperator = /*@__PURE__*/ (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription(callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var FindValueOperator = /*@__PURE__*/ (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());
var FindValueSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var IgnoreElementsOperator = /*@__PURE__*/ (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var IsEmptyOperator = /*@__PURE__*/ (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
var IsEmptySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */

var TakeLastOperator = /*@__PURE__*/ (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var MapToOperator = /*@__PURE__*/ (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */

var MaterializeOperator = /*@__PURE__*/ (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
var MaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var ScanOperator = /*@__PURE__*/ (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber PURE_IMPORTS_END */

var MergeScanOperator = /*@__PURE__*/ (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());
var MergeScanSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var ish = tryCatch(this.accumulator)(this.acc, value);
            var destination = this.destination;
            if (ish === errorObject) {
                destination.error(errorObject.e);
            }
            else {
                this.active++;
                this._innerSub(ish, value, index);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult(this, ish, value, index, innerSubscriber);
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */

var MulticastOperator = /*@__PURE__*/ (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());

/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */


var OnErrorResumeNextOperator = /*@__PURE__*/ (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (next) {
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            var destination = this.destination;
            destination.add(innerSubscriber);
            subscribeToResult(this, next, undefined, undefined, innerSubscriber);
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var PairwiseOperator = /*@__PURE__*/ (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */

/** PURE_IMPORTS_START _map PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */

var RepeatOperator = /*@__PURE__*/ (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var RepeatWhenOperator = /*@__PURE__*/ (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
var RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject();
        var retries = tryCatch(this.notifier)(this.notifications);
        if (retries === errorObject) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = subscribeToResult(this, retries);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var RetryOperator = /*@__PURE__*/ (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
var RetrySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var RetryWhenOperator = /*@__PURE__*/ (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
var RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject();
                retries = tryCatch(this.notifier)(errors);
                if (retries === errorObject) {
                    return _super.prototype.error.call(this, errorObject.e);
                }
                retriesSubscription = subscribeToResult(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var SampleOperator = /*@__PURE__*/ (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(subscribeToResult(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}());
var SampleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */

var SampleTimeOperator = /*@__PURE__*/ (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
var SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}

/** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */

var SequenceEqualOperator = /*@__PURE__*/ (function () {
    function SequenceEqualOperator(compareTo, comparor) {
        this.compareTo = compareTo;
        this.comparor = comparor;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));
    };
    return SequenceEqualOperator;
}());
var SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparor) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparor = comparor;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
        this.unsubscribe();
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            if (comparor) {
                areEqual = tryCatch(comparor)(a, b);
                if (areEqual === errorObject) {
                    this.destination.error(errorObject.e);
                }
            }
            else {
                areEqual = a === b;
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype.completeB = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber));
var SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
        this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent.completeB();
        this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */

/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */

var SingleOperator = /*@__PURE__*/ (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
var SingleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var SkipOperator = /*@__PURE__*/ (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */

var SkipLastOperator = /*@__PURE__*/ (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            return source.subscribe(new Subscriber(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
var SkipLastSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var SkipUntilOperator = /*@__PURE__*/ (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new InnerSubscriber(_this, undefined, undefined);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        subscribeToResult(_this, notifier, undefined, undefined, innerSubscriber);
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var SkipWhileOperator = /*@__PURE__*/ (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */
var SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
    __extends(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap;
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable));

/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

var SubscribeOnOperator = /*@__PURE__*/ (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */

var SwitchMapOperator = /*@__PURE__*/ (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = subscribeToResult(this, result, value, index, innerSubscriber);
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */

/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var TakeWhileOperator = /*@__PURE__*/ (function () {
    function TakeWhileOperator(predicate) {
        this.predicate = predicate;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
    };
    return TakeWhileOperator;
}());
var TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */


var ThrottleOperator = /*@__PURE__*/ (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = null;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (duration) {
            this.add(this._throttled = subscribeToResult(this, duration));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = null;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */

var ThrottleTimeOperator = /*@__PURE__*/ (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext$3, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber));
function dispatchNext$3(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var TimeoutWithOperator = /*@__PURE__*/ (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.action = null;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(subscribeToResult(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */

/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(subscribeToResult(windowSubscriber, this.windowBoundaries));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */

var WindowCountOperator = /*@__PURE__*/ (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
var WindowCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */

var WindowTimeOperator = /*@__PURE__*/ (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = /*@__PURE__*/ (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject));
var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var WindowToggleOperator = /*@__PURE__*/ (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
var WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingSelector = this.closingSelector;
            var closingNotifier = tryCatch(closingSelector)(innerValue);
            if (closingNotifier === errorObject) {
                return this.error(errorObject.e);
            }
            else {
                var window_1 = new Subject();
                var subscription = new Subscription();
                var context_4 = { window: window_1, subscription: subscription };
                this.contexts.push(context_4);
                var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
                if (innerSubscription.closed) {
                    this.closeWindow(this.contexts.length - 1);
                }
                else {
                    innerSubscription.context = context_4;
                    subscription.add(innerSubscription);
                }
                this.destination.next(window_1);
            }
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var WindowOperator$1 = /*@__PURE__*/ (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber$1(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
var WindowSubscriber$1 = /*@__PURE__*/ (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) {
            innerSub = null;
        }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject();
        this.destination.next(window);
        var closingNotifier = tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject) {
            var err = errorObject.e;
            this.destination.error(err);
            this.window.error(err);
        }
        else {
            this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
        }
    };
    return WindowSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var WithLatestFromOperator = /*@__PURE__*/ (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(subscribeToResult(_this, observable, observable, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/**
 * @license Angular v6.0.4
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a
 * `HttpResponse`.
 *
 * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the
 * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the
 * `HttpBackend`.
 *
 * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.
 *
 *
 */
var HttpHandler = /** @class */ (function () {
    function HttpHandler() {
    }
    return HttpHandler;
}());
/**
 * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.
 *
 * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.
 *
 * When injected, `HttpBackend` dispatches requests directly to the backend, without going
 * through the interceptor chain.
 *
 *
 */
var HttpBackend = /** @class */ (function () {
    function HttpBackend() {
    }
    return HttpBackend;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Immutable set of Http headers, with lazy parsing.
 *
 */
var HttpHeaders = /** @class */ (function () {
    function HttpHeaders(headers) {
        var _this = this;
        /**
         * Internal map of lowercased header names to the normalized
         * form of the name (the form seen first).
         */
        this.normalizedNames = new Map();
        /**
         * Queued updates to be materialized the next initialization.
         */
        this.lazyUpdate = null;
        if (!headers) {
            this.headers = new Map();
        }
        else if (typeof headers === 'string') {
            this.lazyInit = function () {
                _this.headers = new Map();
                headers.split('\n').forEach(function (line) {
                    var index = line.indexOf(':');
                    if (index > 0) {
                        var name_1 = line.slice(0, index);
                        var key = name_1.toLowerCase();
                        var value = line.slice(index + 1).trim();
                        _this.maybeSetNormalizedName(name_1, key);
                        if (_this.headers.has(key)) {
                            _this.headers.get(key).push(value);
                        }
                        else {
                            _this.headers.set(key, [value]);
                        }
                    }
                });
            };
        }
        else {
            this.lazyInit = function () {
                _this.headers = new Map();
                Object.keys(headers).forEach(function (name) {
                    var values = headers[name];
                    var key = name.toLowerCase();
                    if (typeof values === 'string') {
                        values = [values];
                    }
                    if (values.length > 0) {
                        _this.headers.set(key, values);
                        _this.maybeSetNormalizedName(name, key);
                    }
                });
            };
        }
    }
    /**
     * Checks for existence of header by given name.
     */
    HttpHeaders.prototype.has = function (name) {
        this.init();
        return this.headers.has(name.toLowerCase());
    };
    /**
     * Returns first header that matches given name.
     */
    HttpHeaders.prototype.get = function (name) {
        this.init();
        var values = this.headers.get(name.toLowerCase());
        return values && values.length > 0 ? values[0] : null;
    };
    /**
     * Returns the names of the headers
     */
    HttpHeaders.prototype.keys = function () {
        this.init();
        return Array.from(this.normalizedNames.values());
    };
    /**
     * Returns list of header values for a given name.
     */
    HttpHeaders.prototype.getAll = function (name) {
        this.init();
        return this.headers.get(name.toLowerCase()) || null;
    };
    HttpHeaders.prototype.append = function (name, value) {
        return this.clone({ name: name, value: value, op: 'a' });
    };
    HttpHeaders.prototype.set = function (name, value) {
        return this.clone({ name: name, value: value, op: 's' });
    };
    HttpHeaders.prototype.delete = function (name, value) {
        return this.clone({ name: name, value: value, op: 'd' });
    };
    HttpHeaders.prototype.maybeSetNormalizedName = function (name, lcName) {
        if (!this.normalizedNames.has(lcName)) {
            this.normalizedNames.set(lcName, name);
        }
    };
    HttpHeaders.prototype.init = function () {
        var _this = this;
        if (!!this.lazyInit) {
            if (this.lazyInit instanceof HttpHeaders) {
                this.copyFrom(this.lazyInit);
            }
            else {
                this.lazyInit();
            }
            this.lazyInit = null;
            if (!!this.lazyUpdate) {
                this.lazyUpdate.forEach(function (update) { return _this.applyUpdate(update); });
                this.lazyUpdate = null;
            }
        }
    };
    HttpHeaders.prototype.copyFrom = function (other) {
        var _this = this;
        other.init();
        Array.from(other.headers.keys()).forEach(function (key) {
            _this.headers.set(key, other.headers.get(key));
            _this.normalizedNames.set(key, other.normalizedNames.get(key));
        });
    };
    HttpHeaders.prototype.clone = function (update) {
        var clone = new HttpHeaders();
        clone.lazyInit =
            (!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;
        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
        return clone;
    };
    HttpHeaders.prototype.applyUpdate = function (update) {
        var key = update.name.toLowerCase();
        switch (update.op) {
            case 'a':
            case 's':
                var value = update.value;
                if (typeof value === 'string') {
                    value = [value];
                }
                if (value.length === 0) {
                    return;
                }
                this.maybeSetNormalizedName(update.name, key);
                var base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];
                base.push.apply(base, __spread(value));
                this.headers.set(key, base);
                break;
            case 'd':
                var toDelete_1 = update.value;
                if (!toDelete_1) {
                    this.headers.delete(key);
                    this.normalizedNames.delete(key);
                }
                else {
                    var existing = this.headers.get(key);
                    if (!existing) {
                        return;
                    }
                    existing = existing.filter(function (value) { return toDelete_1.indexOf(value) === -1; });
                    if (existing.length === 0) {
                        this.headers.delete(key);
                        this.normalizedNames.delete(key);
                    }
                    else {
                        this.headers.set(key, existing);
                    }
                }
                break;
        }
    };
    /**
     * @internal
     */
    HttpHeaders.prototype.forEach = function (fn) {
        var _this = this;
        this.init();
        Array.from(this.normalizedNames.keys())
            .forEach(function (key) { return fn(_this.normalizedNames.get(key), _this.headers.get(key)); });
    };
    return HttpHeaders;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to
 * serialize and parse URL parameter keys and values.
 *
 *
 */
var HttpUrlEncodingCodec = /** @class */ (function () {
    function HttpUrlEncodingCodec() {
    }
    HttpUrlEncodingCodec.prototype.encodeKey = function (k) { return standardEncoding(k); };
    HttpUrlEncodingCodec.prototype.encodeValue = function (v) { return standardEncoding(v); };
    HttpUrlEncodingCodec.prototype.decodeKey = function (k) { return decodeURIComponent(k); };
    HttpUrlEncodingCodec.prototype.decodeValue = function (v) { return decodeURIComponent(v); };
    return HttpUrlEncodingCodec;
}());
function paramParser(rawParams, codec) {
    var map$$1 = new Map();
    if (rawParams.length > 0) {
        var params = rawParams.split('&');
        params.forEach(function (param) {
            var eqIdx = param.indexOf('=');
            var _a = __read(eqIdx == -1 ?
                [codec.decodeKey(param), ''] :
                [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))], 2), key = _a[0], val = _a[1];
            var list = map$$1.get(key) || [];
            list.push(val);
            map$$1.set(key, list);
        });
    }
    return map$$1;
}
function standardEncoding(v) {
    return encodeURIComponent(v)
        .replace(/%40/gi, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/gi, '$')
        .replace(/%2C/gi, ',')
        .replace(/%3B/gi, ';')
        .replace(/%2B/gi, '+')
        .replace(/%3D/gi, '=')
        .replace(/%3F/gi, '?')
        .replace(/%2F/gi, '/');
}
/**
 * An HTTP request/response body that represents serialized parameters,
 * per the MIME type `application/x-www-form-urlencoded`.
 *
 * This class is immutable - all mutation operations return a new instance.
 *
 *
 */
var HttpParams = /** @class */ (function () {
    function HttpParams(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.updates = null;
        this.cloneFrom = null;
        this.encoder = options.encoder || new HttpUrlEncodingCodec();
        if (!!options.fromString) {
            if (!!options.fromObject) {
                throw new Error("Cannot specify both fromString and fromObject.");
            }
            this.map = paramParser(options.fromString, this.encoder);
        }
        else if (!!options.fromObject) {
            this.map = new Map();
            Object.keys(options.fromObject).forEach(function (key) {
                var value = options.fromObject[key];
                _this.map.set(key, Array.isArray(value) ? value : [value]);
            });
        }
        else {
            this.map = null;
        }
    }
    /**
     * Check whether the body has one or more values for the given parameter name.
     */
    HttpParams.prototype.has = function (param) {
        this.init();
        return this.map.has(param);
    };
    /**
     * Get the first value for the given parameter name, or `null` if it's not present.
     */
    HttpParams.prototype.get = function (param) {
        this.init();
        var res = this.map.get(param);
        return !!res ? res[0] : null;
    };
    /**
     * Get all values for the given parameter name, or `null` if it's not present.
     */
    HttpParams.prototype.getAll = function (param) {
        this.init();
        return this.map.get(param) || null;
    };
    /**
     * Get all the parameter names for this body.
     */
    HttpParams.prototype.keys = function () {
        this.init();
        return Array.from(this.map.keys());
    };
    /**
     * Construct a new body with an appended value for the given parameter name.
     */
    HttpParams.prototype.append = function (param, value) { return this.clone({ param: param, value: value, op: 'a' }); };
    /**
     * Construct a new body with a new value for the given parameter name.
     */
    HttpParams.prototype.set = function (param, value) { return this.clone({ param: param, value: value, op: 's' }); };
    /**
     * Construct a new body with either the given value for the given parameter
     * removed, if a value is given, or all values for the given parameter removed
     * if not.
     */
    HttpParams.prototype.delete = function (param, value) { return this.clone({ param: param, value: value, op: 'd' }); };
    /**
     * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are
     * separated by `&`s.
     */
    HttpParams.prototype.toString = function () {
        var _this = this;
        this.init();
        return this.keys()
            .map(function (key) {
            var eKey = _this.encoder.encodeKey(key);
            return _this.map.get(key).map(function (value) { return eKey + '=' + _this.encoder.encodeValue(value); })
                .join('&');
        })
            .join('&');
    };
    HttpParams.prototype.clone = function (update) {
        var clone = new HttpParams({ encoder: this.encoder });
        clone.cloneFrom = this.cloneFrom || this;
        clone.updates = (this.updates || []).concat([update]);
        return clone;
    };
    HttpParams.prototype.init = function () {
        var _this = this;
        if (this.map === null) {
            this.map = new Map();
        }
        if (this.cloneFrom !== null) {
            this.cloneFrom.init();
            this.cloneFrom.keys().forEach(function (key) { return _this.map.set(key, _this.cloneFrom.map.get(key)); });
            this.updates.forEach(function (update) {
                switch (update.op) {
                    case 'a':
                    case 's':
                        var base = (update.op === 'a' ? _this.map.get(update.param) : undefined) || [];
                        base.push(update.value);
                        _this.map.set(update.param, base);
                        break;
                    case 'd':
                        if (update.value !== undefined) {
                            var base_1 = _this.map.get(update.param) || [];
                            var idx = base_1.indexOf(update.value);
                            if (idx !== -1) {
                                base_1.splice(idx, 1);
                            }
                            if (base_1.length > 0) {
                                _this.map.set(update.param, base_1);
                            }
                            else {
                                _this.map.delete(update.param);
                            }
                        }
                        else {
                            _this.map.delete(update.param);
                            break;
                        }
                }
            });
            this.cloneFrom = null;
        }
    };
    return HttpParams;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Determine whether the given HTTP method may include a body.
 */
function mightHaveBody(method) {
    switch (method) {
        case 'DELETE':
        case 'GET':
        case 'HEAD':
        case 'OPTIONS':
        case 'JSONP':
            return false;
        default:
            return true;
    }
}
/**
 * Safely assert whether the given value is an ArrayBuffer.
 *
 * In some execution environments ArrayBuffer is not defined.
 */
function isArrayBuffer(value) {
    return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;
}
/**
 * Safely assert whether the given value is a Blob.
 *
 * In some execution environments Blob is not defined.
 */
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
/**
 * Safely assert whether the given value is a FormData instance.
 *
 * In some execution environments FormData is not defined.
 */
function isFormData(value) {
    return typeof FormData !== 'undefined' && value instanceof FormData;
}
/**
 * An outgoing HTTP request with an optional typed body.
 *
 * `HttpRequest` represents an outgoing request, including URL, method,
 * headers, body, and other request configuration options. Instances should be
 * assumed to be immutable. To modify a `HttpRequest`, the `clone`
 * method should be used.
 *
 *
 */
var HttpRequest = /** @class */ (function () {
    function HttpRequest(method, url, third, fourth) {
        this.url = url;
        /**
         * The request body, or `null` if one isn't set.
         *
         * Bodies are not enforced to be immutable, as they can include a reference to any
         * user-defined data type. However, interceptors should take care to preserve
         * idempotence by treating them as such.
         */
        this.body = null;
        /**
         * Whether this request should be made in a way that exposes progress events.
         *
         * Progress events are expensive (change detection runs on each event) and so
         * they should only be requested if the consumer intends to monitor them.
         */
        this.reportProgress = false;
        /**
         * Whether this request should be sent with outgoing credentials (cookies).
         */
        this.withCredentials = false;
        /**
         * The expected response type of the server.
         *
         * This is used to parse the response appropriately before returning it to
         * the requestee.
         */
        this.responseType = 'json';
        this.method = method.toUpperCase();
        // Next, need to figure out which argument holds the HttpRequestInit
        // options, if any.
        var options;
        // Check whether a body argument is expected. The only valid way to omit
        // the body argument is to use a known no-body method like GET.
        if (mightHaveBody(this.method) || !!fourth) {
            // Body is the third argument, options are the fourth.
            this.body = (third !== undefined) ? third : null;
            options = fourth;
        }
        else {
            // No body required, options are the third argument. The body stays null.
            options = third;
        }
        // If options have been passed, interpret them.
        if (options) {
            // Normalize reportProgress and withCredentials.
            this.reportProgress = !!options.reportProgress;
            this.withCredentials = !!options.withCredentials;
            // Override default response type of 'json' if one is provided.
            if (!!options.responseType) {
                this.responseType = options.responseType;
            }
            // Override headers if they're provided.
            if (!!options.headers) {
                this.headers = options.headers;
            }
            if (!!options.params) {
                this.params = options.params;
            }
        }
        // If no headers have been passed in, construct a new HttpHeaders instance.
        if (!this.headers) {
            this.headers = new HttpHeaders();
        }
        // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.
        if (!this.params) {
            this.params = new HttpParams();
            this.urlWithParams = url;
        }
        else {
            // Encode the parameters to a string in preparation for inclusion in the URL.
            var params = this.params.toString();
            if (params.length === 0) {
                // No parameters, the visible URL is just the URL given at creation time.
                this.urlWithParams = url;
            }
            else {
                // Does the URL already have query parameters? Look for '?'.
                var qIdx = url.indexOf('?');
                // There are 3 cases to handle:
                // 1) No existing parameters -> append '?' followed by params.
                // 2) '?' exists and is followed by existing query string ->
                //    append '&' followed by params.
                // 3) '?' exists at the end of the url -> append params directly.
                // This basically amounts to determining the character, if any, with
                // which to join the URL and parameters.
                var sep = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');
                this.urlWithParams = url + sep + params;
            }
        }
    }
    /**
     * Transform the free-form body into a serialized format suitable for
     * transmission to the server.
     */
    HttpRequest.prototype.serializeBody = function () {
        // If no body is present, no need to serialize it.
        if (this.body === null) {
            return null;
        }
        // Check whether the body is already in a serialized form. If so,
        // it can just be returned directly.
        if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||
            typeof this.body === 'string') {
            return this.body;
        }
        // Check whether the body is an instance of HttpUrlEncodedParams.
        if (this.body instanceof HttpParams) {
            return this.body.toString();
        }
        // Check whether the body is an object or array, and serialize with JSON if so.
        if (typeof this.body === 'object' || typeof this.body === 'boolean' ||
            Array.isArray(this.body)) {
            return JSON.stringify(this.body);
        }
        // Fall back on toString() for everything else.
        return this.body.toString();
    };
    /**
     * Examine the body and attempt to infer an appropriate MIME type
     * for it.
     *
     * If no such type can be inferred, this method will return `null`.
     */
    HttpRequest.prototype.detectContentTypeHeader = function () {
        // An empty body has no content type.
        if (this.body === null) {
            return null;
        }
        // FormData bodies rely on the browser's content type assignment.
        if (isFormData(this.body)) {
            return null;
        }
        // Blobs usually have their own content type. If it doesn't, then
        // no type can be inferred.
        if (isBlob(this.body)) {
            return this.body.type || null;
        }
        // Array buffers have unknown contents and thus no type can be inferred.
        if (isArrayBuffer(this.body)) {
            return null;
        }
        // Technically, strings could be a form of JSON data, but it's safe enough
        // to assume they're plain strings.
        if (typeof this.body === 'string') {
            return 'text/plain';
        }
        // `HttpUrlEncodedParams` has its own content-type.
        if (this.body instanceof HttpParams) {
            return 'application/x-www-form-urlencoded;charset=UTF-8';
        }
        // Arrays, objects, and numbers will be encoded as JSON.
        if (typeof this.body === 'object' || typeof this.body === 'number' ||
            Array.isArray(this.body)) {
            return 'application/json';
        }
        // No type could be inferred.
        return null;
    };
    HttpRequest.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        // For method, url, and responseType, take the current value unless
        // it is overridden in the update hash.
        var method = update.method || this.method;
        var url = update.url || this.url;
        var responseType = update.responseType || this.responseType;
        // The body is somewhat special - a `null` value in update.body means
        // whatever current body is present is being overridden with an empty
        // body, whereas an `undefined` value in update.body implies no
        // override.
        var body = (update.body !== undefined) ? update.body : this.body;
        // Carefully handle the boolean options to differentiate between
        // `false` and `undefined` in the update args.
        var withCredentials = (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;
        var reportProgress = (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;
        // Headers and params may be appended to if `setHeaders` or
        // `setParams` are used.
        var headers = update.headers || this.headers;
        var params = update.params || this.params;
        // Check whether the caller has asked to add headers.
        if (update.setHeaders !== undefined) {
            // Set every requested header.
            headers =
                Object.keys(update.setHeaders)
                    .reduce(function (headers, name) { return headers.set(name, update.setHeaders[name]); }, headers);
        }
        // Check whether the caller has asked to set params.
        if (update.setParams) {
            // Set every requested param.
            params = Object.keys(update.setParams)
                .reduce(function (params, param) { return params.set(param, update.setParams[param]); }, params);
        }
        // Finally, construct the new HttpRequest using the pieces from above.
        return new HttpRequest(method, url, body, {
            params: params, headers: headers, reportProgress: reportProgress, responseType: responseType, withCredentials: withCredentials,
        });
    };
    return HttpRequest;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Type enumeration for the different kinds of `HttpEvent`.
 *
 *
 */
var HttpEventType;
(function (HttpEventType) {
    /**
     * The request was sent out over the wire.
     */
    HttpEventType[HttpEventType["Sent"] = 0] = "Sent";
    /**
     * An upload progress event was received.
     */
    HttpEventType[HttpEventType["UploadProgress"] = 1] = "UploadProgress";
    /**
     * The response status code and headers were received.
     */
    HttpEventType[HttpEventType["ResponseHeader"] = 2] = "ResponseHeader";
    /**
     * A download progress event was received.
     */
    HttpEventType[HttpEventType["DownloadProgress"] = 3] = "DownloadProgress";
    /**
     * The full response including the body was received.
     */
    HttpEventType[HttpEventType["Response"] = 4] = "Response";
    /**
     * A custom event from an interceptor or a backend.
     */
    HttpEventType[HttpEventType["User"] = 5] = "User";
})(HttpEventType || (HttpEventType = {}));
/**
 * Base class for both `HttpResponse` and `HttpHeaderResponse`.
 *
 *
 */
var HttpResponseBase = /** @class */ (function () {
    /**
     * Super-constructor for all responses.
     *
     * The single parameter accepted is an initialization hash. Any properties
     * of the response passed there will override the default values.
     */
    function HttpResponseBase(init, defaultStatus, defaultStatusText) {
        if (defaultStatus === void 0) { defaultStatus = 200; }
        if (defaultStatusText === void 0) { defaultStatusText = 'OK'; }
        // If the hash has values passed, use them to initialize the response.
        // Otherwise use the default values.
        this.headers = init.headers || new HttpHeaders();
        this.status = init.status !== undefined ? init.status : defaultStatus;
        this.statusText = init.statusText || defaultStatusText;
        this.url = init.url || null;
        // Cache the ok value to avoid defining a getter.
        this.ok = this.status >= 200 && this.status < 300;
    }
    return HttpResponseBase;
}());
/**
 * A partial HTTP response which only includes the status and header data,
 * but no response body.
 *
 * `HttpHeaderResponse` is a `HttpEvent` available on the response
 * event stream, only when progress events are requested.
 *
 *
 */
var HttpHeaderResponse = /** @class */ (function (_super) {
    __extends(HttpHeaderResponse, _super);
    /**
     * Create a new `HttpHeaderResponse` with the given parameters.
     */
    function HttpHeaderResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.ResponseHeader;
        return _this;
    }
    /**
     * Copy this `HttpHeaderResponse`, overriding its contents with the
     * given parameter hash.
     */
    HttpHeaderResponse.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        // Perform a straightforward initialization of the new HttpHeaderResponse,
        // overriding the current parameters with new ones if given.
        return new HttpHeaderResponse({
            headers: update.headers || this.headers,
            status: update.status !== undefined ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpHeaderResponse;
}(HttpResponseBase));
/**
 * A full HTTP response, including a typed response body (which may be `null`
 * if one was not returned).
 *
 * `HttpResponse` is a `HttpEvent` available on the response event
 * stream.
 *
 *
 */
var HttpResponse = /** @class */ (function (_super) {
    __extends(HttpResponse, _super);
    /**
     * Construct a new `HttpResponse`.
     */
    function HttpResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.Response;
        _this.body = init.body !== undefined ? init.body : null;
        return _this;
    }
    HttpResponse.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        return new HttpResponse({
            body: (update.body !== undefined) ? update.body : this.body,
            headers: update.headers || this.headers,
            status: (update.status !== undefined) ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpResponse;
}(HttpResponseBase));
/**
 * A response that represents an error or failure, either from a
 * non-successful HTTP status, an error while executing the request,
 * or some other failure which occurred during the parsing of the response.
 *
 * Any error returned on the `Observable` response stream will be
 * wrapped in an `HttpErrorResponse` to provide additional context about
 * the state of the HTTP layer when the error occurred. The error property
 * will contain either a wrapped Error object or the error response returned
 * from the server.
 *
 *
 */
var HttpErrorResponse = /** @class */ (function (_super) {
    __extends(HttpErrorResponse, _super);
    function HttpErrorResponse(init) {
        var _this = 
        // Initialize with a default status of 0 / Unknown Error.
        _super.call(this, init, 0, 'Unknown Error') || this;
        _this.name = 'HttpErrorResponse';
        /**
         * Errors are never okay, even when the status code is in the 2xx success range.
         */
        _this.ok = false;
        // If the response was successful, then this was a parse error. Otherwise, it was
        // a protocol-level failure of some sort. Either the request failed in transit
        // or the server returned an unsuccessful status code.
        if (_this.status >= 200 && _this.status < 300) {
            _this.message = "Http failure during parsing for " + (init.url || '(unknown url)');
        }
        else {
            _this.message =
                "Http failure response for " + (init.url || '(unknown url)') + ": " + init.status + " " + init.statusText;
        }
        _this.error = init.error || null;
        return _this;
    }
    return HttpErrorResponse;
}(HttpResponseBase));

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Construct an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and
 * the given `body`. Basically, this clones the object and adds the body.
 */
function addBody(options, body) {
    return {
        body: body,
        headers: options.headers,
        observe: options.observe,
        params: options.params,
        reportProgress: options.reportProgress,
        responseType: options.responseType,
        withCredentials: options.withCredentials,
    };
}
/**
 * Perform HTTP requests.
 *
 * `HttpClient` is available as an injectable class, with methods to perform HTTP requests.
 * Each request method has multiple signatures, and the return type varies according to which
 * signature is called (mainly the values of `observe` and `responseType`).
 *
 *
 */
var HttpClient = /** @class */ (function () {
    function HttpClient(handler) {
        this.handler = handler;
    }
    /**
     * Constructs an `Observable` for a particular HTTP request that, when subscribed,
     * fires the request through the chain of registered interceptors and on to the
     * server.
     *
     * This method can be called in one of two ways. Either an `HttpRequest`
     * instance can be passed directly as the only parameter, or a method can be
     * passed as the first parameter, a string URL as the second, and an
     * options hash as the third.
     *
     * If a `HttpRequest` object is passed directly, an `Observable` of the
     * raw `HttpEvent` stream will be returned.
     *
     * If a request is instead built by providing a URL, the options object
     * determines the return type of `request()`. In addition to configuring
     * request parameters such as the outgoing headers and/or the body, the options
     * hash specifies two key pieces of information about the request: the
     * `responseType` and what to `observe`.
     *
     * The `responseType` value determines how a successful response body will be
     * parsed. If `responseType` is the default `json`, a type interface for the
     * resulting object may be passed as a type parameter to `request()`.
     *
     * The `observe` value determines the return type of `request()`, based on what
     * the consumer is interested in observing. A value of `events` will return an
     * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,
     * including progress events by default. A value of `response` will return an
     * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`
     * depends on the `responseType` and any optionally provided type parameter.
     * A value of `body` will return an `Observable<T>` with the same `T` body type.
     */
    HttpClient.prototype.request = function (first, url, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var req;
        // Firstly, check whether the primary argument is an instance of `HttpRequest`.
        if (first instanceof HttpRequest) {
            // It is. The other arguments must be undefined (per the signatures) and can be
            // ignored.
            req = first;
        }
        else {
            // It's a string, so it represents a URL. Construct a request based on it,
            // and incorporate the remaining arguments (assuming GET unless a method is
            // provided.
            // Figure out the headers.
            var headers = undefined;
            if (options.headers instanceof HttpHeaders) {
                headers = options.headers;
            }
            else {
                headers = new HttpHeaders(options.headers);
            }
            // Sort out parameters.
            var params = undefined;
            if (!!options.params) {
                if (options.params instanceof HttpParams) {
                    params = options.params;
                }
                else {
                    params = new HttpParams({ fromObject: options.params });
                }
            }
            // Construct the request.
            req = new HttpRequest(first, url, (options.body !== undefined ? options.body : null), {
                headers: headers,
                params: params,
                reportProgress: options.reportProgress,
                // By default, JSON is assumed to be returned for all calls.
                responseType: options.responseType || 'json',
                withCredentials: options.withCredentials,
            });
        }
        // Start with an Observable.of() the initial request, and run the handler (which
        // includes all interceptors) inside a concatMap(). This way, the handler runs
        // inside an Observable chain, which causes interceptors to be re-run on every
        // subscription (this also makes retries re-run the handler, including interceptors).
        var events$ = of(req).pipe(concatMap(function (req) { return _this.handler.handle(req); }));
        // If coming via the API signature which accepts a previously constructed HttpRequest,
        // the only option is to get the event stream. Otherwise, return the event stream if
        // that is what was requested.
        if (first instanceof HttpRequest || options.observe === 'events') {
            return events$;
        }
        // The requested stream contains either the full response or the body. In either
        // case, the first step is to filter the event stream to extract a stream of
        // responses(s).
        var res$ = events$.pipe(filter(function (event) { return event instanceof HttpResponse; }));
        // Decide which stream to return.
        switch (options.observe || 'body') {
            case 'body':
                // The requested stream is the body. Map the response stream to the response
                // body. This could be done more simply, but a misbehaving interceptor might
                // transform the response body into a different format and ignore the requested
                // responseType. Guard against this by validating that the response is of the
                // requested type.
                switch (req.responseType) {
                    case 'arraybuffer':
                        return res$.pipe(map(function (res) {
                            // Validate that the body is an ArrayBuffer.
                            if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                                throw new Error('Response is not an ArrayBuffer.');
                            }
                            return res.body;
                        }));
                    case 'blob':
                        return res$.pipe(map(function (res) {
                            // Validate that the body is a Blob.
                            if (res.body !== null && !(res.body instanceof Blob)) {
                                throw new Error('Response is not a Blob.');
                            }
                            return res.body;
                        }));
                    case 'text':
                        return res$.pipe(map(function (res) {
                            // Validate that the body is a string.
                            if (res.body !== null && typeof res.body !== 'string') {
                                throw new Error('Response is not a string.');
                            }
                            return res.body;
                        }));
                    case 'json':
                    default:
                        // No validation needed for JSON responses, as they can be of any type.
                        return res$.pipe(map(function (res) { return res.body; }));
                }
            case 'response':
                // The response stream was requested directly, so return it.
                return res$;
            default:
                // Guard against new future observe types being added.
                throw new Error("Unreachable: unhandled observe type " + options.observe + "}");
        }
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * DELETE request to be executed on the server. See the individual overloads for
     * details of `delete()`'s return type based on the provided options.
     */
    HttpClient.prototype.delete = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('DELETE', url, options);
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * GET request to be executed on the server. See the individual overloads for
     * details of `get()`'s return type based on the provided options.
     */
    HttpClient.prototype.get = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('GET', url, options);
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * HEAD request to be executed on the server. See the individual overloads for
     * details of `head()`'s return type based on the provided options.
     */
    HttpClient.prototype.head = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('HEAD', url, options);
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause a request
     * with the special method `JSONP` to be dispatched via the interceptor pipeline.
     *
     * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).
     * If no such interceptor is reached, then the `JSONP` request will likely be
     * rejected by the configured backend.
     */
    HttpClient.prototype.jsonp = function (url, callbackParam) {
        return this.request('JSONP', url, {
            params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),
            observe: 'body',
            responseType: 'json',
        });
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * OPTIONS request to be executed on the server. See the individual overloads for
     * details of `options()`'s return type based on the provided options.
     */
    HttpClient.prototype.options = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('OPTIONS', url, options);
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * PATCH request to be executed on the server. See the individual overloads for
     * details of `patch()`'s return type based on the provided options.
     */
    HttpClient.prototype.patch = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PATCH', url, addBody(options, body));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     */
    HttpClient.prototype.post = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('POST', url, addBody(options, body));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     */
    HttpClient.prototype.put = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PUT', url, addBody(options, body));
    };
    HttpClient.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HttpClient.ctorParameters = function () { return [
        { type: HttpHandler }
    ]; };
    return HttpClient;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.
 *
 *
 */
var HttpInterceptorHandler = /** @class */ (function () {
    function HttpInterceptorHandler(next, interceptor) {
        this.next = next;
        this.interceptor = interceptor;
    }
    HttpInterceptorHandler.prototype.handle = function (req) {
        return this.interceptor.intercept(req, this.next);
    };
    return HttpInterceptorHandler;
}());
/**
 * A multi-provider token which represents the array of `HttpInterceptor`s that
 * are registered.
 *
 *
 */
var HTTP_INTERCEPTORS = new InjectionToken('HTTP_INTERCEPTORS');
var NoopInterceptor = /** @class */ (function () {
    function NoopInterceptor() {
    }
    NoopInterceptor.prototype.intercept = function (req, next) {
        return next.handle(req);
    };
    NoopInterceptor.decorators = [
        { type: Injectable }
    ];
    return NoopInterceptor;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Every request made through JSONP needs a callback name that's unique across the
// whole page. Each request is assigned an id and the callback name is constructed
// from that. The next id to be assigned is tracked in a global variable here that
// is shared among all applications on the page.
var nextRequestId = 0;
// Error text given when a JSONP script is injected, but doesn't invoke the callback
// passed in its URL.
var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
// Error text given when a request is passed to the JsonpClientBackend that doesn't
// have a request method JSONP.
var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';
var JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';
/**
 * DI token/abstract type representing a map of JSONP callbacks.
 *
 * In the browser, this should always be the `window` object.
 *
 *
 */
var JsonpCallbackContext = /** @class */ (function () {
    function JsonpCallbackContext() {
    }
    return JsonpCallbackContext;
}());
/**
 * `HttpBackend` that only processes `HttpRequest` with the JSONP method,
 * by performing JSONP style requests.
 *
 *
 */
var JsonpClientBackend = /** @class */ (function () {
    function JsonpClientBackend(callbackMap, document) {
        this.callbackMap = callbackMap;
        this.document = document;
    }
    /**
     * Get the name of the next callback method, by incrementing the global `nextRequestId`.
     */
    JsonpClientBackend.prototype.nextCallback = function () { return "ng_jsonp_callback_" + nextRequestId++; };
    /**
     * Process a JSONP request and return an event stream of the results.
     */
    JsonpClientBackend.prototype.handle = function (req) {
        var _this = this;
        // Firstly, check both the method and response type. If either doesn't match
        // then the request was improperly routed here and cannot be handled.
        if (req.method !== 'JSONP') {
            throw new Error(JSONP_ERR_WRONG_METHOD);
        }
        else if (req.responseType !== 'json') {
            throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
        }
        // Everything else happens inside the Observable boundary.
        return new Observable(function (observer) {
            // The first step to make a request is to generate the callback name, and replace the
            // callback placeholder in the URL with the name. Care has to be taken here to ensure
            // a trailing &, if matched, gets inserted back into the URL in the correct place.
            var callback = _this.nextCallback();
            var url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, "=" + callback + "$1");
            // Construct the <script> tag and point it at the URL.
            var node = _this.document.createElement('script');
            node.src = url;
            // A JSONP request requires waiting for multiple callbacks. These variables
            // are closed over and track state across those callbacks.
            // The response object, if one has been received, or null otherwise.
            var body = null;
            // Whether the response callback has been called.
            var finished = false;
            // Whether the request has been cancelled (and thus any other callbacks)
            // should be ignored.
            var cancelled = false;
            // Set the response callback in this.callbackMap (which will be the window
            // object in the browser. The script being loaded via the <script> tag will
            // eventually call this callback.
            _this.callbackMap[callback] = function (data) {
                // Data has been received from the JSONP script. Firstly, delete this callback.
                delete _this.callbackMap[callback];
                // Next, make sure the request wasn't cancelled in the meantime.
                if (cancelled) {
                    return;
                }
                // Set state to indicate data was received.
                body = data;
                finished = true;
            };
            // cleanup() is a utility closure that removes the <script> from the page and
            // the response callback from the window. This logic is used in both the
            // success, error, and cancellation paths, so it's extracted out for convenience.
            var cleanup = function () {
                // Remove the <script> tag if it's still on the page.
                if (node.parentNode) {
                    node.parentNode.removeChild(node);
                }
                // Remove the response callback from the callbackMap (window object in the
                // browser).
                delete _this.callbackMap[callback];
            };
            // onLoad() is the success callback which runs after the response callback
            // if the JSONP script loads successfully. The event itself is unimportant.
            // If something went wrong, onLoad() may run without the response callback
            // having been invoked.
            var onLoad = function (event) {
                // Do nothing if the request has been cancelled.
                if (cancelled) {
                    return;
                }
                // Cleanup the page.
                cleanup();
                // Check whether the response callback has run.
                if (!finished) {
                    // It hasn't, something went wrong with the request. Return an error via
                    // the Observable error path. All JSONP errors have status 0.
                    observer.error(new HttpErrorResponse({
                        url: url,
                        status: 0,
                        statusText: 'JSONP Error',
                        error: new Error(JSONP_ERR_NO_CALLBACK),
                    }));
                    return;
                }
                // Success. body either contains the response body or null if none was
                // returned.
                observer.next(new HttpResponse({
                    body: body,
                    status: 200,
                    statusText: 'OK', url: url,
                }));
                // Complete the stream, the response is over.
                observer.complete();
            };
            // onError() is the error callback, which runs if the script returned generates
            // a Javascript error. It emits the error via the Observable error channel as
            // a HttpErrorResponse.
            var onError = function (error) {
                // If the request was already cancelled, no need to emit anything.
                if (cancelled) {
                    return;
                }
                cleanup();
                // Wrap the error in a HttpErrorResponse.
                observer.error(new HttpErrorResponse({
                    error: error,
                    status: 0,
                    statusText: 'JSONP Error', url: url,
                }));
            };
            // Subscribe to both the success (load) and error events on the <script> tag,
            // and add it to the page.
            node.addEventListener('load', onLoad);
            node.addEventListener('error', onError);
            _this.document.body.appendChild(node);
            // The request has now been successfully sent.
            observer.next({ type: HttpEventType.Sent });
            // Cancellation handler.
            return function () {
                // Track the cancellation so event listeners won't do anything even if already scheduled.
                cancelled = true;
                // Remove the event listeners so they won't run if the events later fire.
                node.removeEventListener('load', onLoad);
                node.removeEventListener('error', onError);
                // And finally, clean up the page.
                cleanup();
            };
        });
    };
    JsonpClientBackend.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    JsonpClientBackend.ctorParameters = function () { return [
        { type: JsonpCallbackContext },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    return JsonpClientBackend;
}());
/**
 * An `HttpInterceptor` which identifies requests with the method JSONP and
 * shifts them to the `JsonpClientBackend`.
 *
 *
 */
var JsonpInterceptor = /** @class */ (function () {
    function JsonpInterceptor(jsonp) {
        this.jsonp = jsonp;
    }
    JsonpInterceptor.prototype.intercept = function (req, next) {
        if (req.method === 'JSONP') {
            return this.jsonp.handle(req);
        }
        // Fall through for normal HTTP requests.
        return next.handle(req);
    };
    JsonpInterceptor.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    JsonpInterceptor.ctorParameters = function () { return [
        { type: JsonpClientBackend }
    ]; };
    return JsonpInterceptor;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSSI_PREFIX = /^\)\]\}',?\n/;
/**
 * Determine an appropriate URL for the response, by checking either
 * XMLHttpRequest.responseURL or the X-Request-URL header.
 */
function getResponseUrl(xhr) {
    if ('responseURL' in xhr && xhr.responseURL) {
        return xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
        return xhr.getResponseHeader('X-Request-URL');
    }
    return null;
}
/**
 * A wrapper around the `XMLHttpRequest` constructor.
 *
 *
 */
var XhrFactory = /** @class */ (function () {
    function XhrFactory() {
    }
    return XhrFactory;
}());
/**
 * A factory for @{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.
 *
 *
 */
var BrowserXhr = /** @class */ (function () {
    function BrowserXhr() {
    }
    BrowserXhr.prototype.build = function () { return (new XMLHttpRequest()); };
    BrowserXhr.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    BrowserXhr.ctorParameters = function () { return []; };
    return BrowserXhr;
}());
/**
 * An `HttpBackend` which uses the XMLHttpRequest API to send
 * requests to a backend server.
 *
 *
 */
var HttpXhrBackend = /** @class */ (function () {
    function HttpXhrBackend(xhrFactory) {
        this.xhrFactory = xhrFactory;
    }
    /**
     * Process a request and return a stream of response events.
     */
    HttpXhrBackend.prototype.handle = function (req) {
        var _this = this;
        // Quick check to give a better error message when a user attempts to use
        // HttpClient.jsonp() without installing the JsonpClientModule
        if (req.method === 'JSONP') {
            throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed.");
        }
        // Everything happens on Observable subscription.
        return new Observable(function (observer) {
            // Start by setting up the XHR object with request method, URL, and withCredentials flag.
            var xhr = _this.xhrFactory.build();
            xhr.open(req.method, req.urlWithParams);
            if (!!req.withCredentials) {
                xhr.withCredentials = true;
            }
            // Add all the requested headers.
            req.headers.forEach(function (name, values) { return xhr.setRequestHeader(name, values.join(',')); });
            // Add an Accept header if one isn't present already.
            if (!req.headers.has('Accept')) {
                xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');
            }
            // Auto-detect the Content-Type header if one isn't present already.
            if (!req.headers.has('Content-Type')) {
                var detectedType = req.detectContentTypeHeader();
                // Sometimes Content-Type detection fails.
                if (detectedType !== null) {
                    xhr.setRequestHeader('Content-Type', detectedType);
                }
            }
            // Set the responseType if one was requested.
            if (req.responseType) {
                var responseType = req.responseType.toLowerCase();
                // JSON responses need to be processed as text. This is because if the server
                // returns an XSSI-prefixed JSON response, the browser will fail to parse it,
                // xhr.response will be null, and xhr.responseText cannot be accessed to
                // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON
                // is parsed by first requesting text and then applying JSON.parse.
                xhr.responseType = ((responseType !== 'json') ? responseType : 'text');
            }
            // Serialize the request body if one is present. If not, this will be set to null.
            var reqBody = req.serializeBody();
            // If progress events are enabled, response headers will be delivered
            // in two events - the HttpHeaderResponse event and the full HttpResponse
            // event. However, since response headers don't change in between these
            // two events, it doesn't make sense to parse them twice. So headerResponse
            // caches the data extracted from the response whenever it's first parsed,
            // to ensure parsing isn't duplicated.
            var headerResponse = null;
            // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest
            // state, and memoizes it into headerResponse.
            var partialFromXhr = function () {
                if (headerResponse !== null) {
                    return headerResponse;
                }
                // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).
                var status = xhr.status === 1223 ? 204 : xhr.status;
                var statusText = xhr.statusText || 'OK';
                // Parse headers from XMLHttpRequest - this step is lazy.
                var headers = new HttpHeaders(xhr.getAllResponseHeaders());
                // Read the response URL from the XMLHttpResponse instance and fall back on the
                // request URL.
                var url = getResponseUrl(xhr) || req.url;
                // Construct the HttpHeaderResponse and memoize it.
                headerResponse = new HttpHeaderResponse({ headers: headers, status: status, statusText: statusText, url: url });
                return headerResponse;
            };
            // Next, a few closures are defined for the various events which XMLHttpRequest can
            // emit. This allows them to be unregistered as event listeners later.
            // First up is the load event, which represents a response being fully available.
            var onLoad = function () {
                // Read response state from the memoized partial data.
                var _a = partialFromXhr(), headers = _a.headers, status = _a.status, statusText = _a.statusText, url = _a.url;
                // The body will be read out if present.
                var body = null;
                if (status !== 204) {
                    // Use XMLHttpRequest.response if set, responseText otherwise.
                    body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;
                }
                // Normalize another potential bug (this one comes from CORS).
                if (status === 0) {
                    status = !!body ? 200 : 0;
                }
                // ok determines whether the response will be transmitted on the event or
                // error channel. Unsuccessful status codes (not 2xx) will always be errors,
                // but a successful status code can still result in an error if the user
                // asked for JSON data and the body cannot be parsed as such.
                var ok = status >= 200 && status < 300;
                // Check whether the body needs to be parsed as JSON (in many cases the browser
                // will have done that already).
                if (req.responseType === 'json' && typeof body === 'string') {
                    // Save the original body, before attempting XSSI prefix stripping.
                    var originalBody = body;
                    body = body.replace(XSSI_PREFIX, '');
                    try {
                        // Attempt the parse. If it fails, a parse error should be delivered to the user.
                        body = body !== '' ? JSON.parse(body) : null;
                    }
                    catch (error) {
                        // Since the JSON.parse failed, it's reasonable to assume this might not have been a
                        // JSON response. Restore the original body (including any XSSI prefix) to deliver
                        // a better error response.
                        body = originalBody;
                        // If this was an error request to begin with, leave it as a string, it probably
                        // just isn't JSON. Otherwise, deliver the parsing error to the user.
                        if (ok) {
                            // Even though the response status was 2xx, this is still an error.
                            ok = false;
                            // The parse error contains the text of the body that failed to parse.
                            body = { error: error, text: body };
                        }
                    }
                }
                if (ok) {
                    // A successful response is delivered on the event stream.
                    observer.next(new HttpResponse({
                        body: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                    // The full body has been received and delivered, no further events
                    // are possible. This request is complete.
                    observer.complete();
                }
                else {
                    // An unsuccessful request is delivered on the error channel.
                    observer.error(new HttpErrorResponse({
                        // The error in this case is the response body (error from the server).
                        error: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                }
            };
            // The onError callback is called when something goes wrong at the network level.
            // Connection timeout, DNS error, offline, etc. These are actual errors, and are
            // transmitted on the error channel.
            var onError = function (error) {
                var res = new HttpErrorResponse({
                    error: error,
                    status: xhr.status || 0,
                    statusText: xhr.statusText || 'Unknown Error',
                });
                observer.error(res);
            };
            // The sentHeaders flag tracks whether the HttpResponseHeaders event
            // has been sent on the stream. This is necessary to track if progress
            // is enabled since the event will be sent on only the first download
            // progerss event.
            var sentHeaders = false;
            // The download progress event handler, which is only registered if
            // progress events are enabled.
            var onDownProgress = function (event) {
                // Send the HttpResponseHeaders event if it hasn't been sent already.
                if (!sentHeaders) {
                    observer.next(partialFromXhr());
                    sentHeaders = true;
                }
                // Start building the download progress event to deliver on the response
                // event stream.
                var progressEvent = {
                    type: HttpEventType.DownloadProgress,
                    loaded: event.loaded,
                };
                // Set the total number of bytes in the event if it's available.
                if (event.lengthComputable) {
                    progressEvent.total = event.total;
                }
                // If the request was for text content and a partial response is
                // available on XMLHttpRequest, include it in the progress event
                // to allow for streaming reads.
                if (req.responseType === 'text' && !!xhr.responseText) {
                    progressEvent.partialText = xhr.responseText;
                }
                // Finally, fire the event.
                observer.next(progressEvent);
            };
            // The upload progress event handler, which is only registered if
            // progress events are enabled.
            var onUpProgress = function (event) {
                // Upload progress events are simpler. Begin building the progress
                // event.
                var progress = {
                    type: HttpEventType.UploadProgress,
                    loaded: event.loaded,
                };
                // If the total number of bytes being uploaded is available, include
                // it.
                if (event.lengthComputable) {
                    progress.total = event.total;
                }
                // Send the event.
                observer.next(progress);
            };
            // By default, register for load and error events.
            xhr.addEventListener('load', onLoad);
            xhr.addEventListener('error', onError);
            // Progress events are only enabled if requested.
            if (req.reportProgress) {
                // Download progress is always enabled if requested.
                xhr.addEventListener('progress', onDownProgress);
                // Upload progress depends on whether there is a body to upload.
                if (reqBody !== null && xhr.upload) {
                    xhr.upload.addEventListener('progress', onUpProgress);
                }
            }
            // Fire the request, and notify the event stream that it was fired.
            xhr.send(reqBody);
            observer.next({ type: HttpEventType.Sent });
            // This is the return from the Observable function, which is the
            // request cancellation handler.
            return function () {
                // On a cancellation, remove all registered event listeners.
                xhr.removeEventListener('error', onError);
                xhr.removeEventListener('load', onLoad);
                if (req.reportProgress) {
                    xhr.removeEventListener('progress', onDownProgress);
                    if (reqBody !== null && xhr.upload) {
                        xhr.upload.removeEventListener('progress', onUpProgress);
                    }
                }
                // Finally, abort the in-flight request.
                xhr.abort();
            };
        });
    };
    HttpXhrBackend.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HttpXhrBackend.ctorParameters = function () { return [
        { type: XhrFactory }
    ]; };
    return HttpXhrBackend;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSRF_COOKIE_NAME = new InjectionToken('XSRF_COOKIE_NAME');
var XSRF_HEADER_NAME = new InjectionToken('XSRF_HEADER_NAME');
/**
 * Retrieves the current XSRF token to use with the next outgoing request.
 *
 *
 */
var HttpXsrfTokenExtractor = /** @class */ (function () {
    function HttpXsrfTokenExtractor() {
    }
    return HttpXsrfTokenExtractor;
}());
/**
 * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.
 */
var HttpXsrfCookieExtractor = /** @class */ (function () {
    function HttpXsrfCookieExtractor(doc, platform, cookieName) {
        this.doc = doc;
        this.platform = platform;
        this.cookieName = cookieName;
        this.lastCookieString = '';
        this.lastToken = null;
        /**
         * @internal for testing
         */
        this.parseCount = 0;
    }
    HttpXsrfCookieExtractor.prototype.getToken = function () {
        if (this.platform === 'server') {
            return null;
        }
        var cookieString = this.doc.cookie || '';
        if (cookieString !== this.lastCookieString) {
            this.parseCount++;
            this.lastToken = ÉµparseCookieValue(cookieString, this.cookieName);
            this.lastCookieString = cookieString;
        }
        return this.lastToken;
    };
    HttpXsrfCookieExtractor.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HttpXsrfCookieExtractor.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: String, decorators: [{ type: Inject, args: [XSRF_COOKIE_NAME,] }] }
    ]; };
    return HttpXsrfCookieExtractor;
}());
/**
 * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.
 */
var HttpXsrfInterceptor = /** @class */ (function () {
    function HttpXsrfInterceptor(tokenService, headerName) {
        this.tokenService = tokenService;
        this.headerName = headerName;
    }
    HttpXsrfInterceptor.prototype.intercept = function (req, next) {
        var lcUrl = req.url.toLowerCase();
        // Skip both non-mutating requests and absolute URLs.
        // Non-mutating requests don't require a token, and absolute URLs require special handling
        // anyway as the cookie set
        // on our origin is not the same as the token expected by another origin.
        if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||
            lcUrl.startsWith('https://')) {
            return next.handle(req);
        }
        var token = this.tokenService.getToken();
        // Be careful not to overwrite an existing header of the same name.
        if (token !== null && !req.headers.has(this.headerName)) {
            req = req.clone({ headers: req.headers.set(this.headerName, token) });
        }
        return next.handle(req);
    };
    HttpXsrfInterceptor.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HttpXsrfInterceptor.ctorParameters = function () { return [
        { type: HttpXsrfTokenExtractor },
        { type: String, decorators: [{ type: Inject, args: [XSRF_HEADER_NAME,] }] }
    ]; };
    return HttpXsrfInterceptor;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An `HttpHandler` that applies a bunch of `HttpInterceptor`s
 * to a request before passing it to the given `HttpBackend`.
 *
 * The interceptors are loaded lazily from the injector, to allow
 * interceptors to themselves inject classes depending indirectly
 * on `HttpInterceptingHandler` itself.
 */
var HttpInterceptingHandler = /** @class */ (function () {
    function HttpInterceptingHandler(backend, injector) {
        this.backend = backend;
        this.injector = injector;
        this.chain = null;
    }
    HttpInterceptingHandler.prototype.handle = function (req) {
        if (this.chain === null) {
            var interceptors = this.injector.get(HTTP_INTERCEPTORS, []);
            this.chain = interceptors.reduceRight(function (next, interceptor) { return new HttpInterceptorHandler(next, interceptor); }, this.backend);
        }
        return this.chain.handle(req);
    };
    HttpInterceptingHandler.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HttpInterceptingHandler.ctorParameters = function () { return [
        { type: HttpBackend },
        { type: Injector }
    ]; };
    return HttpInterceptingHandler;
}());
/**
 * `NgModule` which adds XSRF protection support to outgoing requests.
 *
 * Provided the server supports a cookie-based XSRF protection system, this
 * module can be used directly to configure XSRF protection with the correct
 * cookie and header names.
 *
 * If no such names are provided, the default is to use `X-XSRF-TOKEN` for
 * the header name and `XSRF-TOKEN` for the cookie name.
 *
 *
 */
var HttpClientXsrfModule = /** @class */ (function () {
    function HttpClientXsrfModule() {
    }
    /**
     * Disable the default XSRF protection.
     */
    HttpClientXsrfModule.disable = function () {
        return {
            ngModule: HttpClientXsrfModule,
            providers: [
                { provide: HttpXsrfInterceptor, useClass: NoopInterceptor },
            ],
        };
    };
    /**
     * Configure XSRF protection to use the given cookie name or header name,
     * or the default names (as described above) if not provided.
     */
    HttpClientXsrfModule.withOptions = function (options) {
        if (options === void 0) { options = {}; }
        return {
            ngModule: HttpClientXsrfModule,
            providers: [
                options.cookieName ? { provide: XSRF_COOKIE_NAME, useValue: options.cookieName } : [],
                options.headerName ? { provide: XSRF_HEADER_NAME, useValue: options.headerName } : [],
            ],
        };
    };
    HttpClientXsrfModule.decorators = [
        { type: NgModule, args: [{
                    providers: [
                        HttpXsrfInterceptor,
                        { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },
                        { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },
                        { provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN' },
                        { provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN' },
                    ],
                },] }
    ];
    return HttpClientXsrfModule;
}());
/**
 * `NgModule` which provides the `HttpClient` and associated services.
 *
 * Interceptors can be added to the chain behind `HttpClient` by binding them
 * to the multiprovider for `HTTP_INTERCEPTORS`.
 *
 *
 */
var HttpClientModule = /** @class */ (function () {
    function HttpClientModule() {
    }
    HttpClientModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        HttpClientXsrfModule.withOptions({
                            cookieName: 'XSRF-TOKEN',
                            headerName: 'X-XSRF-TOKEN',
                        }),
                    ],
                    providers: [
                        HttpClient,
                        { provide: HttpHandler, useClass: HttpInterceptingHandler },
                        HttpXhrBackend,
                        { provide: HttpBackend, useExisting: HttpXhrBackend },
                        BrowserXhr,
                        { provide: XhrFactory, useExisting: BrowserXhr },
                    ],
                },] }
    ];
    return HttpClientModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 10/1/18.
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Ketan Gote, Pratik Kelwalkar, Dattaram Gawas, Rashmi Thakkar
 *
 */
class AmexioGridColumnComponent {
    constructor() {
        /*
           Properties
           name : sort
           datatype : boolean
           version : 4.2.6 onwards
           default : true
           description : Set column Sortable.
           */
        this.sort = true;
        /*
        Properties
        name : hidden
        datatype : boolean
        version : 4.0 onwards
        default : none
        description : Hide column
        */
        this.hidden = false;
    }
}
AmexioGridColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-data-table-column', template: ``,
            },] },
];
AmexioGridColumnComponent.propDecorators = {
    text: [{ type: Input }],
    sort: [{ type: Input }],
    dataindex: [{ type: Input, args: ['data-index',] }],
    hidden: [{ type: Input }],
    datatype: [{ type: Input, args: ['data-type',] }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    summarytype: [{ type: Input, args: ['summary-type',] }],
    summarycaption: [{ type: Input, args: ['summary-caption',] }],
    width: [{ type: Input }],
    headerTemplate: [{ type: ContentChild, args: ['amexioHeaderTmpl',] }],
    bodyTemplate: [{ type: ContentChild, args: ['amexioBodyTmpl',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CommonDataService {
    /**
     * @param {?} _http
     */
    constructor(_http) {
        this._http = _http;
        this.filteredObject = [];
    }
    /**
     * @param {?} serviceUrl
     * @param {?} methodType
     * @return {?}
     */
    fetchData(serviceUrl, methodType) {
        const /** @type {?} */ requestJson = {};
        const /** @type {?} */ headers = new HttpHeaders().append('Content-Type', 'application/json;charset=UTF-8');
        if (methodType === 'post') {
            return this._http.post(serviceUrl, requestJson, { headers });
        }
        else if (methodType === 'get') {
            return this._http.get(serviceUrl, { headers });
        }
    }
    /**
     * @param {?} serviceUrl
     * @param {?} methodType
     * @param {?} requestData
     * @return {?}
     */
    uploadFile(serviceUrl, methodType, requestData) {
        const /** @type {?} */ requestJson = requestData;
        const /** @type {?} */ headers = new HttpHeaders().append('Access-Control-Allow-Origin', '*');
        if (methodType.toUpperCase() === 'POST') {
            return this._http.post(serviceUrl, requestJson, { headers });
        }
    }
}
CommonDataService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
CommonDataService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioDatagridComponent {
    /**
     * @param {?} element
     * @param {?} dataTableService
     * @param {?} cd
     * @param {?} renderer
     */
    constructor(element, dataTableService, cd, renderer) {
        this.element = element;
        this.dataTableService = dataTableService;
        this.cd = cd;
        this.renderer = renderer;
        /*
           Events
           name : rowSelect
           datatype : none
           version : none
           default : none
           description : It will gives you row clicked data.
           */
        this.rowSelect = new EventEmitter();
        /*
           Events
           name : selectedRowData
           datatype : none
           version : none
           default : none
           description : It will fire only on selection of checkbox and gives you selected record data.
           */
        this.selectedRowData = new EventEmitter();
        /*
           Events
           name : onHeaderClick
           datatype : none
           version : none
           default : none
           description : It will gives you click event and column info.
           */
        this.onHeaderClick = new EventEmitter();
        /*
           Properties
           name : groupby
           datatype :
           version : 4.0 onwards
           default : none
           description : Set True for Enable group by functionality.
           */
        this.groupby = false;
        this.rightClick = new EventEmitter();
        this.columns = [];
        this.viewRows = [];
        this.selectAll = false;
        this.tempContextMenu = [];
        this.mouseLocation = { left: 0, top: 0 };
        this.isExpanded = false;
        this.mask = true;
        this.checkIcon = 'fa fa-check';
        this.plusIcon = 'fa fa-plus';
        this.checkDefaultIcon = 'checkbox default';
        this.checkBoxSelectClass = '';
        this.selectedRows = [];
        this.sortBy = -1;
        this.globalFilterOptions = [{
                key: 'Start With', value: '1', checkedStatus: this.checkIcon,
            }, {
                key: 'Ends With', value: '2', checkedStatus: '',
            }, {
                key: 'Contains', value: '3', checkedStatus: '',
            }];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set columndefintion(value) {
        this._columndefintion = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get columndefintion() {
        return this._columndefintion;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.enablecolumnfiter) {
            this.enablecolumnfilter = this.enablecolumnfiter;
        }
        this.isExpanded = true;
        this.iconclassKey = this.plusIcon;
        if (this.enabledatafilter === true) {
            this.globalfilter = false;
        }
        if (this.selectedrowcolor == null || this.selectedrowcolor === '') {
            this.selectedrowcolor = '#dcecf7';
        }
        if (this.httpmethod && this.httpurl) {
            this.dataTableService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.responseData = response;
            }, (error) => {
            }, () => {
                this.setData(this.responseData);
            });
        }
        else if (this.data) {
            this.setData(this.data);
            this.previousData = JSON.parse(JSON.stringify(this.data));
        }
        this.componentLoaded = true;
        this.checkBoxSelectClass = this.setCheckBoxSelectClass();
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (this.previousData != null && JSON.stringify(this.previousData) !== JSON.stringify(this.data)) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setChangeData(this.data);
        }
        if (this.columnPreviewData != null && this.columndefintion != null &&
            JSON.stringify(this.columnPreviewData) !== JSON.stringify(this.columndefintion)) {
            this.columnPreviewData = JSON.parse(JSON.stringify(this.columndefintion));
            this.columns = this.columndefintion;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.columndefintion) {
            this.columns = this.columndefintion;
            this.columnPreviewData = JSON.parse(JSON.stringify(this.columndefintion));
        }
        else {
            this.createConfig();
        }
    }
    /**
     * @return {?}
     */
    createConfig() {
        let /** @type {?} */ columnRefArray = [];
        columnRefArray = this.columnRef.toArray();
        for (const /** @type {?} */ cr of columnRefArray) {
            const /** @type {?} */ columnConfig = cr;
            let /** @type {?} */ columnData;
            if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate != null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    headerTemplate: columnConfig.headerTemplate,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    bodyTemplate: columnConfig.bodyTemplate,
                    contextmenu: columnConfig.contextmenu,
                };
            }
            else if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    headerTemplate: columnConfig.headerTemplate,
                    contextmenu: columnConfig.contextmenu,
                };
            }
            else if (columnConfig.bodyTemplate != null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    bodyTemplate: columnConfig.bodyTemplate,
                    contextmenu: columnConfig.contextmenu,
                };
            }
            else if (columnConfig.bodyTemplate == null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    datatype: columnConfig.datatype,
                    contextmenu: columnConfig.contextmenu,
                };
            }
            if (columnConfig.summarytype) {
                columnData['summarytype'] = columnConfig.summarytype;
            }
            if (columnConfig.summarycaption) {
                columnData['summarycaption'] = columnConfig.summarycaption;
            }
            this.columns.push(columnData);
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setChangeData(httpResponse) {
        this.setSelectedFlag(httpResponse);
        if (!this.groupby) {
            this.renderData();
        }
        this.totalPages = this.pageNumbers.length;
        this.mask = false;
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        this.viewRows = this.getResponseData(httpResponse);
        this.setSelectedFlag(this.viewRows);
        this.data = this.viewRows;
        if (this.groupby) {
            this.cloneData = JSON.parse(JSON.stringify(this.data));
        }
        if (this.enabledatafilter) {
            this.filterCloneData = JSON.parse(JSON.stringify(this.data));
        }
        if (this.globalfilter) {
            this.filterCloneData = JSON.parse(JSON.stringify(this.data));
        }
        this.renderData();
        if (this.groupby) {
            this.setColumnData();
        }
        this.totalPages = this.pageNumbers.length;
        this.mask = false;
    }
    /**
     * @param {?} viewRows
     * @return {?}
     */
    setSelectedFlag(viewRows) {
        viewRows.forEach((row) => {
            if (!row.hasOwnProperty('isSelected')) {
                row['isSelected'] = false;
            }
        });
    }
    /**
     * @param {?} col
     * @return {?}
     */
    setGroupByColumn(col) {
        this.groupbydataindex = col.dataindex;
        this.selectAll = false;
        this.setColumnData();
    }
    /**
     * @return {?}
     */
    keyUpSearch() {
        if (this.filterValue == null || this.filterValue === '') {
            this.removeGlobalFilter();
        }
        const /** @type {?} */ filter = {
            value: this.filterValue,
        };
        this.globalFilterOptions.forEach((opt) => {
            if (opt.checkedStatus === this.checkIcon) {
                filter['filter'] = opt.value;
            }
        });
        this.getGlobalFilteredData(filter);
    }
    /**
     * @return {?}
     */
    checkStatus() {
        this.globalFilterOptions.forEach((opt) => {
            opt.checkedStatus = '';
        });
    }
    /**
     * @param {?} opt
     * @return {?}
     */
    selectedOption(opt) {
        this.checkStatus();
        const /** @type {?} */ filter = {
            value: this.filterValue,
            filter: opt.value,
        };
        opt.checkedStatus = this.checkIcon;
        if (this.filterValue) {
            this.getGlobalFilteredData(filter);
        }
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    removeGlobalFilter() {
        this.filterValue = '';
    }
    /**
     * @param {?} filteredObj
     * @return {?}
     */
    getGlobalFilteredData(filteredObj) {
        this.data = [];
        this.filterCloneData.forEach((option) => {
            this.columns.forEach((opt) => {
                let /** @type {?} */ status = false;
                const /** @type {?} */ optvalue = option[opt.dataindex].toLowerCase();
                const /** @type {?} */ filtervalue = filteredObj.value.toLowerCase();
                if (filteredObj.filter === '1') {
                    status = optvalue.startsWith(filtervalue);
                }
                else if (filteredObj.filter === '2') {
                    status = optvalue.endsWith(filtervalue);
                }
                else if (filteredObj.filter === '3') {
                    status = optvalue.includes(filtervalue);
                }
                if (status) {
                    this.data.push(option);
                }
            });
        });
        if (this.data.length > (1 * this.pagesize)) {
            this.pagingRegenration();
            this.renderData();
        }
        else {
            this.viewRows = this.data;
            this.currentPage = 1;
            this.maxPage = 1;
        }
    }
    /**
     * @param {?} filteredObj
     * @param {?} option
     * @param {?} opt
     * @return {?}
     */
    filterConditionMethod(filteredObj, option, opt) {
        this.data = [];
        let /** @type {?} */ condition;
        if (filteredObj.filter === '1') {
            condition = option[opt.dataindex].toLowerCase().startsWith(filteredObj.value.toLowerCase());
            this.setstatus(condition);
        }
        if (filteredObj.filter === '2') {
            condition = option[opt.dataindex].toLowerCase().endsWith(filteredObj.value.toLowerCase());
            this.setstatus(condition);
        }
        if (filteredObj.filter === '3') {
            condition = option[opt.dataindex].toLowerCase().includes(filteredObj.value.toLowerCase());
            this.setstatus(condition);
        }
    }
    /**
     * @param {?} condition
     * @return {?}
     */
    setstatus(condition) {
        if (condition) {
            status = condition;
        }
    }
    /**
     * @return {?}
     */
    setColumnData() {
        this.data = this.cloneData;
        const /** @type {?} */ groups = {};
        this.data.forEach((option) => {
            const /** @type {?} */ groupName = option[this.groupbydataindex];
            if (!groups[groupName]) {
                groups[groupName] = [];
            }
            groups[groupName].push(option);
        });
        this.data = [];
        for (const /** @type {?} */ groupName in groups) {
            if (groups.hasOwnProperty(groupName)) {
                this.data.push({ expanded: false, isSelected: false, group: groupName, groupData: groups[groupName] });
            }
        }
        /*-------Aggregation---------*/
        this.renderData();
        this.cd.detectChanges();
    }
    /**
     * @return {?}
     */
    renderData() {
        // calculate page no for pagination
        if (this.data) {
            this.maxPage = 0;
            this.pageNumbers = [];
            if (this.data.length > (1 * this.pagesize)) {
                this.maxPage = Math.floor((this.data.length / this.pagesize));
                if ((this.data.length % this.pagesize) > 0) {
                    this.maxPage++;
                }
            }
            for (let /** @type {?} */ pageNo = 1; pageNo <= this.maxPage; pageNo++) {
                this.pageNumbers.push(pageNo);
            }
        }
        if (this.pagesize >= 1) {
            this.getPageSize();
        }
        else {
            this.viewRows = this.data;
        }
        this.selectedRowNo = -1;
    }
    /**
     * @return {?}
     */
    getPageSize() {
        const /** @type {?} */ rowsTemp = this.data;
        const /** @type {?} */ newRows = [];
        let /** @type {?} */ startIndex = 0;
        let /** @type {?} */ endIndex = this.pagesize;
        if (this.currentPage > 1) {
            startIndex = (this.currentPage - 1) * this.pagesize;
            endIndex = startIndex + this.pagesize;
        }
        while (startIndex <= endIndex - 1) {
            if (rowsTemp[startIndex]) {
                newRows.push(rowsTemp[startIndex]);
            }
            startIndex++;
        }
        this.viewRows = newRows;
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getResponseData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    }
    /**
     * @return {?}
     */
    selectAllRecord() {
        this.selectAll = !this.selectAll;
        if (this.selectAll) {
            for (const /** @type {?} */ vr of this.viewRows) {
                this.selectedRows.push(vr);
            }
        }
        else {
            this.selectedRows = [];
        }
        this.emitSelectedRows();
        if (this.groupby) {
            if (!this.selectAll) {
                this.viewRows.forEach((row) => {
                    row.isSelected = false;
                    row.groupData.forEach((node) => {
                        node.isSelected = false;
                    });
                });
            }
            else {
                this.viewRows.forEach((row) => {
                    row.isSelected = true;
                    row.groupData.forEach((node) => {
                        node.isSelected = true;
                    });
                });
            }
        }
    }
    /**
     * @param {?} column
     * @return {?}
     */
    onColumnCheck(column) {
        column.hidden = !column.hidden;
    }
    /**
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    onRowClick(rowData, rowIndex) {
        this.data.forEach((opt) => {
            opt.isSelected = false;
            if (opt.hasOwnProperty('groupData')) {
                opt.groupData.forEach((optChild) => {
                    optChild.isSelected = false;
                });
            }
        });
        rowData.isSelected = !rowData.isSelected;
        rowIndex = 'row' + rowIndex;
        this.rowId = rowIndex;
        this.rowSelect.emit(rowData);
        this.selectedRowNo = rowIndex;
    }
    /**
     * @param {?} pageNumber
     * @return {?}
     */
    loadPageData(pageNumber) {
        this.currentPage = pageNumber;
        this.renderData();
    }
    /**
     * @param {?} filteredObj
     * @return {?}
     */
    getFilteredData(filteredObj) {
        let /** @type {?} */ status = false;
        if (filteredObj.length > 0) {
            this.data = [];
            this.filterCloneData.forEach((option) => {
                status = this.filterOpertion(option, filteredObj);
                if (status) {
                    this.data.push(option);
                    status = false;
                }
            });
            if (this.data.length > (1 * this.pagesize)) {
                this.pagingRegenration();
                this.renderData();
            }
            else {
                this.viewRows = this.data;
                this.currentPage = 1;
                this.maxPage = 1;
            }
        }
        else {
            this.data = this.filterCloneData;
            this.pagingRegenration();
            this.renderData();
        }
    }
    /**
     * @param {?} filter
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    checkNumberFilter(filter, key, value) {
        if (filter === '<') {
            return key > value;
        }
        else if (filter === '>') {
            return key < value;
        }
        else if (filter === '>=') {
            return key <= value;
        }
        else if (filter === '=<') {
            return key >= value;
        }
        else if (filter === '==') {
            return key === value;
        }
        else if (filter === '!=') {
            return key !== value;
        }
        else {
            return key !== value;
        }
    }
    /**
     * @param {?} filter
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    checkStringFilter(filter, key, value) {
        if (filter === '3') {
            return key.includes(value);
        }
        else if (filter === '1') {
            return key.startsWith(value);
        }
        else if (filter === '2') {
            return key.endsWith(value);
        }
        else {
            return key !== value;
        }
    }
    /**
     * @param {?} data
     * @param {?} filteredObj
     * @return {?}
     */
    filterOpertion(data, filteredObj) {
        const /** @type {?} */ statusArray = [];
        let /** @type {?} */ condition;
        filteredObj.forEach((filterOpt) => {
            if (filterOpt.type === 'string') {
                condition = this.checkStringFilter(filterOpt.filter, data[filterOpt.key].toLowerCase(), filterOpt.value.toLowerCase());
            }
            else if (filterOpt.type === 'number') {
                condition = this.checkNumberFilter(filterOpt.filter, data[filterOpt.key], filterOpt.value);
            }
            statusArray.push(condition);
        });
        statusArray.forEach((opt) => {
            if (opt === false) {
                condition = false;
            }
        });
        return condition;
    }
    /**
     * @return {?}
     */
    pagingRegenration() {
        this.maxPage = Math.floor((this.data.length / this.pagesize));
        if ((this.data.length % this.pagesize) > 0) {
            this.maxPage++;
        }
        for (let /** @type {?} */ pageNo = 1; pageNo <= this.maxPage; pageNo++) {
            this.pageNumbers.push(pageNo);
        }
    }
    /**
     * @param {?} rowData
     * @param {?} event
     * @return {?}
     */
    setSelectedRow(rowData, event) {
        if (event.classList.value === this.checkDefaultIcon) {
            this.selectedRows.push(rowData);
            event.classList.value = 'checkbox active';
        }
        else {
            const /** @type {?} */ indexOf = this.selectedRows.indexOf(rowData);
            this.selectedRows.splice(indexOf, 0);
            event.classList.value = this.checkDefaultIcon;
        }
        this.emitSelectedRows();
    }
    /**
     * @return {?}
     */
    emitSelectedRows() {
        const /** @type {?} */ sRows = [];
        for (const /** @type {?} */ sr of this.selectedRows) {
            if (sr) {
                sRows.push(sr);
            }
        }
        this.selectedRowData.emit(sRows);
    }
    /**
     * @return {?}
     */
    setCheckBoxSelectClass() {
        if (this.selectAll) {
            return 'checkbox active';
        }
        else if (!this.selectAll) {
            return this.checkDefaultIcon;
        }
    }
    /**
     * @param {?} sortCol
     * @param {?} clickEvent
     * @return {?}
     */
    sortOnColHeaderClick(sortCol, clickEvent) {
        this.onHeaderClick.emit({ event: clickEvent, data: sortCol });
        if (sortCol.sort) {
            if (this.sortBy === -1) {
                this.sortBy = 1;
            }
            else if (this.sortBy === 1) {
                this.sortBy = 2;
            }
            else if (this.sortBy === 2) {
                this.sortBy = 1;
            }
            this.setSortColumn(sortCol, this.sortBy);
        }
    }
    /**
     * @param {?} sortCol
     * @param {?} _sortBy
     * @return {?}
     */
    setSortColumn(sortCol, _sortBy) {
        /*------set column sort false for other column--------*/
        this.columns.forEach((opt) => {
            opt['isColumnSort'] = false;
        });
        this.sortBy = _sortBy;
        this.sortColumn = sortCol;
        this.sortColumn.sort = true;
        this.sortColumn.isColumnSort = true;
        this.sortData();
    }
    /**
     * @return {?}
     */
    sortData() {
        if (this.sortColumn) {
            let /** @type {?} */ sortColDataIndex;
            const /** @type {?} */ sortOrder = this.sortBy;
            if (this.sortColumn.dataindex && this.sortColumn.datatype) {
                const /** @type {?} */ dataindex = this.sortColumn.dataindex;
                sortColDataIndex = dataindex;
                if (this.sortColumn.datatype === 'string') {
                    if (this.groupby) {
                        this.sortOrderGrpBy(sortOrder);
                    }
                    else {
                        this.data.sort((a, b) => {
                            const /** @type {?} */ x = a[sortColDataIndex].toLowerCase();
                            const /** @type {?} */ y = b[sortColDataIndex].toLowerCase();
                            return this.noGrpBySortOrder(sortOrder, x, y);
                        });
                    }
                }
                else if (this.sortColumn.datatype === 'number') {
                    this.sortOrderByNumber(sortOrder, sortColDataIndex);
                }
            }
        }
        this.renderData();
    }
    /**
     * @param {?} sortOrder
     * @param {?} sortColDataIndex
     * @return {?}
     */
    sortOrderByNumber(sortOrder, sortColDataIndex) {
        if (this.groupby) {
            this.data.sort((a, b) => {
                const /** @type {?} */ x = a.group;
                const /** @type {?} */ y = b.group;
                if (sortOrder === 2) {
                    return y - x;
                }
                else {
                    return x - y;
                }
            });
        }
        else {
            this.data.sort((a, b) => {
                const /** @type {?} */ x = a[sortColDataIndex];
                const /** @type {?} */ y = b[sortColDataIndex];
                if (sortOrder === 2) {
                    return y - x;
                }
                else {
                    return x - y;
                }
            });
        }
    }
    /**
     * @param {?} sortOrder
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    noGrpBySortOrder(sortOrder, x, y) {
        if (sortOrder === 2) {
            if (x < y) {
                return 1;
            }
            if (x > y) {
                return -1;
            }
        }
        else {
            if (x < y) {
                return -1;
            }
            if (x > y) {
                return 1;
            }
        }
        return 0;
    }
    /**
     * @param {?} sortOrder
     * @return {?}
     */
    sortOrderGrpBy(sortOrder) {
        this.data.sort((a, b) => {
            const /** @type {?} */ x = a.group.toLowerCase();
            const /** @type {?} */ y = b.group.toLowerCase();
            if (sortOrder === 2) {
                if (x < y) {
                    return 1;
                }
                if (x > y) {
                    return -1;
                }
            }
            else {
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
            }
            return 0;
        });
    }
    /**
     * @param {?} btn
     * @return {?}
     */
    onTabClick(btn) {
        btn.classList.toggle('active-accordion');
        const /** @type {?} */ panel = btn.nextElementSibling;
        if (this.iconclassKey === this.plusIcon) {
            this.iconclassKey = 'fa fa-minus';
        }
        else if (this.iconclassKey === 'fa fa-minus') {
            this.iconclassKey = this.plusIcon;
        }
        if (panel.style.maxHeight) {
            panel.style.maxHeight = null;
        }
        else {
            panel.style.maxHeight = panel.scrollHeight + 'px';
        }
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    toogle(row, index) {
        row.expanded = !row.expanded;
        if (row.expanded) {
            if (row.hasOwnProperty('groupData')) {
                this.addRows(row, index);
            }
        }
        else {
            if (row.hasOwnProperty('groupData')) {
                this.removeRows(row);
            }
        }
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    addRows(row, index) {
        row.level = Math.floor(Math.random() * 900) + 100;
        row.groupData.forEach((node, index1) => {
            node.level = row.level;
            this.viewRows.splice(index + (index1 + 1), 0, node);
        });
    }
    /**
     * @param {?} row
     * @return {?}
     */
    removeRows(row) {
        let /** @type {?} */ count = 0;
        this.viewRows.forEach((node) => {
            if (!node.hasOwnProperty('group') && node.level === row.level) {
                count++;
            }
        });
        this.viewRows.forEach((node, index) => {
            if (!node.hasOwnProperty('group') && node.level === row.level) {
                this.viewRows.splice(index, count);
            }
        });
    }
    /**
     * @param {?} row
     * @return {?}
     */
    isGroupChecking(row) {
        if (row.hasOwnProperty('group')) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    selectParent(row) {
        if (this.groupby) {
            row.isSelected = !row.isSelected;
            row.groupData.forEach((node) => {
                node.isSelected = !node.isSelected;
            });
            this.selectedRows = [];
            this.viewRows.forEach((rows) => {
                if (rows.isSelected) {
                    this.selectedRows.push(rows);
                }
            });
            this.emitSelectedRows();
        }
    }
    /**
     * @param {?} event
     * @param {?} row
     * @param {?} col
     * @param {?} ref
     * @return {?}
     */
    loadContextMenu(event, row, col, ref) {
        this.tempContextMenu = [];
        this.tempSelectedFlag(this.viewRows);
        this.mouseLocation.left = event.clientX;
        this.mouseLocation.top = event.clientY;
        row.isSelected = true;
        if (col.contextmenu && col.contextmenu.length > 0) {
            this.flag = true;
            this.tempContextMenu = col.contextmenu;
            this.addListner();
        }
        else if (this.contextmenu && this.contextmenu.length > 0) {
            this.tempContextMenu = this.contextmenu;
            this.flag = true;
            this.addListner();
        }
        this.posixUp = this.getListPosition(ref);
        event.preventDefault();
        event.stopPropagation();
        this.rightClickRowData = row;
        this.contextStyle = this.getContextMenuStyle();
    }
    /**
     * @param {?} itemConfig
     * @return {?}
     */
    onContextNodeClick(itemConfig) {
        if (!itemConfig.disabled) {
            const /** @type {?} */ obj = {
                menuData: itemConfig,
                rowData: this.rightClickRowData,
            };
            this.flag = false;
            this.removeListner();
            this.rightClick.emit(obj);
        }
    }
    /**
     * @return {?}
     */
    getContextMenuStyle() {
        return {
            'cursor': 'default',
            'position': 'fixed',
            'display': this.flag ? 'block' : 'none',
            'left': this.mouseLocation.left + 'px',
            'top': this.mouseLocation.top + 'px',
            'box-shadow': '1px 1px 2px #000000',
            'width': '15%',
        };
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        const /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} viewRows
     * @return {?}
     */
    tempSelectedFlag(viewRows) {
        viewRows.forEach((row) => {
            if (row.isSelected) {
                row.isSelected = false;
            }
        });
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (e) => {
            this.flag = false;
            if (!this.flag) {
                this.removeListner();
            }
        });
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
    }
}
AmexioDatagridComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-datagrid',
                template: `
    <div class="datagrid">
      <div class="datatabletitle">
        <span> {{title}} </span>
        <span class="dataheaderFilter" class="float-right"  style="padding-bottom:1.1%">
          <ng-content select="amexio-datagrid-header"></ng-content>
          <span *ngIf="enablecolumnfilter ? true:false" class="float-right"
          (click)="showToolTip = !showToolTip ; showGroupByColumn = false"
            style=" cursor: pointer;">
            &nbsp;
            <span *ngIf="!show">&#9776;</span>
            <span *ngIf="show">&#9747;</span>
          </span>
        </span>
        <span *ngIf="groupby ? true : false" class="float-right" (click)="showGroupByColumn = !showGroupByColumn; showToolTip = false"
              style=" cursor: pointer;">
          <!--<span class="fa fa-th-list"></span>-->
          <amexio-data-icon key="datagrid_list"></amexio-data-icon>
      </span>
      </div>
      <!--Filter with Checkbox datagrid start-->
      <ng-container *ngIf="enabledatafilter ? true : false">
        <div class="datatable datatable-row">
          <ng-container *ngIf="enablecheckbox">
            <div class="datatable-col col-group datatable-checkbox-width">
              <div class="inputgroup">
                <div class="input-box">
                  <div *ngIf="!selectAll" (click)="selectAllRecord()" class="checkbox default"></div>
                  <div *ngIf="selectAll" (click)="selectAllRecord()" class="checkbox active">&#10004;</div>
                </div>
              </div>
            </div>
          </ng-container>

          <!--Filter datagrid start-->
          <ng-container *ngIf="enabledatafilter ? true : false">
            <ng-container *ngFor="let cols of columns">
              <ng-container *ngIf="!cols.hidden">
                <div class="datatable-col col-group" [style.width.%]="cols.width">
                  <data-grid-filter [column]="cols" (filterObject)="getFilteredData($event)">
                  </data-grid-filter>
                </div>
              </ng-container>
            </ng-container>
          </ng-container>

        </div>
      </ng-container>

      <!--Filter datagrid start-->
      <ng-container *ngIf="globalfilter ? true : false">
        <div class="datatable datatable-row">
          <ng-container class="datatable datatable-column">
            <div class="inputgroup" style="padding-left: 1%; padding-right: 1%">
              <input type="text"  [(ngModel)]="filterValue"
                     (keyup)="keyUpSearch($event)" type="text"
                     class="input-control" aria-label="Text input with dropdown button">
              <!--<i class="fa fa-filter" aria-hidden="true"
              (click)="showToolTip = !showToolTip"></i>-->
              <span class="datatable-filter-icon">
                      <amexio-data-icon key="datagrid_filter" (click)="showToolTip = !showToolTip"></amexio-data-icon>
                  </span>
              <span *ngIf="showToolTip" class="dropdown" style="width: 250px; right: 10px">
                      <ul class="dropdown-list" *ngFor="let opt of globalFilterOptions">
                          <li class="list-items">
                              <div (click)="selectedOption(opt)">
                                  {{opt.key}}&nbsp;
                                  <i [class]="opt.checkedStatus" aria-hidden="true"></i>
                              </div>
                          </li>
                      </ul>
                  </span>
            </div>
          </ng-container>
        </div>
      </ng-container>

      <div>
        <ng-container *ngIf="enablecolumnfilter ? true : false">
          <span *ngIf="showToolTip" class="dropdown dropdown-right" style="width: 250px;">
              <ul class="dropdown-list">
                  <li class="list-items" *ngFor="let cols of columns;let i = index;" (click)="showToolTip = !showToolTip">
                      <div>
                          <input type="checkbox" [attr.checked]="!cols.hidden ? true: null" (click)="onColumnCheck(cols)" />
                          <label>{{cols.text}}</label>
                      </div>
                  </li>
              </ul>
          </span>
        </ng-container>

        <ng-container *ngIf="groupby ? true : false">
          <span *ngIf="showGroupByColumn" class="dropdown dropdown-right" style="width: 250px;">
              <ul class="dropdown-list">
                  <li class="list-items" *ngFor="let cols of columns;let i = index;" (click)="showGroupByColumn = !showGroupByColumn">
                      <div (click)="setGroupByColumn(cols)">
                          <label>{{cols.text}}</label>
                      </div>
                  </li>
              </ul>
          </span>
        </ng-container>
      </div>
    </div>

    <!--Checkbox datagrid with datatypes condition start-->
    <div class="datatable">
      <div class="datatable-header">
        <ng-container *ngIf="enablecheckbox">
          <div class="datatable-col datatable-checkbox-width checkbox-col">
            <div class="inputgroup">
              <div class="input-box">
                <div *ngIf="!selectAll" (click)="selectAllRecord()" class="checkbox default"></div>
                <div *ngIf="selectAll" (click)="selectAllRecord()" class="checkbox active">&#10004;</div>
              </div>
            </div>
          </div>
        </ng-container>
        <!--datagrid start unhidden-->
        <ng-container *ngFor="let cols of columns">
          <ng-container *ngIf="!cols.hidden">
            <ng-container *ngIf="cols.datatype=='string'">
              <!-- -------------------- -->
              <div class="datatable-col" [style.width.%]="cols.width" (click)="sortOnColHeaderClick(cols, $event)">

                <ng-container *ngIf="cols.headerTemplate">
                  <ng-template  [ngTemplateOutlet]="cols.headerTemplate"
                                [ngTemplateOutletContext]="{column:cols ,index: i}"></ng-template>
                </ng-container>
                <ng-container *ngIf="!cols.headerTemplate">
                  {{cols.text}} &nbsp;

                </ng-container>
                <ng-container *ngIf="this.sortBy==1   && cols.isColumnSort">
                  <amexio-data-icon key="datagrid_arrowup"></amexio-data-icon>
                  <!--&nbsp; <i class="fa fa-arrow-up"></i>-->
                </ng-container>
                <ng-container *ngIf="this.sortBy==2  && cols.isColumnSort">
                  <!--&nbsp;<i class="fa fa-arrow-down"></i>-->
                  <amexio-data-icon key="datagrid_arrowdown"></amexio-data-icon>
                </ng-container>
              </div>
            </ng-container>
            <ng-container *ngIf="cols.datatype=='number'">
              <div class="datatable-col" [style.width.%]="cols.width" (click)="sortOnColHeaderClick(cols, $event)">
                <ng-container *ngIf="cols.headerTemplate">
                  <ng-template  [ngTemplateOutlet]="cols.headerTemplate"
                                [ngTemplateOutletContext]="{column:cols ,index: i}"></ng-template>
                </ng-container>
                <ng-container *ngIf="!cols.headerTemplate">
                      <span class="float-right">
                          {{cols.text}} &nbsp;
                          <ng-container *ngIf="this.sortBy==1 && cols.isColumnSort">
                              <amexio-data-icon key="datagrid_arrowup"></amexio-data-icon>
                            <!--&nbsp; <i class="fa fa-arrow-up"></i>-->
                          </ng-container>
                          <ng-container *ngIf="this.sortBy==2 && cols.isColumnSort">
                              <!--&nbsp;<i class="fa fa-arrow-down"></i>-->
                              <amexio-data-icon key="datagrid_arrowdown"></amexio-data-icon>
                          </ng-container>
                      </span>
                </ng-container>
              </div>
            </ng-container>
          </ng-container>
        </ng-container>
      </div>
    </div>

    <!--Group BY datagrid start-->
    <ng-container *ngIf="!groupby">
      <div class="datatable-height" [style.height.px]="height">
        <div class="datatable">
          <div style="height: 300px;" *ngIf="mask">
            <div class="spinner"></div>
          </div>
          <ng-container *ngIf="!mask">
            <div #id class="datatable-row"
                 *ngFor="let row of viewRows;let i=index" id="{{'row'+i}}"
                 [ngClass]="{'datatable-row-active':row.isSelected}"
                 (click)="onRowClick(row, i)">

              <ng-container *ngIf="enablecheckbox">
                <div class="datatable-col datatable-checkbox-width checkbox-col">
                  <div class="inputgroup">
                    <div class="input-box">
                      <div (click)="setSelectedRow(row, check)" [class]="checkBoxSelectClass" #check>
                        {{((checkBoxSelectClass == 'checkbox active') &&
                      (check.classList.value == 'checkbox active')) ||
                      ((checkBoxSelectClass
                      == 'checkbox default') && (check.classList.value == 'checkbox active')) ? '&#10004;'
                        : ''}}
                      </div>
                    </div>
                  </div>
                </div>
              </ng-container>

              <ng-container *ngFor="let cols of columns;let colIndex = index">
                <ng-container *ngIf="!cols.hidden">
                  <ng-container *ngIf="cols.datatype=='number'">
                    <div class="datatable-col" [style.width.%]="cols.width" scope="row" [attr.data-label]="cols.text">
                                  <span class="float-right">
                                      <ng-container *ngIf="row[cols.dataindex]!= null;else elseBlock">
                                      <div (contextmenu)="loadContextMenu($event,row, cols, id)">
                                      {{row[cols.dataindex]}}
                                      </div>
                                      </ng-container>
                                      <ng-template #elseBlock>
                                          &nbsp;
                                      </ng-template>

                                  </span>
                    </div>
                  </ng-container>
                  <ng-container *ngIf="!cols?.bodyTemplate && cols.datatype=='string'">
                    <div class="datatable-col" [style.width.%]="cols.width" scope="row" [attr.data-label]="cols.text">
                      <ng-container *ngIf="row[cols.dataindex]!= null ;else elseBlock">
                        <div (contextmenu)="loadContextMenu($event,row, cols, id)">
                          {{row[cols.dataindex]}}
                        </div>
                      </ng-container>
                      <ng-template #elseBlock>
                        &nbsp;
                      </ng-template>
                    </div>
                  </ng-container>
                  <ng-container *ngIf="cols.bodyTemplate">
                    <div class="datatable-col" [style.width.%]="cols.width" scope="row" [attr.data-label]="cols.text">
                      <ng-template [ngTemplateOutlet]="cols.bodyTemplate"
                                   [ngTemplateOutletContext]="{ $implicit: { text : row[cols.dataindex] }, row: row }"></ng-template>
                    </div>
                  </ng-container>
                </ng-container>

              </ng-container>
            </div>
          </ng-container>

        </div>
      </div>

    </ng-container>

    <!--Group BY datagrid end-->

    <!--Group BY and Filter Data datagrid start-->
    <ng-container *ngIf="groupby && !enabledatafilter">
      <div class="datatable-height" [style.height.px]="height">
        <div class="datatable" style="table-layout: inherit !important;">
          <div style="height: 300px;" *ngIf="mask">
            <div class="spinner"></div>
          </div>
          <ng-container *ngIf="!mask">
            <div class="datatable-row"
                 *ngFor="let row of viewRows;let i=index"
                 id="{{'row'+i}}" [ngClass]="{'datatable-row-active':row.isSelected}"
                 (click)="toogle(row, i)">
              <ng-container *ngIf="enablecheckbox">
                <div class="datatable-col datatable-checkbox-width checkbox-col">
                  <div class="inputgroup">
                    <div class="input-box">
                      <div (click)="selectParent(row)" [class]="row.isSelected ?'checkbox active':'checkbox default'">
                        {{row.isSelected ? '&#10004;' : ''}}
                      </div>
                    </div>
                  </div>
                </div>
              </ng-container>
              <ng-container *ngFor="let cols of columns;let colIndex = index">
                <ng-container *ngIf="isGroupChecking(row)">

                  <ng-container *ngIf="colIndex == 0">
                    <div class="datatable-col col-group">
                      <!--<i *ngIf="!row.expanded" class="fa fa-caret-right" aria-hidden="true" (click)="toogle(row,i)"></i>-->
                      <ng-container *ngIf="!row.expanded">
                        <amexio-data-icon key="datagrid_expand"></amexio-data-icon>
                      </ng-container>
                      <ng-container *ngIf="row.expanded">
                        <amexio-data-icon key="datagrid_collapse"></amexio-data-icon>
                      </ng-container>
                      {{row.group}}
                    </div>
                  </ng-container>

                  <ng-container *ngIf="colIndex != 0">
                    <div class="datatable-col col-hidden">
                    </div>
                  </ng-container>
                </ng-container>
                <ng-container *ngIf="!isGroupChecking(row)">
                  <ng-container *ngIf="cols.datatype=='string'">
                    <div class="datatable-col" [style.width.%]="cols.width" [attr.data-label]="cols.text">
                      <ng-container *ngIf="colIndex == 0">
                                      <span style="padding-left: 20px">
                                          {{row[cols.dataindex]}}
                                      </span>
                      </ng-container>
                      <ng-container *ngIf="colIndex != 0">
                        {{row[cols.dataindex]}}
                      </ng-container>
                    </div>
                  </ng-container>
                  <ng-container *ngIf="cols.datatype=='number'">

                    <div class="datatable-col" [style.width.%]="cols.width" [attr.data-label]="cols.text">

                      <ng-container *ngIf="colIndex == 0">
                                      <span style="padding-left: 20px">
                                          <ng-container *ngIf="row[cols.dataindex]!= null ;else elseBlock">
                                              {{row[cols.dataindex]}}
                                          </ng-container>
                                          <ng-template #elseBlock>
                                              &nbsp;
                                          </ng-template>

                                      </span>
                      </ng-container>
                      <ng-container *ngIf="colIndex != 0">
                                      <span class="float-right">
                                          <ng-container *ngIf="row[cols.dataindex]!= null ;else elseBlock">
                                              {{row[cols.dataindex]}}
                                          </ng-container>
                                          <ng-template #elseBlock>
                                              &nbsp;
                                          </ng-template>
                                      </span>
                      </ng-container>

                    </div>

                  </ng-container>

                </ng-container>
              </ng-container>
            </div>
          </ng-container>

        </div>
      </div>
    </ng-container>
    <!--Group BY and Filter Data datagrid end-->

    <!-- Context Menu  -->
    <span [ngStyle]="contextStyle">
    <ul *ngIf="flag" class="context-menu-list" [ngClass]="{'dropdown-up' : posixUp}">
        <li (click)="onContextNodeClick(itemConfig)" class="context-menu-list-items"
            [ngStyle]="{'cursor': itemConfig.disabled ? 'not-allowed':'pointer'}"
            [ngClass]="{'context-menu-separator':itemConfig.seperator}"
            *ngFor="let itemConfig of tempContextMenu">
            <i [ngStyle]="{'padding-left': itemConfig.icon ? '5px':'22px'}"
               [ngClass]="itemConfig.icon"></i>
            <span style="white-space: nowrap;display: inline ; padding-left:10px">
            {{itemConfig.text}}
            </span>
        </li>
    </ul>
</span>

    <!-- Footer of the grid -->
    <div class="footer">
      <ng-container *ngIf="pagesize && (data && data.length > pagesize)">
        <ng-container *ngIf="totalPages!=null">
          <amexio-paginator [pages]="totalPages" [rows]="pagesize" (onPageChange)="loadPageData($event)"></amexio-paginator>
        </ng-container>
      </ng-container>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioDatagridComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: CommonDataService },
    { type: ChangeDetectorRef },
    { type: Renderer2 }
];
AmexioDatagridComponent.propDecorators = {
    title: [{ type: Input }],
    pagesize: [{ type: Input, args: ['page-size',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    enablecheckbox: [{ type: Input, args: ['enable-checkbox',] }],
    data: [{ type: Input, args: ['data',] }],
    rowSelect: [{ type: Output }],
    selectedRowData: [{ type: Output }],
    onHeaderClick: [{ type: Output }],
    height: [{ type: Input }],
    groupby: [{ type: Input }],
    groupbydataindex: [{ type: Input, args: ['groupby-data-index',] }],
    enabledatafilter: [{ type: Input, args: ['enable-data-filter',] }],
    cclass: [{ type: Input, args: ['c-class',] }],
    tableHeadercclass: [{ type: Input }],
    tableTitlecclass: [{ type: Input }],
    tableDatacclass: [{ type: Input }],
    selectedrowcolor: [{ type: Input, args: ['selected-row-color',] }],
    columndefintion: [{ type: Input, args: ['column-defintion',] }],
    enablecolumnfiter: [{ type: Input, args: ['enable-column-fiter',] }],
    enablecolumnfilter: [{ type: Input, args: ['enable-column-filter',] }],
    globalfilter: [{ type: Input, args: ['global-filter',] }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    rightClick: [{ type: Output }],
    columnRef: [{ type: ContentChildren, args: [AmexioGridColumnComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 2/1/18.
 */
class DataGridFilterComponent {
    /**
     * @param {?} dataTableService
     */
    constructor(dataTableService) {
        this.dataTableService = dataTableService;
        /*
         for internal use
        */
        this.filterObject = new EventEmitter();
        this.checkIcon = 'fa fa-check';
        this.filterOptions = [{
                key: 'Is Equal To', value: '==', type: 'string', checkedStatus: '',
            }, {
                key: 'Is Not Equal To', value: '!=', type: 'string', checkedStatus: '',
            }, {
                key: 'Start With', value: '1', type: 'string', checkedStatus: this.checkIcon,
            },
            {
                key: 'Ends With', value: '2', type: 'string', checkedStatus: '',
            }, {
                key: 'Contains', value: '3', type: 'string', checkedStatus: '',
            }, {
                key: 'Is Equal To', value: '==', type: 'number', checkedStatus: '',
            }, {
                key: 'Is Not Equal To', value: '!=', type: 'number', checkedStatus: '',
            }, {
                key: 'Is greater Than', value: '<', type: 'number', checkedStatus: '',
            }, {
                key: 'Is less Than', value: '>', type: 'number', checkedStatus: '',
            },
            {
                key: 'Is less Than or equal to', value: '>=', type: 'number', checkedStatus: '',
            }, {
                key: 'Is greater Than or equal to', value: '=<', type: 'number', checkedStatus: this.checkIcon,
            }];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} col
     * @param {?} opt
     * @return {?}
     */
    selectedOption(col, opt) {
        this.checkStatus();
        const /** @type {?} */ filter = {
            key: col.dataindex,
            value: this.filterValue,
            filter: opt.value,
            type: col.datatype,
        };
        opt.checkedStatus = this.checkIcon;
        if (this.filterValue) {
            col.filterIcon = true;
            this.filterDataObject(filter, col);
        }
        this.showToolTip = false;
    }
    /**
     * @param {?} col
     * @return {?}
     */
    keyUpSearch(col) {
        this.showToolTip = false;
        if (this.filterValue == null || this.filterValue === '') {
            this.removeFilter(col);
        }
        else {
            col.filterIcon = true;
            const /** @type {?} */ filter = {
                key: col.dataindex,
                value: this.filterValue,
                type: col.datatype,
            };
            this.filterOptions.forEach((opt) => {
                if (opt.checkedStatus === this.checkIcon && col.datatype === opt.type) {
                    filter['filter'] = opt.value;
                }
            });
            this.filterDataObject(filter, col);
        }
    }
    /**
     * @param {?} column
     * @return {?}
     */
    removeFilter(column) {
        this.filterValue = '';
        column.filterIcon = false;
        this.dataTableService.filteredObject.forEach((option, index) => {
            if (option.key === column.dataindex) {
                this.dataTableService.filteredObject.splice(index, 1);
            }
        });
        this.filterObject.emit(this.dataTableService.filteredObject);
    }
    /**
     * @return {?}
     */
    checkStatus() {
        this.filterOptions.forEach((opt) => {
            opt.checkedStatus = '';
        });
    }
    /**
     * @param {?} filter
     * @param {?} col
     * @return {?}
     */
    filterDataObject(filter, col) {
        this.dataTableService.filteredObject.forEach((option, index) => {
            if (option.key === col.dataindex) {
                this.dataTableService.filteredObject.splice(index, 1);
            }
        });
        this.dataTableService.filteredObject.push(filter);
        this.filterObject.emit(this.dataTableService.filteredObject);
    }
}
DataGridFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'data-grid-filter', template: `
    <ng-container *ngIf="column.datatype==='string'">
      <div class="inputgroup">
      <input type="text" [(ngModel)]="filterValue" [attr.placeholder]="column.text" (keyup)="keyUpSearch(column)"
             type="text" class="input-control"
             aria-label="Text input with dropdown button">
      <!--<i class="fa fa-filter" aria-hidden="true" (click)="showToolTip = !showToolTip"></i>-->
      <span class="datatable-filter-icon">
        <amexio-data-icon key="datagrid_filter" (click)="showToolTip = !showToolTip"></amexio-data-icon>
      </span>
      <span *ngIf="showToolTip" class="dropdown" style="width: 250px;">
        <ul class="dropdown-list" *ngFor="let opt of filterOptions">
          <ng-container *ngIf="opt.type===column.datatype">
          <li class="list-items">
              <div (click)="selectedOption(column,opt)">
              {{opt.key}}&nbsp;<i [class]="opt.checkedStatus" aria-hidden="true"></i>
            </div>
          </li>
          </ng-container>
         </ul>
      </span>
      </div>
    </ng-container>

    <ng-container *ngIf="column.datatype==='number'">
              <div class="inputgroup float-right">

        <input type="text" [(ngModel)]="filterValue" [attr.placeholder]="column.text" (keyup)="keyUpSearch(column)"
               type="number" class="input-control"
               aria-label="Text input with dropdown button">
        <!--<i class="fa fa-filter" aria-hidden="true" (click)="showToolTip = !showToolTip"></i>-->
     <span class="datatable-filter-icon">
      <amexio-data-icon key="datagrid_filter" (click)="showToolTip = !showToolTip"></amexio-data-icon>
     </span>
       <span *ngIf="showToolTip" class="dropdown" style="width: 250px;">
        <ul class="dropdown-list" *ngFor="let opt of filterOptions">
          <ng-container *ngIf="opt.type===column.datatype">
          <li class="list-items">
              <div (click)="selectedOption(column,opt)">
              {{opt.key}}&nbsp;<i [class]="opt.checkedStatus" aria-hidden="true"></i>
            </div>
          </li>
          </ng-container>
         </ul>
      </span>
              </div>
    </ng-container>

  `,
            },] },
];
/** @nocollapse */
DataGridFilterComponent.ctorParameters = () => [
    { type: CommonDataService }
];
DataGridFilterComponent.propDecorators = {
    column: [{ type: Input }],
    filterObject: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioDataGridHeaderComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioDataGridHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-datagrid-header', template: `
    <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioDataGridHeaderComponent.ctorParameters = () => [];
AmexioDataGridHeaderComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const faFaCaretIcon = 'fa fa-caret-down';
const faFaTimesIcon = 'fa fa-times';
const ICON_MAPPING = [
    {
        component: 'datepicker_previous',
        fa: 'fa fa-chevron-left',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'datepicker_calendar',
        fa: 'fa fa-calendar',
        mat: 'date_range',
    },
    {
        component: 'datepicker_next',
        fa: 'fa fa-chevron-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'datepicker_previous_fast',
        fa: 'fa fa-step-backward',
        mat: 'fast_rewind',
    },
    {
        component: 'datepicker_next_fast',
        fa: 'fa fa-step-forward',
        mat: 'fast_forward',
    },
    {
        component: 'accordion_expand',
        fa: 'fa fa-plus',
        mat: 'add',
    },
    {
        component: 'accordion_collapse',
        fa: 'fa fa-minus',
        mat: 'remove',
    },
    {
        component: 'tree_expand',
        fa: 'fa fa-chevron-down',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'tree_collapse',
        fa: 'fa fa-chevron-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'dropdown_caret',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'tab_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'window_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'window_maximize',
        fa: 'fa fa-window-maximize',
        mat: 'open_with',
    },
    {
        component: 'window_restore',
        fa: 'fa fa-window-restore',
        mat: 'indeterminate_check_box',
    },
    {
        component: 'paginator_previous',
        fa: 'fa fa-angle-left',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'paginator_next',
        fa: 'fa fa-angle-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'paginator_first',
        fa: 'fa fa-angle-double-left',
        mat: 'first_page',
    },
    {
        component: 'paginator_last',
        fa: 'fa fa-angle-double-right',
        mat: 'last_page',
    },
    {
        component: 'itemselector_caretup',
        fa: 'fa fa-caret-up',
        mat: 'arrow_drop_up',
    },
    {
        component: 'itemselector_caretdown',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'itemselector_arrowup',
        fa: 'fa fa-arrow-up',
        mat: 'arrow_upward',
    },
    {
        component: 'itemselector_arrowdown',
        fa: 'fa fa-arrow-down',
        mat: 'arrow_downward',
    },
    {
        component: 'itemselector_arrowleft',
        fa: 'fa fa-arrow-left',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'itemselector_arrowright',
        fa: 'fa fa-arrow-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'tab_previous',
        fa: 'fa fa-angle-left fa-2x',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'tab_next',
        fa: 'fa fa-angle-right  fa-2x',
    },
    {
        component: 'tab_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'fieldset_expand',
        fa: 'fa fa-plus',
        mat: 'add',
    },
    {
        component: 'fieldset_collpase',
        fa: 'fa fa-minus',
        mat: 'remove',
    },
    {
        component: 'carousel_previous',
        fa: 'fa fa-angle-left fa-2x',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'carousel_next',
        fa: 'fa fa-angle-right  fa-2x',
    },
    {
        component: 'dockbar_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'notify_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'sidenav_bar',
        fa: 'fa fa-bars fa-2x',
        mat: 'menu',
    },
    {
        component: 'sidenav_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'datagrid_arrowdown',
        fa: 'fa fa-arrow-down',
        mat: 'arrow_downward',
    },
    {
        component: 'datagrid_arrowup',
        fa: 'fa fa-arrow-up',
        mat: 'arrow_upward',
    },
    {
        component: 'datagrid_list',
        fa: 'fa fa-th-list',
        mat: 'view_list',
    },
    {
        component: 'datagrid_expand',
        fa: 'fa fa-caret-right',
        mat: '',
    },
    {
        component: 'datagrid_collapse',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'datagrid_collapse',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'datagrid_filter',
        fa: 'fa fa-filter',
        mat: 'filter_list',
    },
    {
        component: 'tree_filter',
        fa: 'fa fa-filter',
        mat: 'filter_list',
    },
    {
        component: 'data_check',
        fa: 'fa fa-check',
        mat: 'check',
    },
    {
        component: 'button_caret-down',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'button_angle-right',
        fa: 'fa fa-angle-right',
        mat: 'arrow_drop_right',
    },
    {
        component: 'button_angle-down',
        fa: 'fa fa-angle-down',
        mat: 'arrow_drop_down',
    },
    {
        component: 'menubar_ravelry',
        fa: 'fa fa-ravelry',
        mat: 'done',
    },
    {
        component: 'sidenav-angle-up',
        fa: 'fa fa-angle-up',
        mat: 'keyboard_arrow_up',
    },
    {
        component: 'sidenav-angle-down',
        fa: 'fa fa-angle-down',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-error',
        fa: 'fa fa-exclamation-triangle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-warning',
        fa: 'fa fa-exclamation-triangle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-help',
        fa: 'fa fa-question-circle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-confirm',
        fa: 'fa fa-check-circle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'horizontal-tree-expanded',
        fa: 'fa fa-caret-right fa-fw',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'horizontal-tree-collapse',
        fa: 'fa fa-caret-left fa-fw',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'button-loading-icon',
        fa: 'fa fa-refresh fa-spin',
        mat: 'cached',
    },
    {
        component: 'datepicker-clock-icon',
        fa: 'fa fa-clock-o',
        mat: 'access_time',
    },
];
class IconLoaderService {
    constructor() {
        this.iconMappings = ICON_MAPPING;
    }
    /**
     * @return {?}
     */
    get iconToUse() {
        if (this._iconToUse == null) {
            return 'fa';
        }
        else {
            return this._iconToUse;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set iconToUse(value) {
        this._iconToUse = value;
    }
    /**
     * @param {?} componentKey
     * @param {?} newValue
     * @return {?}
     */
    modifyIconClass(componentKey, newValue) {
        if (this.iconMappings != null) {
            this.iconMappings.forEach((icon) => {
                if (icon.component === componentKey) {
                    icon[this._iconToUse.toString()] = newValue;
                }
            });
        }
    }
}
IconLoaderService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
IconLoaderService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioDataIconComponent {
    /**
     * @param {?} iconLoaderService
     */
    constructor(iconLoaderService) {
        this.iconLoaderService = iconLoaderService;
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.iconClass = this.getIconClass();
    }
    /**
     * @return {?}
     */
    getIconClass() {
        if (this.iconLoaderService.iconMappings != null) {
            const /** @type {?} */ iconObject = this.iconLoaderService.iconMappings.find((obj) => obj.component === this.key);
            if (iconObject != null) {
                return iconObject[this.iconLoaderService.iconToUse.toString()];
            }
            else {
                return '';
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['key']) {
            this.key = changes["key"].currentValue;
            this.iconClass = this.getIconClass();
        }
    }
}
AmexioDataIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-data-icon', template: `
    <ng-container *ngIf="iconLoaderService.iconToUse == 'fa'">

      <ng-container *ngIf="customclass != null">
        <i class="{{customclass}}" aria-hidden="true" (click)="onClick.emit($event)"></i>
      </ng-container>
      <ng-container *ngIf="customclass == null">
        <i class="{{iconClass}}" aria-hidden="true" (click)="onClick.emit($event)"></i>
      </ng-container>

    </ng-container>

    <ng-container *ngIf="iconLoaderService.iconToUse == 'mat'">

      <ng-container *ngIf="customclass != null">
        <i class="material-icons" (click)="onClick.emit($event)">{{customclass}}</i>
      </ng-container>

      <ng-container *ngIf="customclass == null">
        <i class="material-icons" (click)="onClick.emit($event)">{{iconClass}}</i>
      </ng-container>


    </ng-container>

  `,
            },] },
];
/** @nocollapse */
AmexioDataIconComponent.ctorParameters = () => [
    { type: IconLoaderService }
];
AmexioDataIconComponent.propDecorators = {
    key: [{ type: Input }],
    onClick: [{ type: Output }],
    customclass: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioItemSelectorComponent {
    /**
     * @param {?} itemSelectorService
     */
    constructor(itemSelectorService) {
        this.itemSelectorService = itemSelectorService;
        this.mask = true;
        /*
           Properties
           name : enable-drop
           datatype : boolean
           version : 5.0.0 onwards
           default : false
           description : any node can be dropped in the selector structure
           */
        this.enabledrop = false;
        /*
           Properties
           name : across-itemselector
           datatype : boolean
           version : 5.0.0 onwards
           default : false
           description : Dragging and dropping is possible across list.
           */
        this.acrossitemselector = false;
        /*
           Events
           name : availableRecords
           datatype : none
           version : none
           default : none
           description :  Get available values objects.
           */
        this.availableRecords = new EventEmitter();
        /*
           Events
           name : selectedRecords
           datatype : none
           version : none
           default : none
           description :  Get selected value Object.
           */
        this.selectedRecords = new EventEmitter();
        this.onDrag = new EventEmitter();
        this.dragover = new EventEmitter();
        this.selectedData = [];
        this.leftactive = true;
        this.rightactive = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.itemSelectorService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.response = response;
            }, (error) => {
            }, () => {
                this.setData(this.response);
            });
        }
        else if (this.data) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.previousValue) !== JSON.stringify(this.data)) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
            responsedata.forEach((option, index) => {
                if (!option['isSelected']) {
                    option['isSelected'] = false;
                }
            });
        }
        else {
            responsedata = httpResponse;
        }
        this.availableData = responsedata;
        this.mask = false;
    }
    /**
     * @param {?} data
     * @param {?} index
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    itemClick(data, index, left, right) {
        this.leftactive = left;
        this.rightactive = right;
        this.switchingObject = data;
        this.objectIndex = index;
        for (const /** @type {?} */ ir of this.availableData) {
            if ((ir)[this.valuefield] === data[this.valuefield]) {
                ir['isSelected'] = true;
            }
            else {
                ir['isSelected'] = false;
            }
        }
        if (right) {
            for (const /** @type {?} */ ir of this.selectedData) {
                if ((ir)[this.valuefield] === data[this.valuefield]) {
                    ir['selectedClick'] = true;
                }
                else {
                    ir['selectedClick'] = false;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    rightSwitch() {
        this.selectedData.forEach((element) => {
            this.dragDropValidation(element);
        });
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.selectedData.push(this.switchingObject);
            this.switchingObject['isSelected'] = true;
            this.availableData.forEach((option, index) => {
                if (option['isSelected']) {
                    this.availableData.splice(index, 1);
                    option['selectedClick'] = false;
                }
            });
            this.switchingObject = null;
            this.dataEmitter();
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    dragDropValidation(element) {
        if (this.switchingObject === element) {
            this.switchingObject.isSelected = false;
        }
    }
    /**
     * @return {?}
     */
    leftSwitch() {
        this.setLeftSwitch();
    }
    /**
     * @return {?}
     */
    setLeftSwitch() {
        const /** @type {?} */ flag = false;
        this.availableData.forEach((element) => {
            this.dragDropValidation(element);
        });
        if (!flag && this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.availableData.push(this.switchingObject);
            this.switchingObject['isSelected'] = false;
            this.selectedData.forEach((option, index) => {
                if (!option['isSelected']) {
                    this.selectedData.splice(index, 1);
                }
            });
            this.switchingObject = null;
            this.dataEmitter();
        }
    }
    /**
     * @return {?}
     */
    upSwitch() {
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.selectedData.forEach((opt, i) => {
                this.getIndexObject(opt, i);
            });
            if (this.objectIndex !== 0) {
                const /** @type {?} */ index = this.selectedData[this.objectIndex];
                this.selectedData[this.objectIndex] = this.selectedData[this.objectIndex - 1];
                this.selectedData[this.objectIndex - 1] = index;
                this.dataEmitter();
            }
        }
    }
    /**
     * @return {?}
     */
    downSwitch() {
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.selectedData.forEach((opt, i) => {
                this.getIndexObject(opt, i);
            });
            if (this.selectedData.length - 1 !== this.objectIndex) {
                const /** @type {?} */ index = this.selectedData[this.objectIndex];
                this.selectedData[this.objectIndex] = this.selectedData[this.objectIndex + 1];
                this.selectedData[this.objectIndex + 1] = index;
                this.dataEmitter();
            }
        }
    }
    /**
     * @return {?}
     */
    moveTop() {
        const /** @type {?} */ tempArray = [];
        if (this.switchingObject != null && this.switchingObject['isSelected']) {
            this.selectedData.forEach((opt, i) => {
                this.getIndexObject(opt, i);
            });
            if (this.selectedData.length > 1) {
                tempArray[0] = this.selectedData[this.objectIndex];
                this.selectedData.splice(this.objectIndex, 1);
                this.selectedData.forEach((option) => {
                    tempArray.push(option);
                });
                this.selectedData = tempArray;
                this.dataEmitter();
            }
        }
    }
    /**
     * @return {?}
     */
    moveBottom() {
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected')) {
            this.selectedData.forEach((opt, i) => {
                this.getIndexObject(opt, i);
            });
            if (this.switchingObject['isSelected'] && this.selectedData.length > 1) {
                this.selectedData.splice(this.objectIndex, 1);
                this.selectedData[this.selectedData.length] = this.switchingObject;
            }
        }
        this.dataEmitter();
    }
    /**
     * @return {?}
     */
    dataEmitter() {
        this.availableRecords.emit(this.availableData);
        this.selectedRecords.emit(this.selectedData);
    }
    /**
     * @param {?} opt
     * @param {?} i
     * @return {?}
     */
    getIndexObject(opt, i) {
        if (opt[this.valuefield] === this.switchingObject[this.valuefield]) {
            this.objectIndex = i;
        }
    }
    /**
     * @param {?} dragData
     * @return {?}
     */
    onDragStartLeft(dragData) {
        if (!this.acrossitemselector) {
            this.itemClick(dragData.data, dragData.index, true, false);
        }
        else {
            dragData.event.dataTransfer.setData('itemnodedata', JSON.stringify(dragData.data));
            this.onDrag.emit(dragData);
        }
    }
    /**
     * @param {?} dragData
     * @return {?}
     */
    onDragStartRight(dragData) {
        if (!this.acrossitemselector) {
            this.itemClick(dragData.data, dragData.index, false, true);
        }
        else {
            dragData.event.dataTransfer.setData('itemnodedata', JSON.stringify(dragData.data));
            this.onDrag.emit(dragData);
        }
    }
    /**
     * @param {?} dragOverData
     * @return {?}
     */
    allowDrop(dragOverData) {
        dragOverData.event.preventDefault();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dropRight(event) {
        if (this.enabledrop) {
            this.rightSwitch();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dropLeft(event) {
        if (this.enabledrop) {
            this.leftSwitch();
        }
    }
}
AmexioItemSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-item-selector', template: `
    <amexio-row>
      <amexio-column [size]="'45pt'">
        <amexio-card [header]="true">
          <amexio-header>Available</amexio-header>
          <amexio-body>
            <div style="height: 220px;" *ngIf="mask">
              <div class="spinner"></div>
            </div>
            <div [style.height.px]="height" (dragover)="allowDrop({event:$event,data:data})" (drop)="dropLeft($event)" *ngIf="!mask" style="overflow: auto">
              <div class="itemselector-list" [ngClass]="data['isSelected'] ? 'itemselector-list-active':''" *ngFor="let data of availableData; let i = index"
                (click)="itemClick(data,i, true,false)" [attr.draggable]="enabledrag" (dragstart)="onDragStartLeft({event:$event,data:data,index:i})">
                {{data[displayfield]}}
              </div>
            </div>
          </amexio-body>
        </amexio-card>
      </amexio-column>


      <amexio-column [size]="'10pt'">

        <div class="item-selector-action-panel">

          <amexio-card [header]="true">
            <amexio-header>&nbsp;</amexio-header>
            <amexio-body>

              <div class="actionbar">
                <div [style.height.px]="height" class="actionbarinner">
                  <div [ngClass]="{'actiondisable':!rightactive}" (click)="moveTop()" class="action movetop ">
                    <amexio-data-icon key="itemselector_caretup"></amexio-data-icon>
                  </div>
                  <div [ngClass]="{'actiondisable':!rightactive}" (click)="upSwitch()" class="action moveup">
                    <amexio-data-icon key="itemselector_arrowup"></amexio-data-icon>
                  </div>
                  <div [ngClass]="{'actiondisable':!rightactive}" (click)="leftSwitch()" class="action moveleft">
                    <amexio-data-icon key="itemselector_arrowleft"></amexio-data-icon>
                  </div>
                  <div [ngClass]="{'actiondisable':!leftactive}" (click)="rightSwitch()" class="action moveright">
                    <amexio-data-icon key="itemselector_arrowright"></amexio-data-icon>
                  </div>
                  <div [ngClass]="{'actiondisable':!rightactive}" (click)="downSwitch()" class="action movedown">
                    <amexio-data-icon key="itemselector_arrowdown"></amexio-data-icon>
                  </div>
                  <div [ngClass]="{'actiondisable':!rightactive}" (click)="moveBottom()" class="action movebottom">
                    <amexio-data-icon key="itemselector_caretdown"></amexio-data-icon>
                  </div>
                </div>
              </div>
            </amexio-body>
          </amexio-card>
        </div>

      </amexio-column>

      <amexio-column [size]="'45pt'">
        <amexio-card [header]="true">
          <amexio-header>Selected</amexio-header>
          <amexio-body>
            <div [style.height.px]="height" style="overflow: auto" (dragover)="allowDrop({event:$event,data:data})" (drop)="dropRight($event)">
              <div  [attr.draggable]="enabledrag" class="itemselector-list" *ngFor="let data of selectedData; let i = index" (click)="itemClick(data,i, false,true)"
               [ngClass]="data['selectedClick'] ? 'itemselector-list-active':''" (dragstart)="onDragStartRight({event:$event,data:data,index:i})">
                {{data[displayfield]}}
              </div>
            </div>
          </amexio-body>
        </amexio-card>
      </amexio-column>
    </amexio-row>
  `,
            },] },
];
/** @nocollapse */
AmexioItemSelectorComponent.ctorParameters = () => [
    { type: CommonDataService }
];
AmexioItemSelectorComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    height: [{ type: Input }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    enabledrag: [{ type: Input, args: ['enable-drag',] }],
    enabledrop: [{ type: Input, args: ['enable-drop',] }],
    acrossitemselector: [{ type: Input, args: ['across-itemselector',] }],
    availableRecords: [{ type: Output }],
    selectedRecords: [{ type: Output }],
    onDrag: [{ type: Output }],
    dragover: [{ type: Output }],
    dragData: [{ type: Input }],
    parentRef: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 11/22/17.
 */
class AmexioListBoxComponent {
    /**
     * @param {?} dataService
     * @param {?} renderer
     */
    constructor(dataService, renderer) {
        this.dataService = dataService;
        this.renderer = renderer;
        /*
        Properties
        name : enable-header
        datatype : boolean
        version : 4.2.4 onwards
        default : true
        description : User can disabled header of listbox to false..
        */
        this.enableHeader = true;
        /*
        Events
        name : selectedRows
        datatype : none
        version : none
        default : none
        description : It will fire only on selection of checkbox and gives you selected record data.
        */
        this.selectedRows = new EventEmitter();
        /*
        Events
        name : onRowClick
        datatype : none
        version : none
        default : none
        description : It will gives you row clicked data.
        */
        this.onRowClick = new EventEmitter();
        /*
        Events
        name : rightClick
        datatype : none
        version : 5.0.1
        default : none
        description : It will gives you row clicked data.
        */
        this.rightClick = new EventEmitter();
        this.selectAll = false;
        this.maskloader = true;
        this.mouseLocation = { left: 0, top: 0 };
        this.filter = false;
        this.enablecheckbox = false;
        this.selectedData = [];
        this.searchplaceholder = 'Search';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.response = response;
            }, (error) => {
            }, () => {
                this.setData(this.response);
            });
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.previousData) !== JSON.stringify(this.data)) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewData = responsedata;
        this.setSelectedFlag(this.viewData);
        this.orgData = JSON.parse(JSON.stringify(this.viewData));
    }
    /**
     * @param {?} viewRows
     * @return {?}
     */
    setSelectedFlag(viewRows) {
        viewRows.forEach((row) => {
            if (!row.hasOwnProperty('isSelected')) {
                row['isSelected'] = false;
            }
        });
        this.maskloader = false;
    }
    /**
     * @return {?}
     */
    filterData() {
        const /** @type {?} */ tData = JSON.parse(JSON.stringify(this.orgData));
        const /** @type {?} */ nodes = this.searchTree(tData, this.filterText);
        this.viewData = nodes;
    }
    /**
     * @param {?} data
     * @param {?} matchingTitle
     * @return {?}
     */
    searchTree(data, matchingTitle) {
        const /** @type {?} */ disp = this.displayfield;
        return data.filter(function f(node) {
            if (node[disp] && node[disp].toLowerCase().startsWith(matchingTitle.toLowerCase())) {
                return true;
            }
            if (node.children) {
                return (node.children = node.children.filter(f)).length;
            }
        });
        // return res;
    }
    /**
     * @param {?} rowData
     * @return {?}
     */
    selectedCheckBox(rowData) {
        rowData.isSelected = !rowData.isSelected;
        this.selectedData = [];
        this.viewData.forEach((node) => {
            if (node.isSelected) {
                this.selectedData.push(node);
            }
        });
        this.selectedRows.emit(this.selectedData);
    }
    /**
     * @return {?}
     */
    selectAllRecord() {
        this.selectedData = [];
        this.selectAll = !this.selectAll;
        if (this.selectAll) {
            this.viewData.forEach((node) => {
                node.isSelected = true;
            });
            this.selectedData = this.viewData;
        }
        else {
            this.viewData.forEach((node) => {
                node.isSelected = false;
            });
        }
        this.selectedRows.emit(this.selectedData);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onClick(data) {
        this.onRowClick.emit(data);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @param {?} event
     * @param {?} row
     * @param {?} id
     * @return {?}
     */
    loadContextMenu(event, row, id) {
        this.tempSelectedFlag(this.viewData);
        this.mouseLocation.left = event.clientX;
        this.mouseLocation.top = event.clientY;
        row.isSelected = true;
        this.getContextMenu();
        this.posixUp = this.getListPosition(id);
        event.preventDefault();
        event.stopPropagation();
        this.rightClickRowData = row;
        this.contextMenuStyle = this.getContextMenuStyle();
    }
    /**
     * @return {?}
     */
    getContextMenu() {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.contextMenuFlag = true;
            this.addListner();
        }
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    tempSelectedFlag(rows) {
        rows.forEach((row) => {
            if (row.isSelected) {
                row.isSelected = false;
            }
        });
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        const /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @return {?}
     */
    getContextMenuStyle() {
        return {
            'cursor': 'default',
            'position': 'fixed',
            'display': this.contextMenuFlag ? 'block' : 'none',
            'left': this.mouseLocation.left + 'px',
            'top': this.mouseLocation.top + 'px',
            'box-shadow': '1px 1px 2px #000000',
            'width': '15%',
        };
    }
    /**
     * @param {?} itemConfig
     * @return {?}
     */
    onContextNodeClick(itemConfig) {
        if (!itemConfig.disabled) {
            const /** @type {?} */ obj = {
                menuData: itemConfig,
                rowData: this.rightClickRowData,
            };
            this.contextMenuFlag = false;
            this.removeListner();
            this.rightClick.emit(obj);
        }
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (e) => {
            this.contextMenuFlag = false;
            if (!this.contextMenuFlag) {
                this.removeListner();
            }
        });
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
    }
}
AmexioListBoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-listbox', template: `

    <div class="listbox" [style.border]="border">

      <div *ngIf="enableHeader" class="header" style="display: flex; justify-content: space-between">
        <div style="display: flex;justify-content: flex-start;">
          <div *ngIf="enablecheckbox"  class="input-box">
            <div *ngIf="!selectAll" (click)="selectAllRecord()" class="checkbox default"></div>
            <div *ngIf="selectAll" (click)="selectAllRecord()" class="checkbox active">&#10004;</div>
          </div>
          <div class="title">&nbsp;&nbsp;{{header}}</div>
        </div>

        <div *ngIf="(filter == true)">
          <input type="text" [(ngModel)]="filterText" [placeholder]="searchplaceholder" (keyup)="filterData()" class="search "/>
        </div>
      </div>

      <div class="listbox-height" [style.height.px]="height">
        <ul class="list" [ngClass]="{'loading-mask' : maskloader}">
          <li #id class="list-items" *ngFor="let row of viewData let rowno = index " [ngClass]="{'tree-node-label-selected':row.isSelected ,'tree-node-label-not-selected':row.isSelected=='false'}">

            <div (click)="onClick(row)" (contextmenu)="loadContextMenu($event,row, id)">
              <ng-container *ngIf="enablecheckbox">
                <div class="inputgroup" style="float: left; height: 100%;">
                  <div class="input-box">
                    <div (click)="selectedCheckBox(row)" [class]="row.isSelected ?'checkbox active':'checkbox default'">
                      {{row.isSelected ? '&#10004;' : ''}}
                    </div>
                  </div>
                </div>&nbsp;
              </ng-container>
              <ng-container *ngIf="!bodyTemplate"> {{row[displayfield]}}</ng-container>
              <ng-template *ngIf="bodyTemplate" [ngTemplateOutlet]="bodyTemplate" [ngTemplateOutletContext]="{ row: row }"></ng-template>
            </div>

          </li>
        </ul>
      </div>
    </div>

    <span [ngStyle]="contextMenuStyle">
      <ul *ngIf="contextMenuFlag" class="context-menu-list" [ngClass]="{'dropdown-up' : posixUp}">
        <li (click)="onContextNodeClick(itemConfig)" class="context-menu-list-items" [ngStyle]="{'cursor': itemConfig.disabled ? 'not-allowed':'pointer'}" [ngClass]="{'context-menu-separator':itemConfig.seperator}"
          *ngFor="let itemConfig of contextmenu">
          <em [ngStyle]="{'padding-left': itemConfig.icon ? '5px':'19px'}" [ngClass]="itemConfig.icon"></em>
          <span style="white-space: nowrap;display: inline ; padding-left:5px">{{itemConfig.text}}
          </span>
        </li>
      </ul>
    </span>
  `,
            },] },
];
/** @nocollapse */
AmexioListBoxComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: Renderer2 }
];
AmexioListBoxComponent.propDecorators = {
    enablecheckbox: [{ type: Input, args: ['enable-checkbox',] }],
    header: [{ type: Input }],
    enableHeader: [{ type: Input, args: ['enable-header',] }],
    searchplaceholder: [{ type: Input, args: ['search-placeholder',] }],
    filter: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    height: [{ type: Input }],
    selectedRows: [{ type: Output }],
    onRowClick: [{ type: Output }],
    border: [{ type: Input }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    rightClick: [{ type: Output }],
    bodyTemplate: [{ type: ContentChild, args: ['amexioBodyTmpl',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 11/23/17.
 */
class AmexioPaginatorComponent {
    constructor() {
        /*
        Events
        name : onRowChange
        datatype : none
        version : none
        default : none
        description : if you click on '<<' will get 1st record and if you click on '>>' will get last record.
        */
        this.onRowChange = new EventEmitter();
        /*
        Events
        name : onPageChange
        datatype : none
        version : none
        default : none
        description : It will gives you current page number
        */
        this.onPageChange = new EventEmitter();
        this.fullPageSet = [];
        this.activePages = [];
        this.pageIndex = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.size == null || this.size === '') {
            this.size = 'medium';
        }
        this.initializePages();
    }
    /**
     * @param {?} change
     * @return {?}
     */
    ngOnChanges(change) {
        if (change["pages"] && !change["pages"].isFirstChange()) {
            this.initializePages();
        }
        if (change["rows"] && !change["rows"].isFirstChange()) {
            this.initializePages();
        }
    }
    /**
     * @return {?}
     */
    initializePages() {
        if (this.rows > this.pages) {
            this.rows = this.pages;
        }
        this.fullPageSet.length = 0;
        this.activePages.length = 0;
        this.pageIndex.length = 0;
        if (this.rows != null) {
            for (let /** @type {?} */ i = 0; i < this.pages; i++) {
                this.fullPageSet.push(i + 1);
            }
            this.calculateRows();
            this.setRows(this.rows);
        }
        else {
            for (let /** @type {?} */ i = 0; i < this.pages; i++) {
                this.fullPageSet.push(i + 1);
                this.activePages.push(i + 1);
            }
        }
        this.setBoundaries();
        this.activePageIndex = 0;
        this.currentRowIndex = 0;
    }
    /**
     * @return {?}
     */
    onFirstClick() {
        this.activePageIndex = 0;
        this.changeRows(this.pageIndex[0], 0, null);
        this.onPageChange.emit(this.activePage);
    }
    /**
     * @return {?}
     */
    onLastClick() {
        this.activePageIndex = this.activePages.length - 1;
        this.changeRows(this.pageIndex[this.pageIndex.length - 1], this.pageIndex.length - 1, null);
        this.activePageIndex = this.activePages.length - 1;
        this.activePage = this.activePages[this.activePages.length - 1];
        this.onPageChange.emit(this.activePage);
    }
    /**
     * @return {?}
     */
    onPrevious() {
        if (this.activePageIndex !== 0) {
            // within row bounds
            this.activePageIndex -= 1;
            this.activePage = this.activePages[this.activePageIndex];
            this.onPageChange.emit(this.activePage);
        }
        else {
            // load prev rows
            let /** @type {?} */ sIndx;
            if (this.fullPageSet.indexOf(this.activePage) === 1) {
                sIndx = this.fullPageSet.indexOf(this.activePage);
            }
            else {
                sIndx = this.fullPageSet.indexOf(this.activePage) - 1;
            }
            if (sIndx > 0) {
                this.changeRows(this.pageIndex[this.currentRowIndex - 1], this.currentRowIndex - 1, null);
                this.activePageIndex = this.activePages.length - 2;
                this.activePage = this.activePages[this.activePages.length - 2];
                this.onPageChange.emit(this.activePage);
            }
        }
    }
    /**
     * @return {?}
     */
    onNext() {
        if (this.activePageIndex !== this.activePages.length - 1) {
            // within row bounds
            this.activePageIndex += 1;
            this.activePage = this.activePages[this.activePageIndex];
            this.onPageChange.emit(this.activePage);
        }
        else {
            // load next rows
            const /** @type {?} */ sIndx = this.fullPageSet.indexOf(this.activePage) + 1;
            if (sIndx <= this.fullPageSet.length - 1) {
                this.changeRows(this.pageIndex[this.currentRowIndex + 1], this.currentRowIndex + 1, null);
                this.activePageIndex = 1;
                this.activePage = this.activePages[1];
                this.onPageChange.emit(this.activePage);
            }
        }
    }
    /**
     * @param {?} rowNumber
     * @param {?} inDx
     * @param {?} event
     * @return {?}
     */
    changeRows(rowNumber, inDx, event) {
        if (rowNumber != null) {
            this.activePages = [];
            if (this.pages < rowNumber) {
                this.currentRow = this.pages;
                for (let /** @type {?} */ i = this.currentRow - this.rows + 1; i <= this.currentRow; i++) {
                    if (i !== 0) {
                        this.activePages.push(i);
                    }
                }
            }
            else {
                this.getCurrentRow(rowNumber);
            }
            this.onPageChangeMethod(inDx);
            if (event) {
                this.show = !this.show;
            }
        }
    }
    /**
     * @param {?} rowNumber
     * @return {?}
     */
    getCurrentRow(rowNumber) {
        this.currentRow = rowNumber;
        for (let /** @type {?} */ i = this.currentRow - this.rows; i <= this.currentRow; i++) {
            if (i !== 0) {
                this.activePages.push(i);
            }
        }
    }
    /**
     * @param {?} inDx
     * @return {?}
     */
    onPageChangeMethod(inDx) {
        this.currentRowIndex = inDx;
        this.onRowChange.emit(this.currentRow);
        this.setBoundaries();
        this.activePageIndex = 0;
        this.activePage = this.activePages[0];
        this.onPageChange.emit(this.activePage);
    }
    /**
     * @param {?} page
     * @param {?} index
     * @return {?}
     */
    onPageClick(page, index) {
        this.activePageIndex = index;
        this.activePage = page;
        this.onPageChange.emit(this.activePage);
    }
    /**
     * @return {?}
     */
    calculateRows() {
        for (let /** @type {?} */ i = 0; i < this.rows; i++) {
            this.activePages.push(i + 1);
        }
        this.currentRow = this.rows;
        // calc rows
        const /** @type {?} */ loopI = Math.round(this.pages / this.rows);
        for (let /** @type {?} */ i = 1; i <= loopI; i++) {
            this.pageIndex.push(this.rows * i);
        }
    }
    /**
     * @param {?} rowNumber
     * @return {?}
     */
    setRows(rowNumber) {
        this.activePages = [];
        if (rowNumber > this.pages) {
            this.currentRow = this.pages;
        }
        else {
            this.currentRow = rowNumber;
        }
        for (let /** @type {?} */ i = 0; i < this.currentRow; i++) {
            this.activePages.push(i + 1);
        }
    }
    /**
     * @return {?}
     */
    setBoundaries() {
        this.bFirst = this.activePages[0];
        this.bLast = this.activePages[this.activePages.length - 1];
    }
    /**
     * @return {?}
     */
    showColumnOptions() {
        this.show = !this.show;
    }
}
AmexioPaginatorComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-paginator', template: `
    <div class="paginator">
          <span class="paginator-pages">
            <a class="paginator-page" (click)="onPrevious()">&lt;</a>
            <a class="paginator-page" (click)="onFirstClick()">&lt;&lt;</a>
          </span>
      <span class="paginator-pages" *ngFor="let page of activePages;let i = index">
            <a class="paginator-page" [ngClass]="{'active' : activePageIndex == i  }" (click)="onPageClick(page,i)">{{page}}</a>
          </span>
      <span class="paginator-pages">
            <a class="paginator-page" (click)="onLastClick()">&gt;&gt;</a>
            <a class="paginator-page" (click)="onNext()">&gt;</a>
          </span>
      <ng-container *ngIf="pages > rows">
      <span class="paginator-pages">
            <a class="paginator-page" (click)="showColumnOptions()" style=" cursor: pointer;">{{currentRow}} &nbsp;  &#9660;</a>
            <span *ngIf="show" class="dropdown" style="width: 50px;">
                <ul class="dropdown-list">
                  <li class="list-items" *ngFor="let row of pageIndex;let i = index" (click)="changeRows(row,i, $event)"><div>{{row}}</div></li>
                </ul>
            </span>
          </span>
      </ng-container>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioPaginatorComponent.ctorParameters = () => [];
AmexioPaginatorComponent.propDecorators = {
    pages: [{ type: Input }],
    rows: [{ type: Input }],
    size: [{ type: Input }],
    onRowChange: [{ type: Output }],
    onPageChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioProgressMultiBarComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioProgressMultiBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-multi-bar', template: `

  `,
            },] },
];
/** @nocollapse */
AmexioProgressMultiBarComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 27/12/17.
 */
class AmexioProgressBarComponent {
    constructor() {
        /*
        Properties
        name : show
        datatype : boolean
        version : 4.0 onwards
        default : true
        description :  Shows / Hides the progress bar.
        */
        this.showProgress = true;
        this.progressclass = '';
        this.strippedCss = 'stripped ';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.height) {
            this.height = this.height + 'px';
        }
        else {
            this.height = '20px';
        }
        if (this.stripped) {
            this.progressclass = this.progressclass + this.strippedCss;
        }
        if (this.type && !this.amexiocolor) {
            this.progressclass = this.progressclass + this.type.toLocaleLowerCase();
        }
        else if (this.amexiocolor && !this.type) {
            this.progressclass = this.progressclass + this.amexiocolor.toLocaleLowerCase();
        }
    }
}
AmexioProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-progress-bar', template: `
    <div *ngIf="showProgress" class="progress" [ngStyle]="{'height':height}">
      <span [ngClass]="progressclass" *ngIf="infinite" style="width: 100%;">{{label != null ? label : 'Loading...'}}</span>
      <span [ngClass]="progressclass" *ngIf="!infinite" [ngStyle]="{'width.%' : currentvalue}"></span>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioProgressBarComponent.ctorParameters = () => [];
AmexioProgressBarComponent.propDecorators = {
    showProgress: [{ type: Input, args: ['show',] }],
    infinite: [{ type: Input }],
    type: [{ type: Input }],
    amexiocolor: [{ type: Input, args: ['amexio-color',] }],
    currentvalue: [{ type: Input, args: ['current-value',] }],
    label: [{ type: Input }],
    height: [{ type: Input }],
    stripped: [{ type: Input }],
    multi: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 11/12/17.
 */
class AmexioFilterTreeComponent {
    /**
     * @param {?} _http
     * @param {?} cdf
     * @param {?} treeViewFilterService
     */
    constructor(_http, cdf, treeViewFilterService) {
        this._http = _http;
        this.cdf = cdf;
        this.treeViewFilterService = treeViewFilterService;
        /*
        Properties
        name : enable-checkbox
        datatype : false
        version : 4.0 onwards
        default : false
        description : Enables checkbox for each row, this allows user for multi selection.
        */
        this.enablecheckbox = false;
        /*
        Events
        name : nodeClick
        datatype : none
        version : none
        default : none
        description : It will gives you clicked node data.
        */
        this.nodeClick = new EventEmitter();
        /*
        Events
        name : onTreeNodeChecked
        datatype : none
        version : none
        default : none
        description : It will gives whole tree data with checked flag status.
        */
        this.onTreeNodeChecked = new EventEmitter();
        this.isDataFound = true;
        this.onClickSearch = false;
        this.mask = true;
        this.filterIndex = 3;
        this.triggerchar = 1;
        this.filterOptionData = [{
                key: 'Is Equal To', value: '1', type: 'string', checkedStatus: '',
            }, {
                key: 'Is Not Equal To', value: '2', type: 'string', checkedStatus: '',
            }, {
                key: 'Start With', value: '3', type: 'string', checkedStatus: 'fa fa-check',
            }, {
                key: 'Ends With', value: '4', type: 'string', checkedStatus: '',
            }, {
                key: 'Contains', value: '5', type: 'string', checkedStatus: '',
            }];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.parentTmp != null) {
            this.templates = { treeNodeTemplate: this.parentTmp };
        }
        else if (this.templates != null) {
            this.parentTmp = this.templates.treeNodeTemplate;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.parentTmp != null) {
            this.templates = { treeNodeTemplate: this.parentTmp };
        }
        else if (this.templates != null) {
            this.parentTmp = this.templates.treeNodeTemplate;
        }
        if (this.httpmethod && this.httpurl) {
            this.callService();
        }
        else if (this.data) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.previousValue) !== JSON.stringify(this.data)) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @return {?}
     */
    filterData() {
        this.showToolTip = false;
        if (this.filterText.length >= this.triggerchar) {
            const /** @type {?} */ tData = JSON.parse(JSON.stringify(this.orgTreeData));
            const /** @type {?} */ treeNodes = this.searchTree(tData, this.filterText);
            this.treeData = treeNodes;
            if (this.treeData.length === 0) {
                this.isDataFound = false;
            }
            else {
                this.isDataFound = true;
            }
        }
        else if (this.onClickSearch) {
            const /** @type {?} */ tData = JSON.parse(JSON.stringify(this.orgTreeData));
            const /** @type {?} */ treeNodes = this.searchTree(tData, this.filterText);
            this.treeData = treeNodes;
            this.onClickSearch = false;
            if (this.treeData.length === 0) {
                this.isDataFound = false;
            }
            else {
                this.isDataFound = true;
            }
        }
        else {
            this.isDataFound = true;
            this.treeData = this.orgTreeData;
        }
    }
    /**
     * @param {?} data
     * @param {?} matchingTitle
     * @return {?}
     */
    searchTree(data, matchingTitle) {
        const /** @type {?} */ fi = this.filterIndex;
        return this.filterActualData(data, fi, matchingTitle);
    }
    /**
     * @param {?} data
     * @param {?} fi
     * @param {?} matchingTitle
     * @return {?}
     */
    filterActualData(data, fi, matchingTitle) {
        return data.filter(function f(node) {
            if ((fi === 5 && node.text.toLowerCase().includes(matchingTitle.toLowerCase())) ||
                (fi === 3 && node.text.toLowerCase().startsWith(matchingTitle.toLowerCase())) ||
                (fi === 1 && node.text.toLowerCase() === matchingTitle.toLowerCase()) ||
                (fi === 2 && node.text.toLowerCase() !== matchingTitle.toLowerCase()) ||
                (fi === 4 && node.text.toLowerCase().endsWith(matchingTitle.toLowerCase()))) {
                return true;
            }
            if (node.children) {
                return (node.children = node.children.filter(f)).length;
            }
        });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    filterOption(data) {
        this.onClickSearch = true;
        this.filterIndex = data.value;
        this.filterOptionData.forEach((opt) => {
            if (opt.value !== data.value) {
                opt.checkedStatus = '';
            }
            else {
                opt.checkedStatus = 'fa fa-check';
            }
        });
        this.filterData();
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    renderServiceData() {
        this.setData(this.data);
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        const /** @type {?} */ tdata = this.getData(httpResponse);
        if (tdata) {
            this.orgTreeData = JSON.parse(JSON.stringify(tdata));
            this.treeData = tdata;
        }
        this.mask = false;
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    }
    /**
     * @return {?}
     */
    callService() {
        this.treeViewFilterService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
            this.data = response;
        }, () => {
            this.renderServiceData();
        });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onRowSelect(data) {
        this.nodeClick.emit(data);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onCheckSelect(data) {
        this.onTreeNodeChecked.emit(data);
    }
}
AmexioFilterTreeComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tree-filter-view', template: `
    <div>
      <div>
        <div class="inputgroup">
          <input type="text" class="input-control text-input-width" aria-label="Text input with dropdown button" [(ngModel)]="filterText"
                 placeholder="Search" (keyup)="filterData()">
          <!--<i class="fa fa-filter" aria-hidden="true" (click)="showToolTip = !showToolTip"></i>-->
          <span class="datatable-filter-icon">
          <amexio-data-icon key="tree_filter" (click)="showToolTip = !showToolTip"></amexio-data-icon>
          </span>
          <!--  <div class="input-group-btn">-->
          <!-- <button type="button"
          class="btn" data-toggle="dropdown"
          (click)="showToolTip = !showToolTip"
          aria-haspopup="true" aria-expanded="false">
           </button>-->
          <span *ngIf="showToolTip" class="dropdown">
              <ul class="dropdown-list">
                <li class="list-items" *ngFor="let opt of filterOptionData" (click)="filterOption(opt)">{{opt.key}}&nbsp;
                  <!--<i [class]="opt.checkedStatus" aria-hidden="true"></i>-->
                  <amexio-data-icon key="opt.checkedStatus"></amexio-data-icon>
                </li>
              </ul>
            </span>
          <!-- </div>-->
        </div>
        <ng-container *ngIf="isDataFound">
          <amexio-treeview
            [data]="treeData"
            [enable-checkbox]="enablecheckbox"
            (onTreeNodeChecked)="onCheckSelect($event)"
            (nodeClick)="onRowSelect($event)" [templates]="templates">
          </amexio-treeview>
        </ng-container>
        <ng-container *ngIf="!isDataFound">
          <p>No Data Found.</p>
        </ng-container>

      </div>
    </div>


  `,
            },] },
];
/** @nocollapse */
AmexioFilterTreeComponent.ctorParameters = () => [
    { type: HttpClient },
    { type: ChangeDetectorRef },
    { type: CommonDataService }
];
AmexioFilterTreeComponent.propDecorators = {
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    data: [{ type: Input, args: ['data',] }],
    enablecheckbox: [{ type: Input, args: ['enable-checkbox',] }],
    nodeClick: [{ type: Output }],
    onTreeNodeChecked: [{ type: Output }],
    triggerchar: [{ type: Input, args: ['trigger-char',] }],
    parentTmp: [{ type: ContentChild, args: ['amexioTreeTemplate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/1/17.
 */
class HorizontalTreeViewNodeComponent {
    constructor() {
        /*
        Events
        name : onNodeClick
        datatype : none
        version : none
        default : none
        description : It will gives you clicked node data.
        */
        this.onNodeClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onClick(node) {
        node.expand = !node.expand;
        this.onNodeClick.emit(node);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onInnerClick(node) {
        this.onNodeClick.emit(node);
    }
}
HorizontalTreeViewNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-horizontal-treeviewnode', template: `
    <div class="horizontaltreeview-node">
      <div class="horizontaltreeview-node-entry" [ngClass]="{'sole':data.length==1}" *ngFor="let node of data">
        <span class="horizontaltreeview-node-label" (click)="onClick(node)">
          {{node.text}}
          <span  *ngIf="node.children && (node.children.length>0)" class="float-right" (click)="onClick(node)">
            <amexio-data-icon *ngIf="node.expand" key="horizontal-tree-collapse"></amexio-data-icon>
            <amexio-data-icon *ngIf="!node.expand" key="horizontal-tree-expanded"></amexio-data-icon>
          </span>
        </span>
        <amexio-horizontal-treeviewnode *ngIf="node.expand && node.children && (node.children.length>0)"
                                        [data]="node.children"
                                        (onNodeClick)="onInnerClick($event)"></amexio-horizontal-treeviewnode>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
HorizontalTreeViewNodeComponent.ctorParameters = () => [];
HorizontalTreeViewNodeComponent.propDecorators = {
    data: [{ type: Input }],
    onNodeClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/1/17.
 */
class HorizontalTreeViewComponent {
    /**
     * @param {?} dataService
     */
    constructor(dataService) {
        this.dataService = dataService;
        /*
        Events
        name : nodeClick
        datatype : none
        version : none
        default : none
        description : It will gives you clicked node data.
        */
        this.nodeClick = new EventEmitter();
        this.mask = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.responseData = response;
            }, (error) => {
            }, () => {
                this.setData(this.responseData);
            });
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        // Check if key is added?
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.mask = false;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    nodeclick(node) {
        this.nodeClick.emit(node);
    }
}
HorizontalTreeViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-horizontal-treeview', template: `

    <div class="horizontaltreeview">
      <span class="horizontaltreeview-node-label">{{label}}</span>
      <div style="height: 300px;" *ngIf="mask">
        <div class="spinner"></div>
      </div>
      <amexio-horizontal-treeviewnode *ngIf="!mask" [data]="data" (onNodeClick)="nodeclick($event)"></amexio-horizontal-treeviewnode>
    </div>
  `,
            },] },
];
/** @nocollapse */
HorizontalTreeViewComponent.ctorParameters = () => [
    { type: CommonDataService }
];
HorizontalTreeViewComponent.propDecorators = {
    label: [{ type: Input }],
    data: [{ type: Input }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    nodeClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 11/23/17.
 */
class AmexioTreeViewComponent {
    /**
     * @param {?} element
     * @param {?} dataService
     * @param {?} cdf
     * @param {?} renderer
     */
    constructor(element, dataService, cdf, renderer) {
        this.element = element;
        this.dataService = dataService;
        this.cdf = cdf;
        this.renderer = renderer;
        /*
          Events
          name : nodeClick
          datatype : none
          version : none
          default : none
          description : It will gives you clicked node data.
          */
        this.nodeClick = new EventEmitter();
        /*
        Properties
        name : enable-checkbox
        datatype : false
        version : 4.0 onwards
        default : none
        description : Enables checkbox for each row, this allows user for multi selection.
        */
        this.enablecheckbox = false;
        /*
          Properties
          name : enable-drop
          datatype : boolean
          version : 5.0.0 onwards
          default : false
          description : any node can be dropped in the tree structure
          */
        this.enabledrop = false;
        /*
        Properties
        name : across-tree
        datatype : boolean
        version : 5.0.0 onwards
        default : false
        description : Dragging and dropping is possible across tree.
        */
        this.acrosstree = false;
        /*
          Events
          name : onTreeNodeChecked
          datatype : any
          version : 4.0 onwards
          default : none
          description : It will gives whole tree data with checked flag status.
          */
        this.onTreeNodeChecked = new EventEmitter();
        this.onDrag = new EventEmitter();
        this.onDrop = new EventEmitter();
        this.dragover = new EventEmitter();
        this.nodeRightClick = new EventEmitter();
        this.rightClick = new EventEmitter();
        this.mouseLocation = { left: 0, top: 0 };
        this.isNode = true;
        this.acrosstree = false;
        this.displaykey = 'text';
        this.childarraykey = 'children';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.responseData = response;
            }, (error) => {
            }, () => {
                this.setData(this.responseData);
            });
        }
        else if (this.datareader && this.data) {
            this.setData(this.data);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout(() => {
            if (this.parentTmp != null) {
                this.templates = { treeNodeTemplate: this.parentTmp };
            }
            else if (this.templates != null) {
                this.parentTmp = this.templates.treeNodeTemplate;
            }
        });
        this.cdf.detectChanges();
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.previousValue) !== JSON.stringify(this.data) && this.previousValue != null && this.data != null) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    expandAll(node) {
        this.expandAllCall(this.parentRef);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    expandAllCall(node) {
        node.forEach((childCheck) => {
            if (!childCheck.expand) {
                childCheck.expand = true;
            }
            if (childCheck.hasOwnProperty(this.childarraykey)) {
                this.expandAllCall(childCheck[this.childarraykey]);
            }
        });
    }
    /**
     * @param {?} node
     * @return {?}
     */
    collapseAll(node) {
        this.collapseAllCall(this.parentRef);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    collapseAllCall(node) {
        node.forEach((childCheck) => {
            if (childCheck.expand) {
                childCheck.expand = false;
            }
            if (childCheck.hasOwnProperty(this.childarraykey)) {
                this.collapseAllCall(childCheck[this.childarraykey]);
            }
        });
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onClick(node) {
        node.expand = !node.expand;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onNodeClick(node) {
        this.nodeClick.emit(node);
        this.activateNode(this.data, node);
    }
    /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    activateNode(data, node) {
        for (const /** @type {?} */ i of data) {
            if (node === data[i] && !i[this.childarraykey]) {
                i['active'] = true;
            }
            else {
                i['active'] = false;
            }
            if (i[this.childarraykey]) {
                this.activateNode(i[this.childarraykey], node);
            }
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        // Check if key is added?
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.parentRef = this.data;
        this.setSelectedFlag();
        this.activateNode(this.data, null);
    }
    /**
     * @return {?}
     */
    setSelectedFlag() {
        this.parentRef.forEach((node) => {
            if (node.hasOwnProperty('isSelected')) {
                node.isSelected = false;
            }
            else {
                node['isSelected'] = false;
            }
            if (node.hasOwnProperty(this.childarraykey) && node[this.childarraykey].length > 0) {
                this.setSelectedFlagInChild(node);
            }
        });
    }
    /**
     * @param {?} node
     * @return {?}
     */
    setSelectedFlagInChild(node) {
        node[this.childarraykey].forEach((childcom) => {
            if (childcom.hasOwnProperty('isSelected')) {
                childcom.isSelected = false;
            }
            else {
                childcom['isSelected'] = false;
            }
            if (childcom.hasOwnProperty(this.childarraykey) && childcom[this.childarraykey].length > 0) {
                this.setSelectedFlagInChild(childcom);
            }
        });
    }
    /**
     * @param {?} checkedData
     * @return {?}
     */
    emitCheckedData(checkedData) {
        checkedData.checked = !checkedData.checked;
        if (checkedData.checked) {
            if (checkedData.hasOwnProperty(this.childarraykey)) {
                checkedData[this.childarraykey].forEach((option) => {
                    option.checked = true;
                    if (option.hasOwnProperty(this.childarraykey)) {
                        this.setCheckedStatusFromParent(option);
                    }
                });
            }
            this.onTreeNodeChecked.emit(this.data);
        }
        else {
            if (checkedData.hasOwnProperty(this.childarraykey)) {
                checkedData[this.childarraykey].forEach((option) => {
                    option.checked = false;
                    if (option.hasOwnProperty(this.childarraykey)) {
                        this.searchObject(option);
                    }
                });
            }
            this.onTreeNodeChecked.emit(this.data);
        }
    }
    /**
     * @param {?} object
     * @return {?}
     */
    searchObject(object) {
        object[this.childarraykey].forEach((childOption) => {
            childOption.checked = false;
            if (childOption.hasOwnProperty(this.childarraykey)) {
                this.searchObject(childOption);
            }
        });
    }
    /**
     * @param {?} object
     * @return {?}
     */
    setCheckedStatusFromParent(object) {
        object[this.childarraykey].forEach((childOption) => {
            childOption.checked = true;
            if (childOption.hasOwnProperty(this.childarraykey)) {
                this.setCheckedStatusFromParent(childOption);
            }
        });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onTreeNodeCheck(data) {
        this.onTreeNodeChecked.emit(this.data);
    }
    /**
     * @param {?} dragData
     * @return {?}
     */
    onDragStart(dragData) {
        dragData.event.dataTransfer.setData('treenodedata', JSON.stringify(dragData.data));
        dragData.event.dataTransfer.effectAllowed = 'copy';
        this.dragData = dragData;
        this.onDrag.emit(dragData);
    }
    /**
     * @param {?} dragOverData
     * @return {?}
     */
    allowDrop(dragOverData) {
        dragOverData.event.preventDefault();
        if (!this.enabledrop) {
            dragOverData.event.dataTransfer.dropEffect = 'none';
        }
        this.noDragMethod(this.dragData, dragOverData.data, dragOverData.event);
        this.dragover.emit(dragOverData);
    }
    /**
     * @param {?} dragData
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    noDragMethod(dragData, node, event) {
        if (!this.acrosstree) {
            if (dragData.data === node || node.leaf === true) {
                event.dataTransfer.dropEffect = 'none';
            }
            else {
                event.target.style.border = '3px dotted green';
            }
        }
        else {
            if (node.leaf === true) {
                event.dataTransfer.dropEffect = 'none';
            }
            else {
                event.target.style.border = '3px dotted green';
            }
        }
        if (dragData.data.hasOwnProperty(this.childarraykey)) {
            this.getDropNode(dragData, node, event);
        }
    }
    /**
     * @param {?} dragData
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    getDropNode(dragData, node, event) {
        dragData.data[this.childarraykey].forEach((child) => {
            if (JSON.stringify(child) === JSON.stringify(node) || node.leaf === true) {
                event.dataTransfer.dropEffect = 'none';
            }
            else if (child.hasOwnProperty(this.childarraykey)) {
                this.getDropNode(child[this.childarraykey], node, event);
            }
        });
    }
    /**
     * @param {?} dropData
     * @return {?}
     */
    drop(dropData) {
        if (this.enabledrop) {
            dropData.event.target.style.border = '';
            dropData.event.preventDefault();
            if (this.acrosstree === false) {
                this.setDropAcrosstree(dropData);
                if (this.isNode === true) {
                    this.setDropNodeTree(dropData);
                }
            }
            else {
                if (dropData.data.hasOwnProperty(this.childarraykey)) {
                    this.removeNode(dropData);
                    dropData.data[this.childarraykey].push(JSON.parse(dropData.event.dataTransfer.getData('treenodedata')));
                    this.onDrop.emit(dropData);
                }
            }
        }
    }
    /**
     * @param {?} dropData
     * @return {?}
     */
    setDropAcrosstree(dropData) {
        if (this.dragData.data === dropData.data) {
            this.isNode = false;
        }
        else if (this.dragData.data.hasOwnProperty(this.childarraykey)) {
            this.checkNode(this.dragData, dropData);
        }
    }
    /**
     * @param {?} dropData
     * @return {?}
     */
    setDropNodeTree(dropData) {
        if (dropData.data.hasOwnProperty(this.childarraykey)) {
            this.removeNode(dropData);
            dropData.data[this.childarraykey].push(JSON.parse(dropData.event.dataTransfer.getData('treenodedata')));
            this.onDrop.emit(dropData);
        }
    }
    /**
     * @param {?} dragData
     * @param {?} dropData
     * @return {?}
     */
    checkNode(dragData, dropData) {
        this.dragData.data[this.childarraykey].forEach((child) => {
            if (JSON.stringify(child) === JSON.stringify(dropData.data)) {
                this.isNode = false;
            }
            else if (child.hasOwnProperty(this.childarraykey)) {
                this.checkNode(child, dropData);
            }
        });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    removeNode(data) {
        this.removeDragNode(this.parentRef, JSON.parse(data.event.dataTransfer.getData('treenodedata')));
    }
    /**
     * @param {?} treeData
     * @param {?} dragNode
     * @return {?}
     */
    removeDragNode(treeData, dragNode) {
        treeData.forEach((childNode, index) => {
            if (JSON.stringify(childNode) === JSON.stringify(dragNode)) {
                treeData.splice(index, 1);
            }
            else if (childNode.hasOwnProperty(this.childarraykey)) {
                this.removeDragNode(childNode[this.childarraykey], dragNode);
            }
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragleave(event) {
        event.target.style.border = '';
    }
    /**
     * @return {?}
     */
    getContextMenu() {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    }
    /**
     * @return {?}
     */
    resetFlag() {
        if (this.flag) {
            this.flag = false;
            this.setSelectedFlag();
        }
    }
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    loadContextMenu(rightClickData) {
        this.setSelectedFlag();
        this.mouseLocation.left = rightClickData.event.clientX;
        this.mouseLocation.top = rightClickData.event.clientY;
        rightClickData.data['isSelected'] = true;
        this.getContextMenu();
        this.posixUp = this.getListPosition(rightClickData.ref);
        rightClickData.event.preventDefault();
        rightClickData.event.stopPropagation();
        this.rightClickNodeData = rightClickData.data;
        this.contextStyle = this.getContextMenuStyle();
        this.nodeRightClick.emit(rightClickData);
    }
    /**
     * @param {?} itemConfig
     * @return {?}
     */
    onContextNodeClick(itemConfig) {
        if (!itemConfig.disabled) {
            const /** @type {?} */ obj = {
                menuData: itemConfig,
                NodeData: this.rightClickNodeData,
            };
            this.resetFlag();
            this.removeListner();
            this.rightClick.emit(obj);
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        const /** @type {?} */ height = 240; // must be same in dropdown.scss
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @return {?}
     */
    getContextMenuStyle() {
        return {
            'cursor': 'default',
            'position': 'fixed',
            'display': this.flag ? 'block' : 'none',
            'left': this.mouseLocation.left + 'px',
            'top': this.mouseLocation.top + 'px',
            'box-shadow': '1px 1px 2px #000000',
            'width': '15%',
        };
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (e) => {
            this.resetFlag();
            if (!this.flag) {
                this.removeListner();
            }
        });
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
    }
}
AmexioTreeViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-treeview', template: `
    <div *ngIf="data == null" style="height: 300px;width: 300px;">
      <div class="spinner"></div>
    </div>

    <div class="treenode" *ngFor="let node of data"  >
      <div #id class="treenode-content" (click)="onClick(node)">
        <div style="white-space:nowrap">
          <div class="tree-node-label" *ngIf="node[childarraykey] && (node[childarraykey].length>0)">
            <em class="fa " [ngClass]="{'fa-angle-down':node.expand,'fa-angle-right':!node.expand}"></em>
          </div> &nbsp;

          <div class="tree-node-label tree-node-label-hover" [ngClass]="{'tree-node-label-selected':node.isSelected ,'tree-node-label-not-selected':node.isSelected=='false'}"
            [attr.draggable]="enabledrag" (dragleave)="dragleave($event)" (drop)="drop({event:$event,data:node})" (dragover)="allowDrop({event:$event,data:node})"
            (dragstart)="onDragStart({event:$event,data:node})" (contextmenu)="loadContextMenu({event:$event,data:node,ref:id})">
            <div class="tree-node-label" *ngIf="enablecheckbox">
              <input type="checkbox" [checked]="'checked'?node.checked:null" (click)="emitCheckedData(node)" />
            </div>
            <div class="tree-node-label" (click)="onNodeClick(node)">
              <div class="tree-node-label" *ngIf="templates == null">
                <div class="tree-node-label" *ngIf="node.icon" [ngClass]="node.icon" aria-hidden="true">
                </div>
                <div class="tree-node-label">
                  {{node[displaykey]}}
                  <ng-container *ngIf="badge && node.badge">
                    <span class="tree-badge">{{node.badge}}</span>
                  </ng-container>
                </div>
              </div>
              <div class="tree-node-label" *ngIf="templates != null">
                <ng-template [ngTemplateOutlet]="templates.treeNodeTemplate" [ngTemplateOutletContext]="{ $implicit: { text: node.text } , icon: node.icon,node : node }">
                </ng-template>
              </div>
            </div>

          </div>
        </div>
      </div>
      <div class="treenode-children" style="display: block;" *ngIf="node.expand && node[childarraykey] && (node[childarraykey].length>0)">
        <amexio-treeview [child-array-key]="childarraykey"  [display-key]="displaykey" [enable-drag]="enabledrag" [enable-drop]="enabledrop" [data]="node[childarraykey]" [dragData]="dragData" [parentRef]="parentRef"
          (onDrag)=onDragStart($event) (onDrop)=drop($event) (nodeClick)="onNodeClick($event)" (dragleave)="($event)" (nodeRightClick)="loadContextMenu($event)"
          [across-tree]="acrosstree" [templates]="templates" [enable-checkbox]="enablecheckbox" [badge]="badge" (onTreeNodeChecked)="this.onTreeNodeCheck($event)">
        </amexio-treeview>

      </div>
    </div>

    <span [ngStyle]="contextStyle">
      <ul *ngIf="flag" class="context-menu-list" [ngClass]="{'dropdown-up' : posixUp}">
        <li (click)="onContextNodeClick(itemConfig)" class="context-menu-list-items" [ngStyle]="{'cursor': itemConfig.disabled ? 'not-allowed':'pointer'}" [ngClass]="{'context-menu-separator':itemConfig.seperator}"
          *ngFor="let itemConfig of contextmenu">
          <em [ngStyle]="{'padding-left': itemConfig.icon ? '5px':'19px'}" [ngClass]="itemConfig.icon"></em>
          <span style="white-space: nowrap;display: inline ; padding-left:5px">{{itemConfig.text}}
          </span>
        </li>
      </ul>
    </span>
  `,
            },] },
];
/** @nocollapse */
AmexioTreeViewComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: CommonDataService },
    { type: ChangeDetectorRef },
    { type: Renderer2 }
];
AmexioTreeViewComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    displaykey: [{ type: Input, args: ['display-key',] }],
    childarraykey: [{ type: Input, args: ['child-array-key',] }],
    nodeClick: [{ type: Output }],
    enablecheckbox: [{ type: Input, args: ['enable-checkbox',] }],
    templates: [{ type: Input }],
    enabledrag: [{ type: Input, args: ['enable-drag',] }],
    enabledrop: [{ type: Input, args: ['enable-drop',] }],
    acrosstree: [{ type: Input, args: ['across-tree',] }],
    badge: [{ type: Input, args: ['badge',] }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    parentRef: [{ type: Input }],
    parentTmp: [{ type: ContentChild, args: ['amexioTreeTemplate',] }],
    onTreeNodeChecked: [{ type: Output }],
    onDrag: [{ type: Output }],
    onDrop: [{ type: Output }],
    dragover: [{ type: Output }],
    dragData: [{ type: Input }],
    nodeRightClick: [{ type: Output }],
    rightClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TreeDataTableComponent {
    /**
     * @param {?} treeDataTableService
     */
    constructor(treeDataTableService) {
        this.treeDataTableService = treeDataTableService;
        /*
           Events
           name : selectedRecord
           datatype : none
           version : none
           default : none
           description : Get selected value Object.
           */
        this.selectedRecord = new EventEmitter();
        this.rowSelect = new EventEmitter();
        this.columns = [];
        this.mask = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.treeDataTableService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.responseData = response;
            }, (error) => {
            }, () => {
                this.setData(this.responseData);
            });
        }
        else if (this.data) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.onResize();
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.createConfig();
    }
    /**
     * @return {?}
     */
    createConfig() {
        const /** @type {?} */ columnRefArray = this.columnRef.toArray();
        for (const /** @type {?} */ cr of columnRefArray) {
            const /** @type {?} */ columnConfig = cr;
            let /** @type {?} */ columnData;
            if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate != null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    headerTemplate: columnConfig.headerTemplate,
                    width: columnConfig.width,
                    bodyTemplate: columnConfig.bodyTemplate,
                };
            }
            else if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    headerTemplate: columnConfig.headerTemplate,
                };
            }
            else if (columnConfig.bodyTemplate != null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    bodyTemplate: columnConfig.bodyTemplate,
                };
            }
            else if (columnConfig.bodyTemplate == null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    width: columnConfig.width,
                    datatype: columnConfig.datatype,
                };
            }
            this.columns.push(columnData);
        }
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (this.data) {
            this.viewRows = this.getResponseData(this.data);
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        if (httpResponse) {
            const /** @type {?} */ treedata = this.getResponseData(httpResponse);
            this.viewRows = treedata;
            this.viewRows.forEach((row, index) => {
                this.viewRows[index].level = 1;
                this.viewRows[index].expanded = false;
            });
            this.mask = false;
        }
        else {
            this.viewRows = [];
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getResponseData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    toogle(row, index) {
        row.expanded = !row.expanded;
        if (row.expanded) {
            this.addRows(row, index);
        }
        else {
            this.removeRows(row);
        }
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    addRows(row, index) {
        if (row.children) {
            for (let /** @type {?} */ i = 0; i < row.children.length; i++) {
                const /** @type {?} */ node = row.children[i];
                if (!row.level) {
                    row.level = 1;
                }
                if (node.children) {
                    node.expanded = false;
                }
                node.level = (row.level + 1);
                this.viewRows.splice(index + (i + 1), 0, node);
            }
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    removeRows(node) {
        if (node.children) {
            for (const /** @type {?} */ nc of node.children) {
                if (this.viewRows) {
                    this.setRemovedRows(nc);
                }
            }
        }
    }
    /**
     * @param {?} nc
     * @return {?}
     */
    setRemovedRows(nc) {
        for (const /** @type {?} */ vr of this.viewRows) {
            if (vr === nc) {
                if (nc.children) {
                    this.removeRows(nc);
                }
                this.viewRows.splice(this.viewRows.indexOf(nc), 1);
            }
        }
    }
    /**
     * @param {?} rowData
     * @param {?} event
     * @return {?}
     */
    setSelectedRow(rowData, event) {
        this.selectedRecord.emit(rowData);
        this.rowSelect.emit(rowData);
    }
    /**
     * @return {?}
     */
    onResize() {
        if (this.height) {
            let /** @type {?} */ h = (window.innerHeight / 100) * this.height;
            if (this.gridHeader && this.gridHeader.nativeElement && this.gridHeader.nativeElement.offsetHeight) {
                h = h - this.gridHeader.nativeElement.offsetHeight;
            }
            if (this.height === 100) {
                h = h - 40;
            }
            this.height = h;
        }
    }
}
TreeDataTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tree-data-table', template: `
    <div (window:resize)="onResize()">
      <div #header class="datatable">
        <div class="datatable-header">
          <ng-container *ngFor="let cols of columns;let i = index">
            <ng-container *ngIf="cols.datatype=='string'">
              <div class="datatable-col" [ngClass]="{'header' : i == 0}">
                <ng-container *ngIf="cols.headerTemplate">
                  <ng-template  [ngTemplateOutlet]="cols.headerTemplate"
                                [ngTemplateOutletContext]="{column:cols ,index: i}"></ng-template>
                </ng-container>
                <ng-container *ngIf="!cols.headerTemplate">
                  {{cols.text}}
                </ng-container>
              </div>
            </ng-container>
            <ng-container *ngIf="cols.datatype=='number'">
              <ng-container *ngIf="cols.headerTemplate">
                <ng-template  [ngTemplateOutlet]="cols.headerTemplate"
                              [ngTemplateOutletContext]="{column:cols ,index: i}"></ng-template>
              </ng-container>
              <ng-container *ngIf="!cols.headerTemplate">
               <span class="float-right">
               <div class="datatable-col" [ngClass]="{'header' : i == 0}"> {{cols.text}}</div>
            </span>
              </ng-container>

            </ng-container>
          </ng-container>
        </div>
      </div>

      <div class="datatable-height" [style.height.px]="height">
        <div class="datatable">
          <div style="height: 300px;" *ngIf="mask">
            <div class="spinner"></div>
          </div>
          <ng-container *ngIf="!mask">
            <div class="datatable-row" (click)="toogle(row,i)" *ngFor="let row of viewRows;let i=index"
            (click)="setSelectedRow(row, $event)">
              <ng-container *ngFor="let cols of columns;let colIndex = index">
                <ng-container *ngIf="cols.datatype=='string' && !cols?.bodyTemplate">
                  <div class="datatable-col" [attr.data-label]="cols.text">
                    <ng-container *ngIf="colIndex == 0">
              <span [ngStyle]="{'padding-left':(20*row.level)+'px'}">
                <ng-container *ngIf="!row.expanded && row.children">
                  <amexio-data-icon key="tree_collapse"></amexio-data-icon>
                </ng-container>
                <ng-container *ngIf="row.expanded && row.children">
                  <amexio-data-icon key="tree_expand"></amexio-data-icon>
                </ng-container>
                 <ng-container *ngIf="row[cols.dataindex]!= null && row[cols.dataindex]!= '' ;else elseBlock">
                      {{row[cols.dataindex]}}
                    </ng-container>
                    <ng-template #elseBlock>
                      &nbsp;
                    </ng-template>
               </span>
                    </ng-container>

                    <ng-container *ngIf="colIndex > 0">
                      <ng-container *ngIf="row[cols.dataindex]!= null && row[cols.dataindex]!= '' ;else elseBlock">
                        {{row[cols.dataindex]}}
                      </ng-container>
                      <ng-template #elseBlock>
                        &nbsp;
                      </ng-template>
                    </ng-container>
                  </div>
                </ng-container>
                <ng-container *ngIf="cols.datatype=='number' && !cols?.bodyTemplate">
                  <div class="datatable-col" [attr.data-label]="cols.text" >
                    <ng-container *ngIf="colIndex == 0">
              <span [ngStyle]="{'padding-left':(20*row.level)+'px'}">
                <ng-container *ngIf="!row.expanded && row.children">
                  <amexio-data-icon key="tree_collapse"></amexio-data-icon>
                </ng-container>
                <ng-container *ngIf="row.expanded && row.children">
                  <amexio-data-icon key="tree_expand"></amexio-data-icon>
                </ng-container>
                 <span class="float-right">
                    <ng-container *ngIf="row[cols.dataindex]!= null;else elseBlock">
                      {{row[cols.dataindex]}}
                    </ng-container>
                    <ng-template #elseBlock>
                      &nbsp;
                    </ng-template>
                 </span>
               </span>
                    </ng-container>

                    <ng-container *ngIf="colIndex > 0">
               <span class="float-right">
               <ng-container *ngIf="row[cols.dataindex]!= null;else elseBlock">
                      {{row[cols.dataindex]}}
               </ng-container>
                 <ng-template #elseBlock>
                      &nbsp;
                 </ng-template>
               </span>
                    </ng-container>
                  </div>


                </ng-container>

                <ng-container *ngIf="cols.bodyTemplate">
                  <div class="datatable-col" [attr.data-label]="cols.text">
                    <ng-template  [ngTemplateOutlet]="cols.bodyTemplate"
                                  [ngTemplateOutletContext]="{ $implicit: { text : row[cols.dataindex] }, row: row }"></ng-template>
                  </div>
                </ng-container>



              </ng-container>


            </div>
          </ng-container>

        </div>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
TreeDataTableComponent.ctorParameters = () => [
    { type: CommonDataService }
];
TreeDataTableComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    selectedRecord: [{ type: Output }],
    height: [{ type: Input }],
    gridHeader: [{ type: ViewChild, args: ['header', { read: ElementRef },] }],
    rowSelect: [{ type: Output }],
    columnRef: [{ type: ContentChildren, args: [AmexioGridColumnComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 Component Name : Amexio Accordion
 Component Selector : <amexio-accordion-tab>
 Component Description : Amexio Accordion provides an easy way to organize big forms by grouping the fields in accordion tabs.
*/
class AmexioAccordionTabComponent {
    constructor() {
        /*
        Events
        name : emittedEvent
        datatype :none
        version : none
        default : none
        description : Fires the on accordion pane click event.
        */
        this.emittedEvent = new EventEmitter();
    }
    /**
     * @return {?}
     */
    emitEvent() {
        if (!this.disabled) {
            this.active = !this.active;
            this.emittedEvent.emit(this);
        }
    }
}
AmexioAccordionTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-accordion-tab',
                template: `
    <button (click)="emitEvent()" class="{{isTransparent ? 'accordion-transparent' : 'accordion'}} {{active ? 'active-accordion' : ''}} {{disabled ? 'accordion-disable' : ''}}">
      <div style="float: left;" *ngIf="leftIcon">
        <em class="fa {{leftIcon}}"></em>
      </div>
      <ng-container>
      {{header}}
        <div style="float: right">
            <ng-content select="amexio-accordion-header">&nbsp;</ng-content> &nbsp;  
          <em *ngIf="!angleIcon" class="fa" [ngClass]="{'fa-plus' : !active,'fa-minus' : active}" aria-hidden="true"></em>
          <em *ngIf="angleIcon" class="fa" [ngClass]="{'fa-angle-down' : !active,'fa-angle-up' : active}" aria-hidden="true"></em>
        </div>
      </ng-container>

    </button>
    <div *ngIf="active" class="panel">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioAccordionTabComponent.ctorParameters = () => [];
AmexioAccordionTabComponent.propDecorators = {
    header: [{ type: Input }],
    active: [{ type: Input }],
    emittedEvent: [{ type: Output }],
    leftIcon: [{ type: Input, args: ['left-icon',] }],
    angleIcon: [{ type: Input, args: ['angle-icon',] }],
    disabled: [{ type: Input, args: ['disabled',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioAccordionComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.accordionCollections = this.queryTabs.toArray();
        this.accordionCollections.forEach((node) => node.emittedEvent.subscribe((eventdata) => this.activateAccordionPane(eventdata)));
        this.accordionCollections.forEach((node) => {
            if (this.expandAll) {
                node.active = true;
            }
            else if (node.active) {
                node.active = true;
            }
            else {
                node.active = false;
            }
            if (this.isTransparent) {
                node.isTransparent = true;
            }
            if (this.angleIcon) {
                node.angleIcon = true;
            }
        });
    }
    /**
     * @param {?} node
     * @return {?}
     */
    activateAccordionPane(node) {
        this.accordionCollections.forEach((tab) => {
            if (tab === node) {
                tab.active = node.active;
            }
            else {
                tab.active = false;
            }
        });
    }
}
AmexioAccordionComponent.decorators = [
    { type: Component, args: [{ selector: 'amexio-accordion', template: `

  <ng-content></ng-content>
` },] },
];
/** @nocollapse */
AmexioAccordionComponent.ctorParameters = () => [];
AmexioAccordionComponent.propDecorators = {
    expandAll: [{ type: Input, args: ['expand-all',] }],
    isTransparent: [{ type: Input, args: ['transparent',] }],
    angleIcon: [{ type: Input, args: ['angle-icon',] }],
    queryTabs: [{ type: ContentChildren, args: [AmexioAccordionTabComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioAccordionHeaderComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioAccordionHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-accordion-header', template: `
    <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioAccordionHeaderComponent.ctorParameters = () => [];
AmexioAccordionHeaderComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const LayoutConstant = {
    'start': 'flex-start',
    'end': 'flex-end',
    'center': 'center',
    'space-between': 'space-between',
    'space-around': 'space-around',
    'space-evenly': 'space-evenly',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioLayoutComponent {
    constructor() {
        this.orientation = 'horizontal';
        this.border = true;
        this.fit = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setLayoutDefination();
    }
    /**
     * @return {?}
     */
    setLayoutDefination() {
        this.setorientation();
        this.setAlignment();
        this.setBorder();
        this.setFit();
    }
    /**
     * @return {?}
     */
    setorientation() {
        if (this.orientation && this.orientation.toLowerCase() === 'vertical') {
            this.orientationDirection = 'column';
        }
        else {
            this.orientationDirection = 'row';
        }
    }
    /**
     * @return {?}
     */
    setAlignment() {
        if (this.alignment && LayoutConstant[this.alignment.toLowerCase()]) {
            this.justifyContent = LayoutConstant[this.alignment.toLowerCase()];
        }
        else {
            this.justifyContent = 'start';
        }
    }
    /**
     * @return {?}
     */
    setBorder() {
        if (this.border) {
            this.borderstyle = '1px solid #ced4da';
            this.borderboxstyle = '0 2px 2px 0 rgba(0,0,0,.14)';
        }
    }
    /**
     * @return {?}
     */
    setFit() {
        if (this.fit) {
            this.height = '100%';
        }
    }
}
AmexioLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-layout-columns',
                template: `
      <ng-content></ng-content>
    `,
                styles: [`
    :host {
        display: flex;
    }
  `],
            },] },
];
AmexioLayoutComponent.propDecorators = {
    orientation: [{ type: Input, args: ['orientation',] }],
    alignment: [{ type: Input, args: ['alignment',] }],
    border: [{ type: Input, args: ['border',] }],
    fit: [{ type: Input, args: ['fit',] }],
    orientationDirection: [{ type: HostBinding, args: ['style.flex-direction',] }],
    justifyContent: [{ type: HostBinding, args: ['style.justify-content',] }],
    borderstyle: [{ type: HostBinding, args: ['style.border',] }],
    borderboxstyle: [{ type: HostBinding, args: ['style.box-shadow',] }],
    height: [{ type: HostBinding, args: ['style.height',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioLayoutItemComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.fit) {
            this.flexgrow = 1;
        }
        if (this.padding) {
            this.lipadding = this.padding;
        }
    }
}
AmexioLayoutItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-layout-item',
                template: `
        <ng-content></ng-content>
    `,
            },] },
];
AmexioLayoutItemComponent.propDecorators = {
    fit: [{ type: Input, args: ['fit',] }],
    padding: [{ type: Input, args: ['padding',] }],
    flexgrow: [{ type: HostBinding, args: ['style.flex-grow',] }],
    lipadding: [{ type: HostBinding, args: ['style.padding',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioBorderLayoutItemComponent {
    constructor() {
        this.positionClass = 'borderlayout-';
        this.role = this.positionClass;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    getClassType() {
        let /** @type {?} */ pos = '';
        if (this.position.toLowerCase() === 'north') {
            pos = 'N';
        }
        else if (this.position.toLowerCase() === 'east') {
            pos = 'E';
        }
        else if (this.position.toLowerCase() === 'center') {
            pos = 'C';
        }
        else if (this.position.toLowerCase() === 'west') {
            pos = 'W';
        }
        else if (this.position.toLowerCase() === 'south') {
            pos = 'S';
        }
        this.positionClass = this.positionClass + pos;
        this.role = this.positionClass;
        return pos;
    }
}
AmexioBorderLayoutItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-borderlayout-item',
                template: `
    <aside style="height:100%;"><ng-content></ng-content></aside>
  `,
            },] },
];
/** @nocollapse */
AmexioBorderLayoutItemComponent.ctorParameters = () => [];
AmexioBorderLayoutItemComponent.propDecorators = {
    position: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 1/4/18.
 */
class AmexioBorderLayoutComponent {
    constructor() {
        this.borderclass = 'borderlayout-container';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.layoutitems = this.layout.toArray();
        this.layoutitems.forEach((item) => {
            this.borderclass = this.borderclass + '-' + item.getClassType();
        });
    }
}
AmexioBorderLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-borderlayout',
                template: `

    <section [ngClass]="borderclass">
      <ng-content></ng-content>
    </section>
  `,
            },] },
];
/** @nocollapse */
AmexioBorderLayoutComponent.ctorParameters = () => [];
AmexioBorderLayoutComponent.propDecorators = {
    layout: [{ type: ContentChildren, args: [AmexioBorderLayoutItemComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by anaghak07 on 6/3/18.
 */
class AmexioBoxComponent {
    constructor() {
        /*
        Properties
        name : padding
        datatype : boolean
        version : 4.1 onwards
        default : false
        description : Padding to all sides
        */
        this.padding = false;
        /*
        Properties
        name : border-dotted
        datatype : boolean
        version : 4.1.8 onwards
        default : false
        description : Dotted border
        */
        this.borderDotted = false;
        /*
        Properties
        name : closable
        datatype : boolean
        version : 4.1.8 onwards
        default : false
        description : closable box
        */
        this.closable = false;
        this.close = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.borderColor == null) {
            this.borderColor = 'box-default';
        }
        if (this.borderColor != null && this.bgColor == null) {
            this.bgColor = this.borderColor;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    closeBox(event) {
        this.close = false;
        this.closable = false;
    }
}
AmexioBoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-box',
                template: `
 <div class="box-content" *ngIf="close"
 [style.height] = "height ? height:'none'"
 [style.width] = "width ? width:'none'"
 [style.align] = "align ? align:'none'"
 [ngClass]="{
 'box-default': borderColor=='default' || borderColor ==null,
 'border-topbar': border=='top',
 'border-bottombar': border =='bottom',
 'border-rightbar': border =='right',
 'border-leftbar': border =='left',
 'border-all' : border =='all',
 'border-top-bottom' : border =='top-bottom' || border =='bottom-top',
 'border-right-left' : border =='right-left' || border =='left-right',

 'bg-brown': bgColor=='brown',
 'bg-red': bgColor=='red',
 'bg-green': bgColor=='green',
 'bg-yellow': bgColor=='yellow',
 'bg-blue': bgColor=='blue',
 'bg-purple': bgColor=='purple',
 'bg-theme-color' : bgColor =='theme-color',

 'border-theme-color' : borderColor =='theme-color',
 'border-red' : borderColor =='red',
 'border-yellow' : borderColor =='yellow',
 'border-green' : borderColor =='green',
 'border-blue' : borderColor =='blue',
 'border-brown' : borderColor =='brown',
 'border-purple' : borderColor =='purple',
 'padding' : padding,
 'border-dotted' : borderDotted
  }" >
  <span *ngIf="closable" class="box-close">
  <amexio-layout-icon key="tab_close" (onClick)="closeBox($event)"></amexio-layout-icon>
  </span>
   <ng-content></ng-content>

 </div>
 `,
            },] },
];
/** @nocollapse */
AmexioBoxComponent.ctorParameters = () => [];
AmexioBoxComponent.propDecorators = {
    border: [{ type: Input, args: ['border',] }],
    borderColor: [{ type: Input, args: ['border-color',] }],
    bgColor: [{ type: Input, args: ['background-color',] }],
    padding: [{ type: Input, args: ['padding',] }],
    height: [{ type: Input, args: ['box-height',] }],
    width: [{ type: Input, args: ['box-width',] }],
    borderDotted: [{ type: Input, args: ['border-dotted',] }],
    align: [{ type: Input, args: ['align',] }],
    closable: [{ type: Input, args: ['closable',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioHeaderComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-header', template: `
  <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioHeaderComponent.ctorParameters = () => [];
AmexioHeaderComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 18/12/17.
 */
class AmexioFooterComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-action', template: '<ng-content></ng-content>',
            },] },
];
/** @nocollapse */
AmexioFooterComponent.ctorParameters = () => [];
AmexioFooterComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioBodyComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-body', template: '<ng-content></ng-content>',
            },] },
];
/** @nocollapse */
AmexioBodyComponent.ctorParameters = () => [];
AmexioBodyComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/18/17.
 */
/*
Component Name : Amexio card
 Component Selector : <amexio-card>
Component Description : Amexio Card which renders card based on title, body and actions user has configured
*/
class AmexioCardComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        /*
        Properties
        name : show
        datatype :  boolean
        version : 4.0 onwards
        default : true
        description : User can bind variable to this and hide/unhide card based on requirement..
        */
        this.show = true;
        this.nodeRightClick = new EventEmitter();
        this.rightClick = new EventEmitter();
        this.mouseLocation = { left: 0, top: 0 };
        this.headeralign = 'left';
        this.footeralign = 'right';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout(() => {
            this.onResize();
        }, 500);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // FOR HEADER PADING
        this.headerComponentList = this.amexioHeader.toArray();
        this.headerComponentList.forEach((item, currentIndex) => {
            if (item.padding) {
                this.headerPadding = item.padding;
            }
        });
        // FOR BODY PADDING
        this.bodyComponentList = this.amexioBody.toArray();
        this.bodyComponentList.forEach((item, currentIndex) => {
            if (item.padding) {
                this.bodyPadding = item.padding;
            }
        });
        // FOR FOOTER PADDING
        this.footerComponentList = this.amexioFooter.toArray();
        this.footerComponentList.forEach((item, currentIndex) => {
            if (item.padding) {
                this.footerPadding = item.padding;
            }
        });
    }
    /**
     * @return {?}
     */
    onResize() {
        if (this.bodyheight) {
            let /** @type {?} */ h = (window.innerHeight / 100) * this.bodyheight;
            if (this.cardHeader && this.cardHeader.nativeElement && this.cardHeader.nativeElement.offsetHeight) {
                h = h - this.cardHeader.nativeElement.offsetHeight;
            }
            if (this.cardFooter && this.cardFooter.nativeElement && this.cardFooter.nativeElement.offsetHeight) {
                h = h - this.cardFooter.nativeElement.offsetHeight;
            }
            if (this.bodyheight === 100) {
                h = h - 40;
            }
            this.minHeight = h;
            this.height = h;
        }
    }
    /**
     * @return {?}
     */
    getContextMenu() {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        const /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    loadContextMenu(rightClickData) {
        this.mouseLocation.left = rightClickData.event.clientX;
        this.mouseLocation.top = rightClickData.event.clientY;
        this.getContextMenu();
        this.posixUp = this.getListPosition(rightClickData.ref);
        rightClickData.event.preventDefault();
        rightClickData.event.stopPropagation();
        this.rightClickNodeData = rightClickData.data;
        this.contextStyle = this.getContextMenuStyle();
        this.nodeRightClick.emit(rightClickData);
    }
    /**
     * @param {?} itemConfig
     * @return {?}
     */
    onContextNodeClick(itemConfig) {
        if (!itemConfig.disabled) {
            const /** @type {?} */ obj = {
                menuData: itemConfig,
                NodeData: this.rightClickNodeData,
            };
            this.flag = false;
            this.removeListner();
            this.rightClick.emit(obj);
        }
    }
    /**
     * @return {?}
     */
    getContextMenuStyle() {
        return {
            'cursor': 'default',
            'position': 'fixed',
            'display': this.flag ? 'block' : 'none',
            'left': this.mouseLocation.left + 'px',
            'top': this.mouseLocation.top + 'px',
            'box-shadow': '1px 1px 2px #000000',
            'width': '15%',
        };
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (e) => {
            this.flag = false;
            if (!this.flag) {
                this.removeListner();
            }
        });
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
    }
}
AmexioCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-card',
                template: `
  <div  #id  class="card-container" *ngIf="show"  (window:resize)="onResize()"
  (contextmenu)="loadContextMenu({event:$event,ref:id})">
    <header #cardHeader  [style.padding]="headerPadding"  class="card-header" *ngIf="header"

            [ngClass]="{'flex-start':(headeralign=='left'),'flex-end':(headeralign=='right'),'flex-center':(headeralign=='center')}">
      <ng-content select="amexio-header"></ng-content>
    </header>
<div class="card-body cardbody" [style.padding]="bodyPadding"
[ngStyle]="{'height.px' : height,'overflow-y' : height!= null ? 'auto' : '','min-height.px' : minHeight}">
      <ng-content select="amexio-body"></ng-content>
    </div>
    <footer  #cardFooter [style.padding]="footerPadding"  class="card-footer" *ngIf="footer"
            [ngClass]="{'flex-start':(footeralign=='left'),'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}">
      <ng-content select="amexio-action"></ng-content>
    </footer>
  </div>

  <span *ngIf="flag" [ngStyle]="contextStyle">
    <ul class="context-menu-list" [ngClass]="{'dropdown-up' : posixUp}">
      <li (click)="onContextNodeClick(itemConfig)" class="context-menu-list-items"
      [ngStyle]="{'cursor': itemConfig.disabled ? 'not-allowed':'pointer'}"
        [ngClass]="{'context-menu-separator':itemConfig.seperator}" *ngFor="let itemConfig of contextmenu">
        <em [ngStyle]="{'padding-left': itemConfig.icon ? '5px':'19px'}" [ngClass]="itemConfig.icon"></em>
        <span style="white-space: nowrap;display: inline ; padding-left:5px">{{itemConfig.text}}
        </span>
      </li>
    </ul>
  </span>
  `,
            },] },
];
/** @nocollapse */
AmexioCardComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexioCardComponent.propDecorators = {
    headeralign: [{ type: Input, args: ['header-align',] }],
    header: [{ type: Input }],
    footer: [{ type: Input }],
    footeralign: [{ type: Input, args: ['footer-align',] }],
    show: [{ type: Input }],
    height: [{ type: Input }],
    minHeight: [{ type: Input, args: ['min-height',] }],
    bodyheight: [{ type: Input, args: ['body-height',] }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    parentRef: [{ type: Input }],
    nodeRightClick: [{ type: Output }],
    rightClick: [{ type: Output }],
    cardHeader: [{ type: ViewChild, args: ['cardHeader', { read: ElementRef },] }],
    cardFooter: [{ type: ViewChild, args: ['cardFooter', { read: ElementRef },] }],
    amexioHeader: [{ type: ContentChildren, args: [AmexioHeaderComponent,] }],
    amexioBody: [{ type: ContentChildren, args: [AmexioBodyComponent,] }],
    amexioFooter: [{ type: ContentChildren, args: [AmexioFooterComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 8/1/18.
 */
class AmexioColumnComponent {
    constructor() {
        this.role = this.colclass;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        this.size_ = value;
        this.colclass = 'flex-col flex-col-' + value;
        this.role = this.colclass;
    }
    /**
     * @return {?}
     */
    get size() {
        return this.size_;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-column', template: `

    <div [ngStyle]="{'height':fit ? '100%':''}">
        <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioColumnComponent.ctorParameters = () => [];
AmexioColumnComponent.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.class',] }],
    fit: [{ type: Input, args: ['fit',] }],
    size: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioGridLayoutService {
    constructor() {
        this.layoutData = [];
    }
    /**
     * @param {?} dataLayout
     * @return {?}
     */
    createLayout(dataLayout) {
        let /** @type {?} */ findStatus = false;
        this.count = dataLayout.count;
        const /** @type {?} */ data = dataLayout.getLayout();
        if (this.layoutData.length <= 0) {
            this.layoutData.push(data);
        }
        else {
            this.layoutData.forEach((obj) => {
                if (obj.name === data.name) {
                    obj[data.layoutType] = data[data.layoutType];
                    findStatus = true;
                }
            });
            if (!findStatus) {
                this.layoutData.push(data);
            }
        }
    }
    /**
     * @param {?} layoutName
     * @return {?}
     */
    getLayoutData(layoutName) {
        return this.layoutData.find((obj) => obj.name === layoutName);
    }
}
AmexioGridLayoutService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
AmexioGridLayoutService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioGridItemComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this.hostname = this._name;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.insertStyleSheetRule('.' + this.name + '{ grid-area: ' + this.name + ' } ');
    }
    /**
     * @param {?} ruleText
     * @return {?}
     */
    insertStyleSheetRule(ruleText) {
        const /** @type {?} */ sheets = document.styleSheets;
        if (sheets.length === 0) {
            const /** @type {?} */ style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        const /** @type {?} */ sheet = sheets[sheets.length - 1];
        sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
    }
}
AmexioGridItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-grid-item',
                template: `
          <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioGridItemComponent.ctorParameters = () => [];
AmexioGridItemComponent.propDecorators = {
    hostname: [{ type: HostBinding, args: ['class',] }],
    name: [{ type: Input, args: ['name',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioGridComponent {
    /**
     * @param {?} _gridlayoutService
     */
    constructor(_gridlayoutService) {
        this._gridlayoutService = _gridlayoutService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.colCount = this._gridlayoutService.count;
        this.containerClass = '';
        this.className = '';
        this.cssGenreration(this._gridlayoutService.getLayoutData(this.layout));
    }
    /**
     * @return {?}
     */
    getCssAttribute() {
        return 'display: grid;' + ' grid-gap: 5px;' + 'grid-template-columns: repeat(' + this.colCount + ', 1fr);';
    }
    /**
     * @param {?} ruleText
     * @return {?}
     */
    insertStyleSheetRuleParent(ruleText) {
        const /** @type {?} */ sheets = document.styleSheets;
        if (sheets.length === 0) {
            const /** @type {?} */ style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        const /** @type {?} */ sheet = sheets[sheets.length - 1];
        sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.itemCollection = this.queryItem.toArray();
    }
    /**
     * @param {?} deviceName
     * @return {?}
     */
    dataCreation(deviceName) {
        this.containerClass = '';
        deviceName.forEach((ele) => {
            this.containerClass = this.containerClass + '"' + ele.join(' ') + '"';
        });
        return this.containerClass;
    }
    /**
     * @param {?} layoutData
     * @return {?}
     */
    cssGenreration(layoutData) {
        this.className = this.className + '' + layoutData.name;
        this.cssGenerationCommonMethod(layoutData, '(max-width: 767px)', 'mobile');
        this.cssGenerationCommonMethod(layoutData, '(min-width: 1025px)', 'desktop');
        this.cssGenerationCommonMethod(layoutData, '(min-width: 768px) and (max-width: 1024px)', 'tab');
    }
    /**
     * @param {?} layoutData
     * @param {?} screenWidth
     * @param {?} deviceType
     * @return {?}
     */
    cssGenerationCommonMethod(layoutData, screenWidth, deviceType) {
        this.insertStyleSheetRuleParent('@' + 'media' + screenWidth + '{' + '.' + layoutData.name +
            '{' + this.getCssAttribute() + ' grid-template-areas: ' +
            this.dataCreation(layoutData[deviceType]) + '}' + '}');
    }
}
AmexioGridComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-layout-grid',
                template: `
    <div [ngClass]="className" >
          <ng-content select="amexio-grid-item"></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioGridComponent.ctorParameters = () => [
    { type: AmexioGridLayoutService }
];
AmexioGridComponent.propDecorators = {
    queryItem: [{ type: ContentChildren, args: [AmexioGridItemComponent,] }],
    layout: [{ type: Input, args: ['layout',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioIconLayoutComponent {
    /**
     * @param {?} iconLoaderService
     */
    constructor(iconLoaderService) {
        this.iconLoaderService = iconLoaderService;
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.iconClass = this.getIconClass();
    }
    /**
     * @return {?}
     */
    getIconClass() {
        if (this.iconLoaderService.iconMappings != null) {
            const /** @type {?} */ iconObject = this.iconLoaderService.iconMappings.find((obj) => obj.component === this.key);
            if (iconObject != null) {
                return iconObject[this.iconLoaderService.iconToUse.toString()];
            }
            else {
                return '';
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['key']) {
            this.key = changes["key"].currentValue;
            this.iconClass = this.getIconClass();
        }
    }
}
AmexioIconLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-layout-icon', template: `
    <ng-container *ngIf="iconLoaderService.iconToUse == 'fa'">

      <ng-container *ngIf="customclass != null">
        <i class="{{customclass}}" aria-hidden="true" (click)="onClick.emit($event)" style="cursor: pointer;"></i>
      </ng-container>
      <ng-container *ngIf="customclass == null">
        <i class="{{iconClass}}" aria-hidden="true" (click)="onClick.emit($event)" style="cursor: pointer;"></i>
      </ng-container>
    </ng-container>

    <ng-container *ngIf="iconLoaderService.iconToUse == 'mat'">

      <ng-container *ngIf="customclass != null">
        <i class="material-icons" (click)="onClick.emit($event)" style="cursor: pointer;">{{customclass}}</i>
      </ng-container>

      <ng-container *ngIf="customclass == null">
        <i class="material-icons" (click)="onClick.emit($event)" style="cursor: pointer;">{{iconClass}}</i>
      </ng-container>
    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioIconLayoutComponent.ctorParameters = () => [
    { type: IconLoaderService }
];
AmexioIconLayoutComponent.propDecorators = {
    key: [{ type: Input }],
    customclass: [{ type: Input }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 8/1/18.
 */
class AmexioRowComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
    }
}
AmexioRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-row', template: `
    <div class="flex-row">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioRowComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DeviceQueryService {
    /**
     * @param {?} platformId
     */
    constructor(platformId) {
        this.platformId = platformId;
        this.rules = {
            print: 'print',
            screen: 'screen',
            phone: '(max-width: 767px)',
            tablet: '(min-width: 768px) and (max-width: 1024px)',
            desktop: '(min-width: 1025px)',
            portrait: '(orientation: portrait)',
            landscape: '(orientation: landscape)',
            retina: '(-webkit-min-device-pixel-ratio: 2) and (min-resolution: 192dpi)',
        };
        this.Check = function (mq) {
            if (isPlatformBrowser(this.platformId)) {
                if (!mq) {
                    return;
                }
                return window.matchMedia(mq).matches;
            }
            else {
                return;
            }
        };
        this.IsTablet = function () {
            if (isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.tablet).matches;
            }
            else {
                return null;
            }
        };
        this.IsDesktop = function () {
            if (isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.desktop).matches;
            }
            else {
                return null;
            }
        };
        this.IsPortrait = function () {
            if (isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.portrait).matches;
            }
            else {
                return null;
            }
        };
        this.IsLandscape = function () {
            if (isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.landscape).matches;
            }
            else {
                return null;
            }
        };
        this.IsRetina = function () {
            if (isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.retina).matches;
            }
            else {
                return null;
            }
        };
        this.browserWindow = () => {
            return window;
        };
    }
    /**
     * *******************************************
     * METHODS FOR CHECKING TYPE
     * ********************************************
     * @return {?}
     */
    IsPhone() {
        if (isPlatformBrowser(this.platformId)) {
            return window.matchMedia(this.rules.phone).matches;
        }
        else {
            return null;
        }
    }
    /**
     * *******************************************
     * EVENT LISTENERS BY TYPE
     * ********************************************
     * @param {?} callBack
     * @return {?}
     */
    OnPhone(callBack) {
        if (typeof callBack === 'function' && isPlatformBrowser(this.platformId)) {
            const /** @type {?} */ mql = window.matchMedia(this.rules.phone);
            this.mqlMethod(callBack, mql);
        }
    }
    /**
     * @param {?} callBack
     * @return {?}
     */
    OnTablet(callBack) {
        if (typeof callBack === 'function' && isPlatformBrowser(this.platformId)) {
            const /** @type {?} */ mql = window.matchMedia(this.rules.tablet);
            this.mqlMethod(callBack, mql);
        }
    }
    /**
     * @param {?} callBack
     * @return {?}
     */
    OnDesktop(callBack) {
        if (typeof callBack === 'function' && isPlatformBrowser(this.platformId)) {
            const /** @type {?} */ mql = window.matchMedia(this.rules.desktop);
            this.mqlMethod(callBack, mql);
        }
    }
    /**
     * @param {?} callBack
     * @return {?}
     */
    OnPortrait(callBack) {
        if (typeof callBack === 'function' && isPlatformBrowser(this.platformId)) {
            const /** @type {?} */ mql = window.matchMedia(this.rules.portrait);
            this.mqlMethod(callBack, mql);
        }
    }
    /**
     * @param {?} callBack
     * @return {?}
     */
    OnLandscape(callBack) {
        if (typeof callBack === 'function' && isPlatformBrowser(this.platformId)) {
            const /** @type {?} */ mql = window.matchMedia(this.rules.landscape);
            this.mqlMethod(callBack, mql);
        }
    }
    /**
     * @param {?} callBack
     * @param {?} mql
     * @return {?}
     */
    mqlMethod(callBack, mql) {
        mql.addListener((mql1) => {
            if (mql1.matches) {
                callBack(mql);
            }
        });
    }
}
DeviceQueryService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
DeviceQueryService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var isFunction_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

});

unwrapExports(isFunction_1);

var config$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _enable_super_gross_mode_that_will_cause_bad_things = false;
exports.config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = new Error();
            console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

});

unwrapExports(config$1);

var hostReportError_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function hostReportError(err) {
    setTimeout(function () { throw err; });
}
exports.hostReportError = hostReportError;

});

unwrapExports(hostReportError_1);

var Observer = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config$1.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError_1.hostReportError(err);
        }
    },
    complete: function () { }
};

});

unwrapExports(Observer);

var isArray$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

});

unwrapExports(isArray$1);

var isObject_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;

});

unwrapExports(isObject_1);

var errorObject$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorObject = { e: {} };

});

unwrapExports(errorObject$1);

var tryCatch_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject$1.errorObject.e = e;
        return errorObject$1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;

});

unwrapExports(tryCatch_1);

var UnsubscriptionError$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function UnsubscriptionErrorImpl(errors) {
    Error.call(this);
    this.message = errors ?
        errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
    return this;
}
UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
exports.UnsubscriptionError = UnsubscriptionErrorImpl;

});

unwrapExports(UnsubscriptionError$1);

var Subscription_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });






var Subscription = (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        while (_parent) {
            _parent.remove(this);
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject$1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject$1.errorObject.e instanceof UnsubscriptionError$1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject$1.errorObject.e.errors) : [errorObject$1.errorObject.e]);
            }
        }
        if (isArray$1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject$1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject$1.errorObject.e;
                        if (err instanceof UnsubscriptionError$1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError$1.UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function') {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            this._parent = parent;
        }
        else if (!_parents) {
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError$1.UnsubscriptionError) ? err.errors : err); }, []);
}

});

unwrapExports(Subscription_1);

var rxSubscriber$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rxSubscriber = typeof Symbol === 'function'
    ? Symbol('rxSubscriber')
    : '@@rxSubscriber_' + Math.random();
exports.$$rxSubscriber = exports.rxSubscriber;

});

unwrapExports(rxSubscriber$1);

var Subscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        _this._parentSubscription = null;
        switch (arguments.length) {
            case 0:
                _this.destination = Observer.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = Observer.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber$1.rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        this._parentSubscription = null;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config$1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config$1.config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError_1.hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config$1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config$1.config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError_1.hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
exports.SafeSubscriber = SafeSubscriber;

});

unwrapExports(Subscriber_1);

var canReportError_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber_1.Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
exports.canReportError = canReportError;

});

unwrapExports(canReportError_1);

var toSubscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber$1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber$1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

});

unwrapExports(toSubscriber_1);

var observable$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

});

unwrapExports(observable$1);

var noop_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function noop() { }
exports.noop = noop;

});

unwrapExports(noop_1);

var pipe_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;

});

unwrapExports(pipe_1);

var Observable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });





var Observable = (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source || (config$1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config$1.config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError_1.canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable$1.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config$1.config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

});

unwrapExports(Observable_1);

var ObjectUnsubscribedError$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function ObjectUnsubscribedErrorImpl() {
    Error.call(this);
    this.message = 'object unsubscribed';
    this.name = 'ObjectUnsubscribedError';
    return this;
}
ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
exports.ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

});

unwrapExports(ObjectUnsubscribedError$1);

var SubjectSubscription_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

});

unwrapExports(SubjectSubscription_1);

var Subject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber$1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

});

unwrapExports(Subject_1);

var refCount_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
exports.refCount = refCount;
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

});

unwrapExports(refCount_1);

var ConnectableObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });





var ConnectableObservable = (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
var connectableProto = ConnectableObservable.prototype;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

});

unwrapExports(ConnectableObservable_1);

var groupBy_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });




function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
exports.groupBy = groupBy;
var GroupByOperator = (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
var GroupDurationSubscriber = (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
var GroupedObservable = (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
exports.GroupedObservable = GroupedObservable;
var InnerRefCountSubscription = (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));

});

unwrapExports(groupBy_1);

var BehaviorSubject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;

});

unwrapExports(BehaviorSubject_1);

var Action_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;

});

unwrapExports(Action_1);

var AsyncAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;

});

unwrapExports(AsyncAction_1);

var QueueAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;

});

unwrapExports(QueueAction_1);

var Scheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;

});

unwrapExports(Scheduler_1);

var AsyncScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler_1.Scheduler.now; }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;

});

unwrapExports(AsyncScheduler_1);

var QueueScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;

});

unwrapExports(QueueScheduler_1);

var queue$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);

});

unwrapExports(queue$1);

var empty_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
}
exports.empty = empty;
function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
exports.emptyScheduled = emptyScheduled;

});

unwrapExports(empty_1);

var isScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;

});

unwrapExports(isScheduler_1);

var subscribeToArray$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeToArray = function (array) { return function (subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
    }
    if (!subscriber.closed) {
        subscriber.complete();
    }
}; };

});

unwrapExports(subscribeToArray$1);

var fromArray_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToArray$1.subscribeToArray(input));
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            var i = 0;
            sub.add(scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                    return;
                }
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    sub.add(this.schedule());
                }
            }));
            return sub;
        });
    }
}
exports.fromArray = fromArray;

});

unwrapExports(fromArray_1);

var scalar_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function scalar(value) {
    var result = new Observable_1.Observable(function (subscriber) {
        subscriber.next(value);
        subscriber.complete();
    });
    result._isScalar = true;
    result.value = value;
    return result;
}
exports.scalar = scalar;

});

unwrapExports(scalar_1);

var of_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        args.pop();
    }
    else {
        scheduler = undefined;
    }
    switch (args.length) {
        case 0:
            return empty_1.empty(scheduler);
        case 1:
            return scheduler ? fromArray_1.fromArray(args, scheduler) : scalar_1.scalar(args[0]);
        default:
            return fromArray_1.fromArray(args, scheduler);
    }
}
exports.of = of;

});

unwrapExports(of_1);

var throwError_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
exports.throwError = throwError;
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

});

unwrapExports(throwError_1);

var Notification_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of_1.of(this.value);
            case 'E':
                return throwError_1.throwError(this.error);
            case 'C':
                return empty_1.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;

});

unwrapExports(Notification_1);

var observeOn_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;

});

unwrapExports(observeOn_1);

var ReplaySubject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue$1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

});

unwrapExports(ReplaySubject_1);

var AsyncSubject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


var AsyncSubject = (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));
exports.AsyncSubject = AsyncSubject;

});

unwrapExports(AsyncSubject_1);

var Immediate$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nextHandle = 1;
var tasksByHandle = {};
function runIfPresent(handle) {
    var cb = tasksByHandle[handle];
    if (cb) {
        cb();
    }
}
exports.Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(function () { return runIfPresent(handle); });
        return handle;
    },
    clearImmediate: function (handle) {
        delete tasksByHandle[handle];
    },
};

});

unwrapExports(Immediate$1);

var AsapAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


var AsapAction = (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate$1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate$1.Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction_1.AsyncAction));
exports.AsapAction = AsapAction;

});

unwrapExports(AsapAction_1);

var AsapScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AsapScheduler = (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AsapScheduler = AsapScheduler;

});

unwrapExports(AsapScheduler_1);

var asap$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);

});

unwrapExports(asap$1);

var async$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);

});

unwrapExports(async$1);

var AnimationFrameAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AnimationFrameAction = (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction_1.AsyncAction));
exports.AnimationFrameAction = AnimationFrameAction;

});

unwrapExports(AnimationFrameAction_1);

var AnimationFrameScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AnimationFrameScheduler = (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AnimationFrameScheduler = AnimationFrameScheduler;

});

unwrapExports(AnimationFrameScheduler_1);

var animationFrame$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);

});

unwrapExports(animationFrame$1);

var VirtualTimeScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


var VirtualTimeScheduler = (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.VirtualTimeScheduler = VirtualTimeScheduler;
var VirtualAction = (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) { index = scheduler.index += 1; }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction_1.AsyncAction));
exports.VirtualAction = VirtualAction;

});

unwrapExports(VirtualTimeScheduler_1);

var identity_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function identity(x) {
    return x;
}
exports.identity = identity;

});

unwrapExports(identity_1);

var isObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function isObservable(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}
exports.isObservable = isObservable;

});

unwrapExports(isObservable_1);

var ArgumentOutOfRangeError$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function ArgumentOutOfRangeErrorImpl() {
    Error.call(this);
    this.message = 'argument out of range';
    this.name = 'ArgumentOutOfRangeError';
    return this;
}
ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

});

unwrapExports(ArgumentOutOfRangeError$1);

var EmptyError$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function EmptyErrorImpl() {
    Error.call(this);
    this.message = 'no elements in sequence';
    this.name = 'EmptyError';
    return this;
}
EmptyErrorImpl.prototype = Object.create(Error.prototype);
exports.EmptyError = EmptyErrorImpl;

});

unwrapExports(EmptyError$1);

var TimeoutError$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function TimeoutErrorImpl() {
    Error.call(this);
    this.message = 'Timeout has occurred';
    this.name = 'TimeoutError';
    return this;
}
TimeoutErrorImpl.prototype = Object.create(Error.prototype);
exports.TimeoutError = TimeoutErrorImpl;

});

unwrapExports(TimeoutError$1);

var map_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

});

unwrapExports(map_1);

var bindCallback_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });






function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new Observable_1.Observable(function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
            }
        });
    };
}
exports.bindCallback = bindCallback;
function dispatch(state) {
    var _this = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}


});

unwrapExports(bindCallback_1);

var bindNodeCallback_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });






function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new Observable_1.Observable(function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
exports.bindNodeCallback = bindNodeCallback;
function dispatch(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}

});

unwrapExports(bindNodeCallback_1);

var OuterSubscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;

});

unwrapExports(OuterSubscriber_1);

var InnerSubscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;

});

unwrapExports(InnerSubscriber_1);

var subscribeToPromise$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.subscribeToPromise = function (promise) { return function (subscriber) {
    promise.then(function (value) {
        if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
        }
    }, function (err) { return subscriber.error(err); })
        .then(null, hostReportError_1.hostReportError);
    return subscriber;
}; };

});

unwrapExports(subscribeToPromise$1);

var iterator$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
exports.getSymbolIterator = getSymbolIterator;
exports.iterator = getSymbolIterator();
exports.$$iterator = exports.iterator;

});

unwrapExports(iterator$1);

var subscribeToIterable$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.subscribeToIterable = function (iterable) { return function (subscriber) {
    var iterator = iterable[iterator$1.iterator]();
    do {
        var item = iterator.next();
        if (item.done) {
            subscriber.complete();
            break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
            break;
        }
    } while (true);
    if (typeof iterator.return === 'function') {
        subscriber.add(function () {
            if (iterator.return) {
                iterator.return();
            }
        });
    }
    return subscriber;
}; };

});

unwrapExports(subscribeToIterable$1);

var subscribeToObservable$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.subscribeToObservable = function (obj) { return function (subscriber) {
    var obs = obj[observable$1.observable]();
    if (typeof obs.subscribe !== 'function') {
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    }
    else {
        return obs.subscribe(subscriber);
    }
}; };

});

unwrapExports(subscribeToObservable$1);

var isArrayLike$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

});

unwrapExports(isArrayLike$1);

var isPromise_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;

});

unwrapExports(isPromise_1);

var subscribeTo$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });










exports.subscribeTo = function (result) {
    if (result instanceof Observable_1.Observable) {
        return function (subscriber) {
            if (result._isScalar) {
                subscriber.next(result.value);
                subscriber.complete();
                return undefined;
            }
            else {
                return result.subscribe(subscriber);
            }
        };
    }
    else if (result && typeof result[observable$1.observable] === 'function') {
        return subscribeToObservable$1.subscribeToObservable(result);
    }
    else if (isArrayLike$1.isArrayLike(result)) {
        return subscribeToArray$1.subscribeToArray(result);
    }
    else if (isPromise_1.isPromise(result)) {
        return subscribeToPromise$1.subscribeToPromise(result);
    }
    else if (result && typeof result[iterator$1.iterator] === 'function') {
        return subscribeToIterable$1.subscribeToIterable(result);
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

});

unwrapExports(subscribeTo$1);

var subscribeToResult_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
    if (destination === void 0) { destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex); }
    if (destination.closed) {
        return;
    }
    return subscribeTo$1.subscribeTo(result)(destination);
}
exports.subscribeToResult = subscribeToResult;

});

unwrapExports(subscribeToResult_1);

var combineLatest_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });





var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray$1.isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray_1.fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;

});

unwrapExports(combineLatest_1);

var isInteropObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function isInteropObservable(input) {
    return input && typeof input[observable$1.observable] === 'function';
}
exports.isInteropObservable = isInteropObservable;

});

unwrapExports(isInteropObservable_1);

var isIterable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function isIterable(input) {
    return input && typeof input[iterator$1.iterator] === 'function';
}
exports.isIterable = isIterable;

});

unwrapExports(isIterable_1);

var fromPromise_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function fromPromise(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToPromise$1.subscribeToPromise(input));
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            sub.add(scheduler.schedule(function () { return input.then(function (value) {
                sub.add(scheduler.schedule(function () {
                    subscriber.next(value);
                    sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                }));
            }, function (err) {
                sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
            }); }));
            return sub;
        });
    }
}
exports.fromPromise = fromPromise;

});

unwrapExports(fromPromise_1);

var fromIterable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function fromIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToIterable$1.subscribeToIterable(input));
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            var iterator;
            sub.add(function () {
                if (iterator && typeof iterator.return === 'function') {
                    iterator.return();
                }
            });
            sub.add(scheduler.schedule(function () {
                iterator = input[iterator$1.iterator]();
                sub.add(scheduler.schedule(function () {
                    if (subscriber.closed) {
                        return;
                    }
                    var value;
                    var done;
                    try {
                        var result = iterator.next();
                        value = result.value;
                        done = result.done;
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                        this.schedule();
                    }
                }));
            }));
            return sub;
        });
    }
}
exports.fromIterable = fromIterable;

});

unwrapExports(fromIterable_1);

var fromObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function fromObservable(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToObservable$1.subscribeToObservable(input));
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            sub.add(scheduler.schedule(function () {
                var observable = input[observable$1.observable]();
                sub.add(observable.subscribe({
                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                }));
            }));
            return sub;
        });
    }
}
exports.fromObservable = fromObservable;

});

unwrapExports(fromObservable_1);

var from_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });










function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable_1.Observable) {
            return input;
        }
        return new Observable_1.Observable(subscribeTo$1.subscribeTo(input));
    }
    if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
            return fromObservable_1.fromObservable(input, scheduler);
        }
        else if (isPromise_1.isPromise(input)) {
            return fromPromise_1.fromPromise(input, scheduler);
        }
        else if (isArrayLike$1.isArrayLike(input)) {
            return fromArray_1.fromArray(input, scheduler);
        }
        else if (isIterable_1.isIterable(input) || typeof input === 'string') {
            return fromIterable_1.fromIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
exports.from = from;

});

unwrapExports(from_1);

var mergeMap_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });





function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult_1.subscribeToResult(this, ish, value, index, innerSubscriber);
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;

});

unwrapExports(mergeMap_1);

var mergeAll_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
}
exports.mergeAll = mergeAll;

});

unwrapExports(mergeAll_1);

var concatAll_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;

});

unwrapExports(concatAll_1);

var concat_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {
        return from_1.from(observables[0]);
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;

});

unwrapExports(concat_1);

var defer_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function defer(observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? from_1.from(input) : empty_1.empty();
        return source.subscribe(subscriber);
    });
}
exports.defer = defer;

});

unwrapExports(defer_1);

var forkJoin_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var resultSelector;
    if (typeof sources[sources.length - 1] === 'function') {
        resultSelector = sources.pop();
    }
    if (sources.length === 1 && isArray$1.isArray(sources[0])) {
        sources = sources[0];
    }
    if (sources.length === 0) {
        return empty_1.EMPTY;
    }
    if (resultSelector) {
        return forkJoin(sources).pipe(map_1.map(function (args) { return resultSelector.apply(void 0, args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        return new ForkJoinSubscriber(subscriber, sources);
    });
}
exports.forkJoin = forkJoin;
var ForkJoinSubscriber = (function (_super) {
    __extends(ForkJoinSubscriber, _super);
    function ForkJoinSubscriber(destination, sources) {
        var _this = _super.call(this, destination) || this;
        _this.sources = sources;
        _this.completed = 0;
        _this.haveValues = 0;
        var len = sources.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            var source = sources[i];
            var innerSubscription = subscribeToResult_1.subscribeToResult(_this, source, null, i);
            if (innerSubscription) {
                _this.add(innerSubscription);
            }
        }
        return _this;
    }
    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        if (!innerSub._hasValue) {
            innerSub._hasValue = true;
            this.haveValues++;
        }
    };
    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
        var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;
        var len = values.length;
        if (!innerSub._hasValue) {
            destination.complete();
            return;
        }
        this.completed++;
        if (this.completed !== len) {
            return;
        }
        if (haveValues === len) {
            destination.next(values);
        }
        destination.complete();
    };
    return ForkJoinSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

});

unwrapExports(forkJoin_1);

var fromEvent_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
exports.fromEvent = fromEvent;
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

});

unwrapExports(fromEvent_1);

var fromEventPattern_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!isFunction_1.isFunction(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}
exports.fromEventPattern = fromEventPattern;

});

unwrapExports(fromEventPattern_1);

var generate_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || identity_1.identity;
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new Observable_1.Observable(function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
exports.generate = generate;
function dispatch(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}

});

unwrapExports(generate_1);

var iif_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) { trueResult = empty_1.EMPTY; }
    if (falseResult === void 0) { falseResult = empty_1.EMPTY; }
    return defer_1.defer(function () { return condition() ? trueResult : falseResult; });
}
exports.iif = iif;

});

unwrapExports(iif_1);

var isNumeric_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function isNumeric(val) {
    return !isArray$1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;

});

unwrapExports(isNumeric_1);

var interval_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function interval(period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async$1.async; }
    if (!isNumeric_1.isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = async$1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
exports.interval = interval;
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}

});

unwrapExports(interval_1);

var merge_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(fromArray_1.fromArray(observables, scheduler));
}
exports.merge = merge;

});

unwrapExports(merge_1);

var never_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.NEVER = new Observable_1.Observable(noop_1.noop);
function never() {
    return exports.NEVER;
}
exports.never = never;

});

unwrapExports(never_1);

var onErrorResumeNext_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return empty_1.EMPTY;
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && isArray$1.isArray(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new Observable_1.Observable(function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return from_1.from(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}
exports.onErrorResumeNext = onErrorResumeNext;

});

unwrapExports(onErrorResumeNext_1);

var pairs_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


function pairs(obj, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new Subscription_1.Subscription();
            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
exports.pairs = pairs;
function dispatch(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}
exports.dispatch = dispatch;

});

unwrapExports(pairs_1);

var race_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });




function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (isArray$1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return fromArray_1.fromArray(observables, undefined).lift(new RaceOperator());
}
exports.race = race;
var RaceOperator = (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
exports.RaceOperator = RaceOperator;
var RaceSubscriber = (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.RaceSubscriber = RaceSubscriber;

});

unwrapExports(race_1);

var range_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function range(start, count, scheduler) {
    if (start === void 0) { start = 0; }
    if (count === void 0) { count = 0; }
    return new Observable_1.Observable(function (subscriber) {
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
exports.range = range;
function dispatch(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}
exports.dispatch = dispatch;

});

unwrapExports(range_1);

var timer_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) { dueTime = 0; }
    var period = -1;
    if (isNumeric_1.isNumeric(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (isScheduler_1.isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler_1.isScheduler(scheduler)) {
        scheduler = async$1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        var due = isNumeric_1.isNumeric(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
exports.timer = timer;
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}

});

unwrapExports(timer_1);

var using_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function using(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? from_1.from(result) : empty_1.EMPTY;
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}
exports.using = using;

});

unwrapExports(using_1);

var zip_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return fromArray_1.fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
}
exports.zip = zip;
var ZipOperator = (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
exports.ZipOperator = ZipOperator;
var ZipSubscriber = (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) { values = Object.create(null); }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray$1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator$1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator$1.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator.subscribe(iterator, i));
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator$1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator$1.iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber));

});

unwrapExports(zip_1);

var rxjs = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.Observable = Observable_1.Observable;

exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;

exports.GroupedObservable = groupBy_1.GroupedObservable;

exports.observable = observable$1.observable;

exports.Subject = Subject_1.Subject;

exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;

exports.ReplaySubject = ReplaySubject_1.ReplaySubject;

exports.AsyncSubject = AsyncSubject_1.AsyncSubject;

exports.asapScheduler = asap$1.asap;

exports.asyncScheduler = async$1.async;

exports.queueScheduler = queue$1.queue;

exports.animationFrameScheduler = animationFrame$1.animationFrame;

exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
exports.VirtualAction = VirtualTimeScheduler_1.VirtualAction;

exports.Scheduler = Scheduler_1.Scheduler;

exports.Subscription = Subscription_1.Subscription;

exports.Subscriber = Subscriber_1.Subscriber;

exports.Notification = Notification_1.Notification;

exports.pipe = pipe_1.pipe;

exports.noop = noop_1.noop;

exports.identity = identity_1.identity;

exports.isObservable = isObservable_1.isObservable;

exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError$1.ArgumentOutOfRangeError;

exports.EmptyError = EmptyError$1.EmptyError;

exports.ObjectUnsubscribedError = ObjectUnsubscribedError$1.ObjectUnsubscribedError;

exports.UnsubscriptionError = UnsubscriptionError$1.UnsubscriptionError;

exports.TimeoutError = TimeoutError$1.TimeoutError;

exports.bindCallback = bindCallback_1.bindCallback;

exports.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;

exports.combineLatest = combineLatest_1.combineLatest;

exports.concat = concat_1.concat;

exports.defer = defer_1.defer;

exports.empty = empty_1.empty;

exports.forkJoin = forkJoin_1.forkJoin;

exports.from = from_1.from;

exports.fromEvent = fromEvent_1.fromEvent;

exports.fromEventPattern = fromEventPattern_1.fromEventPattern;

exports.generate = generate_1.generate;

exports.iif = iif_1.iif;

exports.interval = interval_1.interval;

exports.merge = merge_1.merge;

exports.never = never_1.never;

exports.of = of_1.of;

exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;

exports.pairs = pairs_1.pairs;

exports.race = race_1.race;

exports.range = range_1.range;

exports.throwError = throwError_1.throwError;

exports.timer = timer_1.timer;

exports.using = using_1.using;

exports.zip = zip_1.zip;
var empty_2 = empty_1;
exports.EMPTY = empty_2.EMPTY;
var never_2 = never_1;
exports.NEVER = never_2.NEVER;

exports.config = config$1.config;

});

unwrapExports(rxjs);
var rxjs_1 = rxjs.Observable;
var rxjs_5 = rxjs.Subject;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AccordionService {
    constructor() {
        this.subject = new rxjs_5();
    }
    /**
     * @param {?} data
     * @param {?} parent
     * @return {?}
     */
    onClickEvent(data, parent) {
        this.subject.next({ data, parent });
    }
    /**
     * @return {?}
     */
    clearEvents() {
        this.subject.next();
    }
    /**
     * @return {?}
     */
    getEvents() {
        return this.subject.asObservable();
    }
}
AccordionService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 27/11/17.
 */
const LAYOUT_COMPONENTS = [
    AmexioRowComponent,
    AmexioColumnComponent,
    AmexioGridComponent,
    AmexioGridItemComponent,
    AmexioBorderLayoutItemComponent,
    AmexioBorderLayoutComponent,
    AmexioCardComponent,
    AmexioBoxComponent,
    AmexioAccordionTabComponent,
    AmexioAccordionComponent,
    AmexioAccordionHeaderComponent,
    AmexioIconLayoutComponent,
    AmexioLayoutComponent,
    AmexioLayoutItemComponent,
];
class AmexioLayoutModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioLayoutModule,
            providers: [CommonDataService, DeviceQueryService, IconLoaderService, AmexioGridLayoutService],
        };
    }
}
AmexioLayoutModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                ],
                exports: LAYOUT_COMPONENTS,
                declarations: LAYOUT_COMPONENTS,
                providers: [CommonDataService, DeviceQueryService, IconLoaderService, AmexioGridLayoutService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 Component Name : Amexio Carousel
 Component Selector : <[amexioTemplate]>
 Component Description : Amexio CarouselView displays a collection of
 images or other content in a horizontal layout with built-in navigation between the items.

*/
class AmexioTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
    /**
     * @return {?}
     */
    getType() {
        return this.name;
    }
}
AmexioTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[amexioTemplate]',
            },] },
];
/** @nocollapse */
AmexioTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
AmexioTemplateDirective.propDecorators = {
    type: [{ type: Input }],
    name: [{ type: Input, args: ['amexioTemplate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 28/12/17.
 */
class AmexioCarouselComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.startTimeInterval();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.templates.forEach((item) => {
            this.itemTemplate = item.template;
        });
    }
    /**
     * @return {?}
     */
    scrollData() {
    }
    /**
     * @return {?}
     */
    next() {
        const /** @type {?} */ nxt = this.tabs.nativeElement;
        nxt.scrollLeft = nxt.scrollLeft + 200;
    }
    /**
     * @return {?}
     */
    previous() {
        const /** @type {?} */ prev = this.tabs.nativeElement;
        prev.scrollLeft = prev.scrollLeft - 200;
    }
    /**
     * @return {?}
     */
    shuffle() {
    }
    /**
     * @return {?}
     */
    startTimeInterval() {
        if (this.shuffleinterval != null) {
            this.timeInterval = setInterval(() => {
                const /** @type {?} */ carouselItemPosix = this.tabs.nativeElement;
                if (!((carouselItemPosix.scrollWidth - carouselItemPosix.offsetWidth - carouselItemPosix.scrollLeft) <= 0)) {
                    // go next
                    carouselItemPosix.scrollLeft = carouselItemPosix.scrollLeft + 200;
                }
                else if (carouselItemPosix.scrollLeft > 0) {
                    // go previous
                    carouselItemPosix.scrollLeft = carouselItemPosix.scrollLeft - 200;
                }
            }, this.shuffleinterval);
        }
    }
    /**
     * @return {?}
     */
    stopTimeInterval() {
        clearTimeout(this.timeInterval);
    }
}
AmexioCarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-carousel', template: `
    <h4>{{header}}</h4>
    <div class="tabwrapper">
      <div class="carouselnavigation float-left" (click)="previous()">
        <amexio-pane-icon key="carousel_previous"></amexio-pane-icon>
      </div>
      <div class="carouselnavigation float-right" (click)="next()">
        <amexio-pane-icon key="carousel_next"></amexio-pane-icon>
      </div>
      <ul #tab class="tab">
        <li class="tablistitems" *ngFor="let item of data" (mouseover)="stopTimeInterval($event)"
            (mouseleave)="startTimeInterval($event)">
          <ng-template [amexioTemplateWrapper]="itemTemplate" [item]="item"></ng-template>
        </li>
      </ul>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioCarouselComponent.ctorParameters = () => [];
AmexioCarouselComponent.propDecorators = {
    header: [{ type: Input }],
    data: [{ type: Input }],
    shuffleinterval: [{ type: Input, args: ['shuffle-interval',] }],
    templates: [{ type: ContentChildren, args: [AmexioTemplateDirective,] }],
    tabs: [{ type: ViewChild, args: ['tab', { read: ElementRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioTemplateWrapperDirective {
    /**
     * @param {?} viewContainer
     */
    constructor(viewContainer) {
        this.viewContainer = viewContainer;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.render();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    set item(item) {
        this._item = item;
        if (this.view) {
            this.view.destroy();
            this.render();
        }
    }
    /**
     * @return {?}
     */
    get item() {
        return this._item;
    }
    /**
     * @return {?}
     */
    render() {
        this.view = this.viewContainer.createEmbeddedView(this.templateRef, {
            $implicit: this.item, index: this.index,
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.view.destroy();
    }
}
AmexioTemplateWrapperDirective.decorators = [
    { type: Directive, args: [{
                selector: '[amexioTemplateWrapper]',
            },] },
];
/** @nocollapse */
AmexioTemplateWrapperDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
AmexioTemplateWrapperDirective.propDecorators = {
    index: [{ type: Input }],
    templateRef: [{ type: Input, args: ['amexioTemplateWrapper',] }],
    item: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by dattaram on 23/1/18.
 */
class AmexiodialoguePaneComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        /*
           Properties
           name : button-size
           datatype :  string
           version : 4.2 onwards
           default :
           description : Different Sizes of Buttons availabe : large, default, small & xsmall
           */
        this.buttonsize = 'large' || 'small' || 'default' || 'xsmall';
        this.showChange = new EventEmitter();
        /*
           Events
           name : actionStatus
           datatype :  none
           version : none
           default : none
           description : Fire when click on yes or no button
           */
        this.actionStatus = new EventEmitter();
        /*
           Events
           name : close
           datatype :  none
           version : none
           default : none
           description : Fire when user close dialogue
           */
        this.close = new EventEmitter();
        this.value = 0;
        this.closable = true;
        this.secondaryactionlabel = 'Cancel';
        this.primaryactionlabel = 'Ok';
        this.custom = false;
        this.buttonsize = 'default';
        this.buttontype = 'theme-color';
        this.closeonescape = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.showdialogue) {
            this.show = this.showdialogue;
        }
        if (this.footeralign == null) {
            this.footeralign = 'right';
        }
        if (this.contentalign == null || this.contentalign === '') {
            this.contentalign = 'center';
        }
        if (this.type == null) {
            this.type = 'confirm';
        }
        this.defaultStyle = this.getDefaultStyle();
        this.buttontype = this.getStyle();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['showdialogue']) {
            this.show = changes["showdialogue"].currentValue;
            if (this.show && this.closeonescape) {
                this.globalListenFunc = this.renderer.listen('document', 'keyup.esc', (e) => {
                    this.showdialogue = false;
                    this.show = false;
                    this.showChange.emit(false);
                });
            }
            else if (this.globalListenFunc) {
                this.globalListenFunc();
            }
        }
    }
    /**
     * @return {?}
     */
    onCloseClick() {
        if (this.closable) {
            this.showdialogue = false;
            this.show = false;
            this.showChange.emit(false);
            this.close.emit(false);
        }
    }
    /**
     * @param {?} v
     * @return {?}
     */
    getStatus(v) {
        this.onCloseClick();
        this.actionStatus.emit(v);
    }
    /**
     * @return {?}
     */
    getDefaultStyle() {
        if (this.materialDesign) {
            return 'transparent';
        }
        else {
            return 'defualt';
        }
    }
    /**
     * @return {?}
     */
    getStyle() {
        if (this.materialDesign) {
            this.buttontype = 'transparent';
            return this.buttontype;
        }
        else {
            return this.buttontype;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    }
}
AmexiodialoguePaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dialogue', template: `
    <div class="root-window"
         [ngStyle]="{'display' : show  ? 'block' : 'none'}">
      <div class="dialogue-sm">
        <div class="dialogue-content">
          <header [ngClass]="{ 'dialogue-material-design':materialDesign ,'dialogue-header':!materialDesign }"
          >
            <div class="dialogue-table">
              <div class="tablerow">
                <div class="tablecol">
                  {{title}}
                </div>
                <div class="tablecol float-right">
                  <div *ngIf="closable" class="icon-style">
                    <amexio-pane-icon [key]="'window_close'" (onClick)="onCloseClick()"></amexio-pane-icon>
                  </div>
                </div>
              </div>
            </div>
          </header>
          <div class="dialogue-middle" [ngStyle]="{'text-align':custom ? contentalign :'center'}">
            <span class="dialogue-icon">
              <span
                [ngClass]="{'dialogue-success': messagetype  == 'help','dialogue-danger':messagetype  == 'error',
                'dialogue-warning': messagetype  == 'warning'}"
                *ngIf="messagetype  || messagetype  != '' ">
                <amexio-pane-icon [key]="'window-msgtype-'+ messagetype "></amexio-pane-icon>
              </span>
               <ng-container *ngIf="!custom">
                 <span class="dialogue-message">
                        {{message}}
                 </span>
            </ng-container>
            </span>
            <ng-container *ngIf="custom">
              <ng-content select="amexio-body"></ng-content>
            </ng-container>

          </div>
          <footer *ngIf="custom" class="dialogue-footer"
                  [ngClass]="{'flex-start':(footeralign=='left'),'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}">
            <ng-content select="amexio-action"></ng-content>
          </footer>

          <footer *ngIf="!custom" class="dialogue-footer"
                  [ngClass]="{'dialogue-material-design-footer':materialDesign ,
                  'dialogue-footer':!materialDesign, 'flex-start':(footeralign=='left'),
                  'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}">
            <amexio-button *ngIf="type =='confirm'"  [size]="buttonsize" [label]="secondaryactionlabel"
            [type]="defaultStyle" (onClick)="getStatus('cancel')"></amexio-button>
            <div  class="custom-btn">
              <amexio-button *ngIf="type =='confirm' || type == 'alert'"   [size]="buttonsize"
              [label]="primaryactionlabel"
                             [ngStyle]="{'color':materialDesign ? 'blue':'white'}"
                             [type]="buttontype" (onClick)="getStatus('ok')">
                             </amexio-button>
            </div>

          </footer>
        </div>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexiodialoguePaneComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexiodialoguePaneComponent.propDecorators = {
    closeonescape: [{ type: Input, args: ['close-on-escape',] }],
    buttontype: [{ type: Input, args: ['button-type',] }],
    buttonsize: [{ type: Input, args: ['button-size',] }],
    footeralign: [{ type: Input, args: ['footer-align',] }],
    contentalign: [{ type: Input, args: ['content-align',] }],
    showdialogue: [{ type: Input, args: ['show-dialogue',] }],
    show: [{ type: Input }],
    showChange: [{ type: Output }],
    closable: [{ type: Input }],
    title: [{ type: Input }],
    message: [{ type: Input }],
    custom: [{ type: Input }],
    type: [{ type: Input }],
    primaryactionlabel: [{ type: Input, args: ['primary-action-label',] }],
    secondaryactionlabel: [{ type: Input, args: ['secondary-action-label',] }],
    messagetype: [{ type: Input, args: ['message-type',] }],
    materialDesign: [{ type: Input, args: ['material-design',] }],
    actionStatus: [{ type: Output }],
    close: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 12/12/17.
 */
class AmexioFieldSetComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.collapsible) {
            this.isActive = true;
        }
    }
    /**
     * @return {?}
     */
    onLegendClick() {
        if (this.collapsible) {
            this.isActive = !this.isActive;
        }
    }
}
AmexioFieldSetComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-fieldset',
                template: `
    <fieldset>
      <legend *ngIf="(title && title.length>0) || collapsible " class="collapsible-legend" (click)="onLegendClick()">

          <ng-container *ngIf="!collapsible">
            {{title}}
          </ng-container>

          <ng-container *ngIf="collapsible && !isActive">
            <amexio-pane-icon style="padding-right:5px" key="fieldset_expand"></amexio-pane-icon>{{title}}
          </ng-container>

          <ng-container *ngIf="collapsible && isActive">
            <amexio-pane-icon style="padding-right:5px" key="fieldset_collpase"></amexio-pane-icon>{{title}}
          </ng-container>

      </legend>
      <div class="collapsible-fieldset" [ngClass]="{'active' : isActive}">
        <ng-content></ng-content>
      </div>
    </fieldset>
  `,
            },] },
];
/** @nocollapse */
AmexioFieldSetComponent.ctorParameters = () => [];
AmexioFieldSetComponent.propDecorators = {
    collapsible: [{ type: Input }],
    title: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const COMPONENT_CLASS_MAP = {
    primary: 'btn-primary-badge',
    secondary: 'btn-secondary-badge',
};
class AmexioButtonComponent {
    constructor() {
        /*
          Events
          name : onClick
          datatype :  none
          version : none
          default : none
          description : Fire when button click
          */
        this.onClick = new EventEmitter();
        this.badgeCssClass = '';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    buttonClick(event) {
        if (!this.disabled) {
            this.onClick.emit(event);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.badgeCssClass = this.badgeClass();
    }
    /**
     * @return {?}
     */
    badgeClass() {
        let /** @type {?} */ className = '';
        if (this.type === 'primary' || this.type === 'theme-color') {
            className = 'btn-primary-badge';
        }
        if (this.type === 'secondary' || this.type === 'theme-backgroundcolor') {
            className = 'btn-secondary-badge';
        }
        if (this.type === 'success' || this.type === 'green') {
            className = 'btn-success-badge';
        }
        if (this.type === 'danger' || this.type === 'red') {
            className = 'btn-danger-badge';
        }
        if (this.type === 'warning' || this.type === 'yellow') {
            className = 'btn-warning-badge';
        }
        if (this.type === 'transparent') {
            className = 'btn-transparent-badge';
        }
        return className;
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    setDisabled(disabled) {
        this.disabled = disabled;
    }
}
AmexioButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-button',
                template: `
    <button class="button" [ngStyle]="{'cursor': disabled ? 'not-allowed':'pointer'}" ng-disabled="disabled ? true: null" [attr.title]="tooltip" 
    [ngClass]="{'button-default': size=='default'
            || size ==null,
            'button-small': size=='small',
            'button-large' : size=='large',
            'button-block': block==true ,
            'button-primary' : type == 'primary' || type == 'theme-color' ,
            'button-secondary' : type == 'secondary' || type == 'theme-backgroundcolor',
            'button-success' : type == 'success' || type == 'green',
            'button-danger' : type=='danger' || type == 'red',
            'button-warning' : type=='warning' || type == 'yellow',
            'button-transparent' : type=='transparent',
            'disabled' : disabled }" (click)="buttonClick($event)">
            <span class="button-text">
              <span style="padding-right: 5px;" *ngIf="icon">
                <amexio-form-icon [customclass]="icon" >
                </amexio-form-icon>
              </span>
              <span style="padding-right: 5px;" *ngIf="loading">
                <amexio-form-icon key="button-loading-icon"></amexio-form-icon>
              </span>
              {{label}}
              <ng-container *ngIf="badge">
                <span [ngClass]="badgeCssClass" >{{badge}}</span> 
             </ng-container>
            </span>
      
    </button>
  `,
                styles: [`

  `],
            },] },
];
/** @nocollapse */
AmexioButtonComponent.ctorParameters = () => [];
AmexioButtonComponent.propDecorators = {
    label: [{ type: Input }],
    badge: [{ type: Input, args: ['badge',] }],
    icon: [{ type: Input }],
    type: [{ type: Input }],
    tooltip: [{ type: Input }],
    disabled: [{ type: Input }],
    formbind: [{ type: Input, args: ['form-bind',] }],
    size: [{ type: Input }],
    loading: [{ type: Input }],
    onClick: [{ type: Output }],
    block: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioButtonGroupComponent {
    constructor() {
        /* for internal use*/
        this._buttonGroupLocalData = [];
        this.getButton = new EventEmitter();
        this.buttons = [];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set buttonGroupLocalData(value) {
        this._buttonGroupLocalData = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get buttonGroupLocalData() {
        return this._buttonGroupLocalData;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.buttonGroupPreviewData) !== JSON.stringify(this.buttonGroupLocalData)) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.buttons = this.buttonGroupLocalData;
            this.setButtonSizes(this.buttons);
        }
    }
    /**
     * @param {?} change
     * @return {?}
     */
    ngOnChanges(change) {
        if (change["size"] && !change["size"].isFirstChange()) {
            this.updateButtonSizes(change["size"]);
        }
    }
    /**
     * @param {?} clickEvent
     * @param {?} btnObj
     * @return {?}
     */
    buttonGroupClick(clickEvent, btnObj) {
        if (this.buttonGroupLocalData || this.buttonGroupLocalData.length > 0) {
            this.getButton.emit({ event: clickEvent, buttonObject: btnObj });
        }
        else {
            btnObj.onClick.emit(clickEvent);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.buttonGroupLocalData && this.buttonGroupLocalData.length > 0) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.buttons = this.buttonGroupLocalData;
        }
        else {
            this.buttons = this.btns.toArray();
            this.addBadgeCssClass();
        }
        this.setButtonSizes(this.buttons);
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    addBadgeCssClass() {
        this.buttons.forEach((btn) => {
            btn.badgeCssClass = this.badgeClass(btn);
        });
    }
    /**
     * @param {?} button
     * @return {?}
     */
    badgeClass(button) {
        let /** @type {?} */ btnStyleClass = '';
        switch (button.type) {
            case 'primary': {
                return 'btn-group-primary-badge';
            }
            case 'theme-color': {
                return 'btn-group-primary-badge';
            }
            case 'secondary': {
                return 'btn-group-secondary-badge';
            }
            case 'theme-backgroundcolor': {
                return 'btn-group-secondary-badge';
            }
            case 'success': {
                return 'btn-group-success-badge';
            }
            case 'green': {
                return 'btn-group-success-badge';
            }
        }
        btnStyleClass = this.badgeMoreClass(button);
        return btnStyleClass;
    }
    /**
     * @param {?} btnArray
     * @return {?}
     */
    setButtonSizes(btnArray) {
        if (btnArray.length > 0) {
            btnArray.forEach((btn) => {
                btn.size = this.size;
            });
        }
    }
    /**
     * @param {?} button
     * @return {?}
     */
    badgeMoreClass(button) {
        let /** @type {?} */ className = '';
        if (button.type === 'danger' || button.type === 'red') {
            className = 'btn-group-danger-badge';
        }
        if (button.type === 'warning' || button.type === 'yellow') {
            className = 'btn-group-warning-badge';
        }
        if (button.type === 'transparent') {
            className = 'btn-group-transparent-badge';
        }
        return className;
    }
    /**
     * @param {?} size
     * @return {?}
     */
    updateButtonSizes(size) {
        this.buttons.forEach((btn) => {
            btn.size = size;
        });
    }
}
AmexioButtonGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-btn-group',
                template: `
    <div class="btn-group">
        <ng-container *ngFor="let button of buttons">
            <button [attr.disabled]="button.disabled ? true: null" [attr.title]="button.tooltip" (click)="buttonGroupClick($event,button)" [ngClass]="{'button-default': button.size=='default' || button.size ==null,
        'button-small': button.size=='small',
        'button-large' : button.size=='large',
        'button-primary' : button.type == 'primary' || button.type == 'theme-color',
        'button-secondary' : button.type == 'secondary' || button.type == null ||button.type == 'theme-backgroundcolor' ,
        'button-success' : button.type == 'success' || button.type == 'green',
        'button-danger' : button.type=='danger'|| button.type == 'red',
        'button-warning' : button.type=='warning' || button.type == 'yellow',
        'button-transparent' : button.type=='transparent',
        'disabled' : button.disabled}">
          <ng-container *ngIf="button.icon!=null">
            <amexio-form-icon style="padding-right: 5px;" [customclass]="button.icon"></amexio-form-icon>
          </ng-container>

          {{button.label}} 
          <ng-container *ngIf="button.badge">
            <span [ngClass]="button.badgeCssClass" >{{button.badge}}</span> 
         </ng-container>
        </button>
        </ng-container>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioButtonGroupComponent.ctorParameters = () => [];
AmexioButtonGroupComponent.propDecorators = {
    size: [{ type: Input }],
    buttonGroupLocalData: [{ type: Input, args: ['buttonGroupLocalData',] }],
    badge: [{ type: Input, args: ['badge',] }],
    getButton: [{ type: Output }],
    btns: [{ type: ContentChildren, args: [AmexioButtonComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioFormActionComponent {
    constructor() {
        this.buttons = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.btns.length > 0) {
            this.buttons = this.btns.toArray();
        }
        else if (this.btngrp.length > 0) {
            this.buttons = this.btngrp.toArray()[0].buttons;
        }
    }
}
AmexioFormActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-form-action', template: '<ng-content></ng-content>',
            },] },
];
/** @nocollapse */
AmexioFormActionComponent.ctorParameters = () => [];
AmexioFormActionComponent.propDecorators = {
    padding: [{ type: Input }],
    btns: [{ type: ContentChildren, args: [AmexioButtonComponent,] }],
    btngrp: [{ type: ContentChildren, args: [AmexioButtonGroupComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioFormBodyComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioFormBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-form-body', template: '<ng-content></ng-content>',
            },] },
];
/** @nocollapse */
AmexioFormBodyComponent.ctorParameters = () => [];
AmexioFormBodyComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioFormGroupDirective {
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.modelsarray = this.models.toArray();
    }
}
AmexioFormGroupDirective.decorators = [
    { type: Directive, args: [{
                selector: '[form-group]',
            },] },
];
AmexioFormGroupDirective.propDecorators = {
    group: [{ type: Input, args: ['form-group',] }],
    models: [{ type: ContentChildren, args: [NgModel, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioFormHeaderComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioFormHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-form-header', template: `
        <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioFormHeaderComponent.ctorParameters = () => [];
AmexioFormHeaderComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioFormComponent {
    /**
     * @param {?} formBuilder
     */
    constructor(formBuilder) {
        this.formBuilder = formBuilder;
        /*
        Properties
        name : show-error
        datatype : boolean
        version : 4.2 onwards
        default : false
        description : Flag to show form invalid error messages
        */
        this.showError = false;
        /*
        Events
        name : showErrorMsg
        datatype : any
        version : none
        default :
        description : Event fired if showError msg info button is clicked
        */
        this.showErrorMsg = new EventEmitter();
        this.componentError = [];
        this.checkForm = false;
        this.isFormValid = false;
        this.showDialogue = false;
        this.headeralign = 'left';
        this.footeralign = 'right';
        this.errorMsgArray = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // FOR HEADER PADING
        this.headerComponentList = this.amexioHeader.toArray();
        this.headerComponentList.forEach((item, currentIndex) => {
            if (item.padding) {
                this.headerPadding = item.padding;
            }
        });
        // FOR BODY PADDING
        this.bodyComponentList = this.amexioBody.toArray();
        this.bodyComponentList.forEach((item, currentIndex) => {
            if (item.padding) {
                this.bodyPadding = item.padding;
            }
        });
        // FOR FOOTER PADDING
        this.footerComponentList = this.amexioFooter.toArray();
        this.footerComponentList.forEach((item, currentIndex) => {
            if (item.padding) {
                this.footerPadding = item.padding;
            }
        });
    }
    /**
     * @return {?}
     */
    onResize() {
        if (this.bodyheight) {
            let /** @type {?} */ h = (window.innerHeight / 100) * this.bodyheight;
            if (this.formHeader && this.formHeader.nativeElement && this.formHeader.nativeElement.offsetHeight) {
                h = h - this.formHeader.nativeElement.offsetHeight;
            }
            if (this.formFooter && this.formFooter.nativeElement && this.formFooter.nativeElement.offsetHeight) {
                h = h - this.formFooter.nativeElement.offsetHeight;
            }
            if (this.bodyheight === 100) {
                h = h - 40;
            }
            this.minHeight = h;
            this.height = h;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.buttons = [];
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        const /** @type {?} */ ngContentModels = this.models.toArray();
        const /** @type {?} */ innerModelArray = [];
        this.fb.forEach((fbnode) => {
            const /** @type {?} */ modelarray = fbnode.modelsarray;
            const /** @type {?} */ fgc = {};
            modelarray.forEach((m) => {
                fgc[m.name] = m.control;
                innerModelArray.push(m);
            });
            const /** @type {?} */ grp = this.formBuilder.group(fgc);
            this.form.form.registerControl(fbnode.group, grp);
        });
        ngContentModels.forEach((model) => {
            if (!this.isFieldPresentInParentAndChildBoth(innerModelArray, model.name)) {
                if (!model.name || model.name === null) {
                    model.name = model.valueAccessor['name'];
                }
                this.form.control.registerControl(model.name, model.control);
            }
        });
        this.form.form.updateValueAndValidity();
        this.btns.toArray().forEach((btnCom) => {
            if ((btnCom.formbind === this.fname) && !btnCom.disabled) {
                this.buttons.push(btnCom);
            }
        });
        this.validateForm();
        this.onResize();
    }
    /**
     * @param {?} innerModelArray
     * @param {?} name
     * @return {?}
     */
    isFieldPresentInParentAndChildBoth(innerModelArray, name) {
        let /** @type {?} */ isPresent = false;
        innerModelArray.forEach((innerModel) => {
            if (name === innerModel.name) {
                isPresent = true;
            }
        });
        return isPresent;
    }
    /**
     * @return {?}
     */
    closeDialogue() {
        this.showDialogue = !this.showDialogue;
    }
    /**
     * @return {?}
     */
    addErrorMsg() {
        if (this.form && this.form.status === 'INVALID') {
            for (const [key, value] of Object.entries(this.form.controls)) {
                if (value && value.status === 'INVALID') {
                    const /** @type {?} */ errorObject = {};
                    errorObject['label'] = key;
                    this.errorMsgArray.push(errorObject);
                }
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    showErrors(event) {
        this.errorMsgArray = [];
        this.addErrorMsg();
        this.showDialogue = !this.isFormValid;
        if (!this.isFormValid) {
            this.showDialogue = true;
        }
        else {
            this.showDialogue = false;
        }
    }
    /**
     * @return {?}
     */
    validateForm() {
        if (this.form && this.form.status === 'INVALID') {
            this.disableButton(true);
        }
        else {
            this.disableButton(false);
        }
    }
    /**
     * @param {?} flag
     * @return {?}
     */
    disableButton(flag) {
        this.buttons.forEach((btn) => {
            btn.disabled = flag;
        });
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.validateForm();
    }
    /**
     * @return {?}
     */
    findformStyleClass() {
        if (this.headeralign === 'right') {
            return 'flex-end';
        }
        if (this.headeralign === 'left') {
            return 'flex-start';
        }
        if (this.headeralign === 'center') {
            return 'flex-center';
        }
    }
}
AmexioFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-form',
                template: `
    <form name="fname" class="form-container form-group" (window:resize)="onResize()">

        <header #formHeader class="form-header" [style.padding]="headerPadding" *ngIf="header" [ngClass]="findformStyleClass()">
            <ng-content select="amexio-form-header"></ng-content>
        </header>

        <div class="form-body formbody" [style.padding]="bodyPadding" [ngStyle]="{'height.px' : height,'overflow-y' : height!= null ? 'auto' : '','min-height.px' : minHeight}">
            <ng-content select="amexio-form-body"></ng-content>
        </div>

        <footer #formFooter class="form-footer" [style.padding]="footerPadding" [ngClass]="{'flex-start':(footeralign=='left'),'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}">
            <ng-content select="amexio-form-action"></ng-content>
            <br/>
            <div *ngIf="!form.valid" style="padding: 5px;">
                <button class="button" [attr.title]="'click'" (click)="showErrors($event)" [ngClass]="'button-warning button-small button-round'">
                            <span class="button-text">
                              <span style="padding-right: 5px;" *ngIf="icon">
                                <amexio-form-icon [customclass]="icon" >
                                </amexio-form-icon>
                              </span>
                              <span style="padding-right: 5px;" *ngIf="loading">
                                <amexio-form-icon key="button-loading-icon"></amexio-form-icon>
                              </span>
                              ?
                            </span>
                    </button>
                <amexio-dialogue [show-dialogue]="showDialogue" [custom]="true" [content-align]="'left'" [closable]="false" [title]="'Invalid Fields'" [type]="'confirm'">

                    <amexio-body *ngFor="let msg of errorMsgArray let index=index">
                        <amexio-label>{{index+1}}) {{msg.label}}</amexio-label><br>
                    </amexio-body>

                    <amexio-action>
                        <amexio-button type="primary" (onClick)="closeDialogue()" [label]="'OK'">
                        </amexio-button>
                    </amexio-action>
                </amexio-dialogue>
            </div>
        </footer>
    </form>
  `,
            },] },
];
/** @nocollapse */
AmexioFormComponent.ctorParameters = () => [
    { type: FormBuilder }
];
AmexioFormComponent.propDecorators = {
    headeralign: [{ type: Input, args: ['header-align',] }],
    footeralign: [{ type: Input, args: ['footer-align',] }],
    fname: [{ type: Input, args: ['form-name',] }],
    header: [{ type: Input, args: ['header',] }],
    showError: [{ type: Input, args: ['show-error',] }],
    height: [{ type: Input }],
    minHeight: [{ type: Input, args: ['min-height',] }],
    bodyheight: [{ type: Input, args: ['body-height',] }],
    formHeader: [{ type: ViewChild, args: ['formHeader', { read: ElementRef },] }],
    formFooter: [{ type: ViewChild, args: ['formFooter', { read: ElementRef },] }],
    showErrorMsg: [{ type: Output }],
    amexioHeader: [{ type: ContentChildren, args: [AmexioFormHeaderComponent,] }],
    amexioBody: [{ type: ContentChildren, args: [AmexioFormBodyComponent,] }],
    amexioFooter: [{ type: ContentChildren, args: [AmexioFormActionComponent,] }],
    btns: [{ type: ContentChildren, args: [AmexioButtonComponent, { descendants: true },] }],
    form: [{ type: ViewChild, args: [NgForm,] }],
    models: [{ type: ContentChildren, args: [NgModel, { descendants: true },] }],
    fb: [{ type: ContentChildren, args: [AmexioFormGroupDirective, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioIconPaneComponent {
    /**
     * @param {?} iconLoaderService
     */
    constructor(iconLoaderService) {
        this.iconLoaderService = iconLoaderService;
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.iconClass = this.getIconClass();
    }
    /**
     * @return {?}
     */
    getIconClass() {
        if (this.iconLoaderService.iconMappings != null) {
            const /** @type {?} */ iconObject = this.iconLoaderService.iconMappings.find((obj) => obj.component === this.key);
            if (iconObject != null) {
                return iconObject[this.iconLoaderService.iconToUse.toString()];
            }
            else {
                return '';
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['key']) {
            this.key = changes["key"].currentValue;
            this.iconClass = this.getIconClass();
        }
    }
}
AmexioIconPaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-pane-icon', template: `
    <ng-container *ngIf="iconLoaderService.iconToUse == 'fa'">
      <ng-container *ngIf="customclass != null">
        <i class="{{customclass}}" aria-hidden="true" (click)="onClick.emit($event)" style="cursor: pointer;"></i>
      </ng-container>
      <ng-container *ngIf="customclass == null">
        <i [ngClass]="iconClass" aria-hidden="true" (click)="onClick.emit($event)" style="cursor: pointer;"></i>
      </ng-container>
    </ng-container>

    <ng-container *ngIf="iconLoaderService.iconToUse == 'mat'">

      <ng-container *ngIf="customclass != null">
        <i class="material-icons" (click)="onClick.emit($event)" style="cursor: pointer;">{{customclass}}</i>
      </ng-container>

      <ng-container *ngIf="customclass == null">
        <i class="material-icons" (click)="onClick.emit($event)" style="cursor: pointer;">{{iconClass}}</i>
      </ng-container>
    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioIconPaneComponent.ctorParameters = () => [
    { type: IconLoaderService }
];
AmexioIconPaneComponent.propDecorators = {
    key: [{ type: Input }],
    customclass: [{ type: Input }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 14/12/17.
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Pratik Kelwalkar
 *
 */
class AmexioPanelComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        /*
        Properties
        name : collapsible
        datatype :  boolean
        version : 4.0 onwards
        default : false
        description : Pane will expand or collapse based on the boolean.
        */
        this.collapsible = true;
        this.contentAlign = 'left';
        this.onClick = new EventEmitter();
        this.nodeRightClick = new EventEmitter();
        this.rightClick = new EventEmitter();
        this.mouseLocation = { left: 0, top: 0 };
        this.faFaIconUPCss = 'fa fa-caret-up';
        this.faFaIconDownCss = 'fa fa-caret-down';
        this.panelstyle = { visibility: 'visible' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.collapsible) {
            this.expanded = true;
        }
        this.iconclassKey = this.expanded ? this.faFaIconUPCss : this.faFaIconDownCss;
        if (this.height) {
            return this.height;
        }
        this.updatestyle();
    }
    /**
     * @param {?} btn
     * @return {?}
     */
    onTabClick(btn) {
        btn.classList.toggle('active-accordion');
        if (this.iconclassKey === this.faFaIconDownCss) {
            this.iconclassKey = this.faFaIconUPCss;
        }
        else if (this.iconclassKey === this.faFaIconUPCss) {
            this.iconclassKey = this.faFaIconDownCss;
        }
        this.expanded = !this.expanded;
        this.updatestyle();
        this.onClick.emit();
    }
    /**
     * @return {?}
     */
    updatestyle() {
        if (this.fit && this.expanded) {
            this.panelstyle = { visibility: 'visible' };
        }
        else if (this.fit && !this.expanded) {
            this.panelstyle = { visibility: 'hidden' };
        }
        else if (!this.fit && this.expanded) {
            this.panelstyle = { display: 'block' };
        }
        else if (!this.fit && !this.expanded) {
            this.panelstyle = { display: 'none' };
        }
        else {
            this.panelstyle = { visibility: 'visible' };
        }
    }
    /**
     * @return {?}
     */
    getContextMenu() {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        const /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    loadContextMenu(rightClickData) {
        this.mouseLocation.left = rightClickData.event.clientX;
        this.mouseLocation.top = rightClickData.event.clientY;
        this.getContextMenu();
        this.posixUp = this.getListPosition(rightClickData.ref);
        rightClickData.event.preventDefault();
        rightClickData.event.stopPropagation();
        this.rightClickNodeData = rightClickData.data;
        this.contextStyle = this.getContextMenuStyle();
        this.nodeRightClick.emit(rightClickData);
    }
    /**
     * @param {?} itemConfig
     * @return {?}
     */
    onContextNodeClick(itemConfig) {
        if (!itemConfig.disabled) {
            const /** @type {?} */ obj = {
                menuData: itemConfig,
                NodeData: this.rightClickNodeData,
            };
            this.flag = false;
            this.removeListner();
            this.rightClick.emit(obj);
        }
    }
    /**
     * @return {?}
     */
    getContextMenuStyle() {
        return {
            'cursor': 'default',
            'position': 'fixed',
            'display': this.flag ? 'block' : 'none',
            'left': this.mouseLocation.left + 'px',
            'top': this.mouseLocation.top + 'px',
            'box-shadow': '1px 1px 2px #000000',
            'width': '15%',
        };
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (e) => {
            this.flag = false;
            if (!this.flag) {
                this.removeListner();
            }
        });
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
    }
}
AmexioPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-panel',
                template: `
    <div #id style="width: 100%" (contextmenu)="loadContextMenu({event:$event,ref:id})">
        <ng-container *ngIf="collapsible; else elseBlock">
            <div *ngIf="header" class="panel-accordion" (click)="onTabClick(btn1)">
                <amexio-toolbar>
                    <amexio-toolbar-item position-left>
                        <amexio-label size="small">
                            {{title}}
                        </amexio-label>
                    </amexio-toolbar-item>
                    <amexio-toolbar-item position-right>
                        <ng-content select="amexio-panel-header"></ng-content>
                    </amexio-toolbar-item>
                    <amexio-toolbar-item style="margin:auto" position-right>
                        <i [class]="iconclassKey" aria-hidden="true" #btn1></i>
                    </amexio-toolbar-item>
                </amexio-toolbar>
            </div>
        </ng-container>

        <ng-template #elseBlock>
            <div *ngIf="header" class="panel-accordion" (click)="onTabClick(btn1)">
                <amexio-toolbar>
                    <amexio-toolbar-item position-left>
                        <amexio-label size="small">
                            {{title}}
                        </amexio-label>
                    </amexio-toolbar-item>
                    <amexio-toolbar-item position-right>
                        <ng-content select="amexio-panel-header"></ng-content>
                    </amexio-toolbar-item>
                </amexio-toolbar>
            </div>
        </ng-template>

        <div class="panel-panel" [ngClass]="{'panel-box-border':border}" [style.textAlign]="contentAlign" [ngStyle]="panelstyle" [style.height.px]="height">
            <ng-content></ng-content>
        </div>


        <span [ngStyle]="contextStyle">
            <ul *ngIf="flag" class="context-menu-list" [ngClass]="{'dropdown-up' : posixUp}">
                <li (click)="onContextNodeClick(itemConfig)" class="context-menu-list-items" [ngStyle]="{'cursor': itemConfig.disabled ? 'not-allowed':'pointer'}"
                    [ngClass]="{'context-menu-separator':itemConfig.seperator}" *ngFor="let itemConfig of contextmenu">
                    <em [ngStyle]="{'padding-left': itemConfig.icon ? '5px':'19px'}" [ngClass]="itemConfig.icon"></em>
                    <span style="white-space: nowrap;display: inline ; padding-left:5px">{{itemConfig.text}}
                    </span>
                </li>
            </ul>
        </span>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioPanelComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexioPanelComponent.propDecorators = {
    title: [{ type: Input }],
    header: [{ type: Input }],
    expanded: [{ type: Input }],
    border: [{ type: Input }],
    collapsible: [{ type: Input }],
    height: [{ type: Input }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    contentAlign: [{ type: Input, args: ['content-align',] }],
    parentRef: [{ type: Input }],
    fit: [{ type: Input, args: ['fit',] }],
    onClick: [{ type: Output }],
    nodeRightClick: [{ type: Output }],
    rightClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioPanelHeaderComponent {
    constructor() {
        this.role = 'amexio-panel-header';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioPanelHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-panel-header', template: `
    <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioPanelHeaderComponent.ctorParameters = () => [];
AmexioPanelHeaderComponent.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.class',] }],
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by sagar on 6/9/17.
 */
class StepBlockComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
StepBlockComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-step-block', template: `
  `,
            },] },
];
/** @nocollapse */
StepBlockComponent.ctorParameters = () => [];
StepBlockComponent.propDecorators = {
    active: [{ type: Input }],
    label: [{ type: Input }],
    icon: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 15/12/17.
 */
class AmexioStepsComponent {
    constructor() {
        /*
        Events
        name : onClick
        datatype : none
        version : none
        default : none
        description :Event emitted on block click.
        */
        this.onClick = new EventEmitter();
        /*
        Events
        name : getStepBlockData
        datatype : none
        version : none
        default : none
        description :Gives stepblock information .
        */
        this.getStepBlockData = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} clickData
     * @param {?} ev
     * @return {?}
     */
    onStepClick(clickData, ev) {
        this.getStepBlockData.emit({ event: ev, data: clickData });
        this.onClick.emit(clickData);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.data && this.data.length > 0) {
            this.stepPreviewData = JSON.parse(JSON.stringify(this.data));
            this.stepBlockArray = this.data;
        }
        else {
            this.stepBlockArray = this.stepBlocks.toArray();
        }
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.stepPreviewData) !== JSON.stringify(this.data)) {
            this.stepPreviewData = JSON.parse(JSON.stringify(this.data));
            this.stepBlockArray = this.data;
        }
    }
}
AmexioStepsComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-steps', template: `
    <div class="stepwizard" *ngIf="(index && !block && !icon)">
      <div class="stepwizard-row setup-panel">
        <div *ngFor="let stepBlock of stepBlockArray; let i = index" class="stepwizard-step" >
          <button type="button" [disabled]="!stepBlock.active" [ngClass]="{'disabled index-step-inactive':!stepBlock.active,
          'active':stepBlock.active}"
                  class="btn-circle button button-primary" (click)="onStepClick(stepBlock,$event)"
                  >{{i + 1}}
          </button>
          <ng-container *ngIf="stepBlock.label && !stepBlock.active">
            <p>{{stepBlock.label}}</p>
          </ng-container>
          <ng-container *ngIf="stepBlock.label && stepBlock.active">
            <p><strong class="step-label-highlight">{{stepBlock.label}}</strong></p>
          </ng-container>
        </div>
      </div>
    </div>

    <!--this code use when user give icon true bydefault it is false-->
    <div class="stepwizard" *ngIf="(icon && !index && !block)">
      <div class="stepwizard-row setup-panel" >
        <div *ngFor="let stepBlock of stepBlockArray; let i = index" class="stepwizard-step" >
          <ng-container *ngIf="stepBlock.icon && stepBlock.active">
          <span [ngClass]="{'step-box-icon-active':stepBlock.active}" (onClick)="onStepClick(stepBlock,$event)">
            <amexio-pane-icon [customclass]="stepBlock.icon" ></amexio-pane-icon>
          </span>
            </ng-container>
          <ng-container *ngIf="stepBlock.icon && !stepBlock.active">
          <span [ngClass]="{'step-block-icon-disable':!stepBlock.active}">
            <amexio-pane-icon [customclass]="stepBlock.icon" (onClick)="onStepClick(stepBlock,$event)"></amexio-pane-icon>
            </span>
          </ng-container>
          <ng-container *ngIf="stepBlock.icon=='' || !stepBlock.icon">
            <br>
          </ng-container>
          <ng-container *ngIf="stepBlock.label && !stepBlock.active">
            <p style="cursor:not-allowed;" (onClick)="onStepClick(stepBlock,$event)">{{stepBlock.label}}</p>
          </ng-container>
          <ng-container *ngIf="stepBlock.label && stepBlock.active">
            <p style="cursor:pointer;" ><strong class="step-label-highlight"
            [ngClass]="{'step-box-label-active':stepBlock.active}">{{stepBlock.label}}</strong></p>
          </ng-container>
        </div>
      </div>
    </div>

    <!--This code use for steps of boxes-->
    <div *ngIf="block">
      <div *ngIf="block" class="step-box-sqaure">
        <div class="step-box-table">
          <ng-container *ngFor="let stepBlock of stepBlockArray; let i = index">
            <div class="step-box-table-item" (click)="onStepClick(stepBlock,$event)"  style="padding-top: 10px;"
            [ngClass]="{'disabled step-box-table-item-hover ':!stepBlock.active,'active':stepBlock.active}">
              <a>
                <ng-container *ngIf="index">
                  {{i + 1}}<br>
                </ng-container>
                <ng-container *ngIf="icon && stepBlock.icon">
                <amexio-pane-icon [customclass]="stepBlock.icon"></amexio-pane-icon>
                </ng-container>
                <ng-container *ngIf="stepBlock.label && !stepBlock.active">
                  <p style="word-wrap: break-word;">{{stepBlock.label}}</p>
                </ng-container>
                <ng-container *ngIf="stepBlock.label && stepBlock.active">
                <p style="word-wrap: break-word;"><strong>{{stepBlock.label}}</strong></p>
                </ng-container>
              </a>
            </div>
          </ng-container>

        </div>
      </div>

    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioStepsComponent.ctorParameters = () => [];
AmexioStepsComponent.propDecorators = {
    index: [{ type: Input }],
    icon: [{ type: Input }],
    block: [{ type: Input }],
    onClick: [{ type: Output }],
    getStepBlockData: [{ type: Output }],
    stepBlocks: [{ type: ContentChildren, args: [StepBlockComponent,] }],
    data: [{ type: Input, args: ['data',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 8/12/17.
 */
class AmexioTabPillComponent {
    constructor() {
        /*
        Properties
        name : disabled
        datatype : boolean
        version : 4.1.4 onwards
        default : false
        description : Disable property for tab
        */
        this.disabled = false;
        /*
        Properties
        name : active
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : Set true for specific tab open as default tab..
        */
        this.active = false;
        /*
         Properties
         name : closable
         datatype : boolean
         version : 4.2 onwards
         default : false
         description : Font color of label
         */
        this.closable = null;
        this.tabId = Math.floor(Math.random() * 90000) + 10000;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioTabPillComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tab', template: `
    <div role="tabpanel" class="tab-pane active" [attr.id]="tabId" [hidden]="!active">
      <ng-content></ng-content>
      <ng-template #target></ng-template>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioTabPillComponent.ctorParameters = () => [];
AmexioTabPillComponent.propDecorators = {
    title: [{ type: Input }],
    disabled: [{ type: Input }],
    active: [{ type: Input }],
    icon: [{ type: Input }],
    amexiocolor: [{ type: Input, args: ['amexio-color',] }],
    closable: [{ type: Input }],
    target: [{ type: ViewChild, args: ['target', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioRightVerticalTabComponent {
    /**
     * @param {?} render
     */
    constructor(render) {
        this.render = render;
        /*
        Events
        name : onClick
        datatype :none
        version : 4.0 onwards
        default : none
        description : Callback to invoke on activated tab event.
        */
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.tabCollection = this.queryTabs.toArray();
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    onTabClick(tab) {
        if (!tab.disabled) {
            for (const /** @type {?} */ i of this.tabCollection) {
                if (i === tab) {
                    i['active'] = true;
                    this.onClick.emit(tab);
                }
                else {
                    i['active'] = false;
                }
            }
        }
    }
    /**
     * @param {?} tabNode
     * @return {?}
     */
    closeTab(tabNode) {
        const /** @type {?} */ newTab = [];
        let /** @type {?} */ index = 0;
        let /** @type {?} */ tabHighlightIndex = 0;
        this.tabCollection.forEach((tab) => {
            tab.active = false;
            if (tab.tabId === tabNode.tabId) {
                tabHighlightIndex = index;
            }
            if (tab.tabId !== tabNode.tabId) {
                newTab.push(tab);
            }
            index++;
        });
        if (tabHighlightIndex === newTab.length) {
            tabHighlightIndex--;
        }
        this.activateTab(newTab[tabHighlightIndex].tabId);
        this.tabCollection = newTab;
    }
    /**
     * @param {?} tabId
     * @return {?}
     */
    activateTab(tabId) {
        this.tabCollection.forEach((tab) => {
            tab.active = false;
            if (tab.tabId === tabId) {
                tab.active = true;
            }
        });
    }
}
AmexioRightVerticalTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-right-vertical-tab-view',
                template: `

    <div class="righttable">
      <div class="righttablerow">
        <div class="tablecol verticalalign-tabcontent">
          <div style="float:left" class="tabcontent">
            <ng-content></ng-content>
          </div>
        </div>

        <div style="float:right" class="righttablecol verticalalign-tabright">
          <div class="verticalnavtab verticalnavtab-right">
            <ul>
              <li *ngFor="let tabnode of tabCollection">
                <div class="defaultnode" [ngClass]="{'rightactivetab':tabnode.active,'disabled-tab':tabnode.disabled }" 
                (click)="onTabClick(tabnode)">
                  <span *ngIf="tabnode.icon" [ngClass]="tabnode.icon"  aria-hidden="true"></span>
                  <span style="padding-left:5px">{{tabnode.title}}</span>
                </div>
              </li>
            </ul>
          </div>
        </div>

      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioRightVerticalTabComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexioRightVerticalTabComponent.propDecorators = {
    tabs: [{ type: ViewChild, args: ['tab', { read: ElementRef },] }],
    queryTabs: [{ type: ContentChildren, args: [AmexioTabPillComponent,] }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const noop$2 = () => {
};
/**
 * @abstract
 * @template T
 */
class ValueAccessorBase {
    constructor() {
        this.onTouchedCallback = noop$2;
        this.onChangeCallback = noop$2;
    }
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} name
     * @param {?} fieldlabel
     * @param {?} inputType
     * @return {?}
     */
    generateName(name, fieldlabel, inputType) {
        let /** @type {?} */ newName;
        if (!name && fieldlabel) {
            newName = fieldlabel.replace(/\s/g, '');
        }
        else if (!name && !fieldlabel) {
            newName = inputType + '-' + this.getRandomString();
        }
        return newName;
    }
    /**
     * @return {?}
     */
    getRandomString() {
        const /** @type {?} */ possibleCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
        let /** @type {?} */ randomString = '';
        for (let /** @type {?} */ i = 0; i < 6; i++) {
            randomString += possibleCharacters.charAt(Math.floor(Math.random() * possibleCharacters.length));
        }
        return randomString;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioCheckBoxGroupComponent extends ValueAccessorBase {
    /**
     * @param {?} httpService
     */
    constructor(httpService) {
        super();
        this.httpService = httpService;
        /*
          Properties
          name : disabled
          datatype : boolean
          version : 4.0 onwards
          default : false
          description :  If true will not react on any user events and show disable icon over
          */
        this.disabled = false;
        this.onSelection = new EventEmitter();
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set data(v) {
        this._data = v;
        this.viewdata = of(this.data);
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ reponseData;
        if (this.httpmethod && this.httpurl) {
            this.httpService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                reponseData = response;
            }, (error) => {
            }, () => {
                this.data = this.getResponseData(reponseData);
            });
        }
        else if (this.data && this.datareader) {
            this.data = this.getResponseData(this.data);
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getResponseData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    contains(value) {
        if (this._model instanceof Array) {
            this._model.forEach((obj) => {
                if (obj[this.displayfield] === value[this.displayfield]) {
                    return true;
                }
            });
        }
        return false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    add(value) {
        if (!this.contains(value)) {
            if (this._model instanceof Array) {
                this._model.push(value);
            }
            else {
                this._model = [value];
            }
            this.onChangeCallback(this._model);
        }
        this.emitCheckboxes(this._model);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    remove(value) {
        const /** @type {?} */ index = this._model.indexOf(value);
        if (!this._model || index < 0) {
            return;
        }
        this._model.splice(index, 1);
        this.onChangeCallback(this._model);
        this.emitCheckboxes(this._model);
    }
    /**
     * @param {?} selectedCheckBoxes
     * @return {?}
     */
    emitCheckboxes(selectedCheckBoxes) {
        this.selectedCheckBox = [];
        if (selectedCheckBoxes && selectedCheckBoxes.length > 0) {
            selectedCheckBoxes.forEach((obj) => {
                obj.checked = true;
                this.selectedCheckBox.push(obj);
            });
        }
        this.onSelection.emit(this.selectedCheckBox);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return (this.required && (this._model && this._model.length > 0)) || !this.required
            ? null
            : {
                jsonParseError: {
                    valid: true,
                },
            };
    }
}
AmexioCheckBoxGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-checkbox-group',
                template: `
    <!-- <div style="height: 300px;" *ngIf="mask">
        <div class="spinner"></div>
    </div> -->
    <div class="inputgroup form-group">
        <div *ngIf="fieldlabel">
            <label>{{fieldlabel}}</label>
        </div>

        <div *ngIf="horizontal" style="display: inline-flex; flex-direction :row;">
            <checkbox *ngFor="let data of viewdata | async" [checked]="data.checked" [value]="data" [disabled]="data?.disabled || disabled" [label]="data[displayfield]">
            </checkbox>
        </div>

        <div *ngIf="!horizontal" style="display: inline-flex;flex-direction :column;">
            <checkbox *ngFor="let data of viewdata | async" [checked]="data.checked" [value]="data" [disabled]="data?.disabled || disabled" [label]="data[displayfield]">
            </checkbox>
        </div>
    </div>
  `,
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioCheckBoxGroupComponent), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AmexioCheckBoxGroupComponent), multi: true },
                ]
            },] },
];
/** @nocollapse */
AmexioCheckBoxGroupComponent.ctorParameters = () => [
    { type: CommonDataService }
];
AmexioCheckBoxGroupComponent.propDecorators = {
    horizontal: [{ type: Input }],
    disabled: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    required: [{ type: Input, args: ['required',] }],
    name: [{ type: Input, args: ['name',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    onSelection: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioFormValidator {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const noop$3 = () => {
};
class AmexioCheckBoxComponent extends AmexioFormValidator {
    constructor() {
        super();
        this.innerValue = '';
        this.onTouchedCallback = noop$3;
        this.onChangeCallback = noop$3;
        /*
          Properties
          name : required
          datatype : boolean
          version : 4.0 onwards
          default : false
          description :  property to set if manditory
          */
        this.required = false;
        /*
          Events
          name : onSelection
          datatype : any
          version : none
          default : none
          description : Event fired on checkbox click.
          */
        this.onSelection = new EventEmitter();
        /*
          Events
          name : input
          datatype : any
          version : none
          default : none
          description : On input event field.
          */
        this.input = new EventEmitter();
        this.isComponentValid = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.generateName();
        this.isValid = !this.required;
        this.isComponentValid.emit(!this.required);
    }
    /**
     * @return {?}
     */
    onInput() {
        this.isValid = this.value;
        this.isComponentValid.emit(this.value);
        this.input.emit(this.value);
    }
    /**
     * @return {?}
     */
    onClick() {
        this.value = !this.value;
        this.isValid = this.value;
        this.isComponentValid.emit(this.value);
        this.onSelection.emit(this.value);
    }
    /**
     * @return {?}
     */
    get value() {
        if (this.required) {
            this.isValid = this.innerValue;
        }
        else {
            this.isValid = true;
        }
        return this.innerValue;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.onTouchedCallback();
    }
    /**
     * @return {?}
     */
    onFocus() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return ((this.required && this.value) || !this.required) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
    /**
     * @return {?}
     */
    generateName() {
        if (!this.name && this.fieldlabel) {
            this.name = this.fieldlabel.replace(/\s/g, '');
        }
        else if (!this.name && !this.fieldlabel) {
            this.name = 'textinput-' + this.getRandomString();
        }
    }
    /**
     * @return {?}
     */
    getRandomString() {
        const /** @type {?} */ possibleCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
        let /** @type {?} */ randomString = '';
        for (let /** @type {?} */ i = 0; i < 6; i++) {
            randomString += possibleCharacters.charAt(Math.floor(Math.random() * possibleCharacters.length));
        }
        return randomString;
    }
}
AmexioCheckBoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-checkbox',
                template: `

    <div class="inputgroup form-group" >
        <label class="input-box-container" >{{fieldlabel}}
            <input type="checkbox"  [ngClass]="{'checkbox-disable' : disabled}" 
            [attr.checked]="value ? true: null" 
            (input)="onInput()" (click)="onClick()" [attr.disabled] = "disabled ? true: null" [required]="required">
            <span class="input-box-checkbox-label"></span>
          </label>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioCheckBoxComponent), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef(() => AmexioCheckBoxComponent), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioCheckBoxComponent.ctorParameters = () => [];
AmexioCheckBoxComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    disabled: [{ type: Input }],
    required: [{ type: Input }],
    onSelection: [{ type: Output }],
    input: [{ type: Output }],
    name: [{ type: Input, args: ['name',] }],
    isComponentValid: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class BaseInput extends ValueAccessorBase {
    /**
     * @param {?} event
     * @return {?}
     */
    onBaseInputFocus(event) {
        this.checkValidity();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBaseInput(event) {
        this.checkValidity();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBlur2(event) {
        this.checkValidity();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBaseInputChange(event) {
        this.checkValidity();
    }
    /**
     * @return {?}
     */
    checkValidity() {
    }
    /**
     * @return {?}
     */
    validateOnInit() {
        return true;
    }
    /**
     * @return {?}
     */
    isVali1d() {
        return true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class EventBaseComponent extends BaseInput {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} cd
     */
    constructor(renderer, element, cd) {
        super();
        this.renderer = renderer;
        this.element = element;
        this.cd = cd;
        this.self = false;
        this.itemClick = false;
        this.hide();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBaseFocusEvent(event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'visible' };
        this.bindDocumentClickListener();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBaseBlurEvent(event) {
        this.onBaseItemClicked();
        return false;
    }
    /**
     * @return {?}
     */
    onBaseItemClicked() {
        this.itemClick = true;
        this.hide();
        this.unbindDocumentClickListener();
        this.clearClicks();
    }
    /**
     * @return {?}
     */
    bindDocumentClickListener() {
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer
                .listen('document', 'click', (event) => this.handleDocumentListener(event));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleDocumentListener(event) {
        if (!this.self && !this.itemClick) {
            this.hide();
            this.unbindDocumentClickListener();
        }
        this.clearClicks();
        this.cd.markForCheck();
    }
    /**
     * @return {?}
     */
    clearClicks() {
        this.self = false;
        this.itemClick = false;
    }
    /**
     * @return {?}
     */
    unbindDocumentClickListener() {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    }
    /**
     * @return {?}
     */
    hide() {
        this.dropdownstyle = { visibility: 'hidden' };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class BaseFormValidator extends EventBaseComponent {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} _cd
     */
    constructor(renderer, element, _cd) {
        super(renderer, element, _cd);
        this.renderer = renderer;
        this.element = element;
        this._cd = _cd;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 1/12/17.
 */
class AmexioDropDownComponent extends BaseFormValidator {
    /**
     * @param {?} dataService
     * @param {?} element
     * @param {?} renderer
     * @param {?} _cd
     */
    constructor(dataService, element, renderer, _cd) {
        super(renderer, element, _cd);
        this.dataService = dataService;
        this.element = element;
        this.renderer = renderer;
        this.displayValue = '';
        this.filteredOptions = [];
        /*
          Events
          name : onBlur
          datatype : any
          version : 4.0 onwards
          default :
          description : 	On blur event
          */
        this.onBlur = new EventEmitter();
        /*
        Events
        name : input
        datatype : any
        version : none
        default :
        description : 	On input event field.
        */
        this.input = new EventEmitter();
        /*
        Events
        name : focus
        datatype : any
        version : none
        default :
        description : On field focus event
        */
        this.focus = new EventEmitter();
        /*
        Events
        name : onSingleSelect
        datatype : any
        version : none
        default :
        description : Fire when drop down item selected.
        */
        this.onSingleSelect = new EventEmitter();
        /*
        Events
        name : onMultiSelect
        datatype : any
        version :none
        default :
        description : Fire when multiple record select in drop down.this event is only
        applied when multi-select=true
        */
        this.onMultiSelect = new EventEmitter();
        /*
        Events
        name : onClick
        datatype : any
        version :none
        default :
        description : On record select event.this event is only for normal dropdown.
        */
        this.onClick = new EventEmitter();
        /*
        Properties
        name : place-holder
        datatype : string
        version : 4.0 onwards
        default :
        description : Show place-holder inside dropdown component*/
        this.placeholder = '';
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : flag to set label
        */
        this.haslabel = true;
        this.selectedindex = 0;
        this.multiselectValues = [];
        this.maskloader = true;
        this.scrollposition = 30;
        // The internal dataviews model
        this.isComponentValid = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.setData(this._data);
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    get errormsg() {
        return this._errormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set errormsg(value) {
        this.helpInfoMsg = value + '<br/>';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'dropdowninput');
        this.isValid = this.allowblank;
        this.isComponentValid.emit(this.allowblank);
        if (this.placeholder === '') {
            this.placeholder = 'Choose Option';
        }
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.responseData = response;
            }, (error) => {
            }, () => {
                this.setData(this.responseData);
            });
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        // Check if key is added?
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            this.multiselectValues = [];
            const /** @type {?} */ dr = this.datareader.split('.');
            if (dr) {
                for (const /** @type {?} */ ir of dr) {
                    responsedata = responsedata[ir];
                }
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.setResponseData(responsedata);
        this.multiSelection();
        this.setUserSelection();
        this.maskloader = false;
    }
    /**
     * @param {?} responsedata
     * @return {?}
     */
    setResponseData(responsedata) {
        if (responsedata) {
            this.viewData = responsedata.sort((a, b) => a[this.displayfield].toLowerCase()
                !== b[this.displayfield].toLowerCase() ?
                a[this.displayfield].toLowerCase() < b[this.displayfield].toLowerCase() ? -1 : 1 : 0);
            this.filteredOptions = this.viewData;
        }
    }
    /**
     * @return {?}
     */
    multiSelection() {
        if (this.multiselect) {
            let /** @type {?} */ preSelectedMultiValues = '';
            const /** @type {?} */ optionsChecked = [];
            this.viewData.forEach((row) => {
                if (row.hasOwnProperty('checked')) {
                    if (row.checked) {
                        optionsChecked.push(row[this.valuefield]);
                        this.multiselectValues.push(row);
                        preSelectedMultiValues === '' ? preSelectedMultiValues +=
                            row[this.displayfield] : preSelectedMultiValues += ',' + row[this.displayfield];
                    }
                }
                else {
                    row['checked'] = false;
                }
            });
            this.displayValue = this.setMultiSelect();
            this.onMultiSelect.emit(this.multiselectValues);
        }
    }
    /**
     * @return {?}
     */
    setUserSelection() {
        // Set user selection
        if (this.innerValue != null) {
            const /** @type {?} */ valueKey = this.valuefield;
            const /** @type {?} */ displayKey = this.displayfield;
            const /** @type {?} */ val = this.innerValue;
            if (this.viewData.length > 0) {
                this.viewData.forEach((item) => {
                    if (item[valueKey] === val) {
                        this.isValid = true;
                        this.isComponentValid.emit(true);
                        this.displayValue = item[displayKey];
                        this.onSingleSelect.emit(item);
                    }
                });
            }
        }
    }
    /**
     * @param {?} selectedItem
     * @return {?}
     */
    onItemSelect(selectedItem) {
        if (this.multiselect) {
            const /** @type {?} */ optionsChecked = [];
            this.multiselectValues = [];
            if (selectedItem.hasOwnProperty('checked')) {
                selectedItem.checked = !selectedItem.checked;
                this.filteredOptions.forEach((row) => {
                    if (row.checked) {
                        optionsChecked.push(row[this.valuefield]);
                        this.multiselectValues.push(row);
                    }
                });
                this.innerValue = optionsChecked;
                this.displayValue = this.setMultiSelect();
                this.onMultiSelect.emit(this.multiselectValues);
            }
        }
        else {
            this.value = selectedItem[this.valuefield]; // Issue here?
            this.displayValue = selectedItem[this.displayfield];
            this.multiselect ? this.showToolTip = true : this.showToolTip = false;
            this.onSingleSelect.emit(selectedItem);
        }
        this.isValid = true;
        this.isComponentValid.emit(true);
    }
    /**
     * @return {?}
     */
    setMultiSelectData() {
        this.multiselectValues = [];
        if (this.innerValue && this.innerValue.length > 0) {
            const /** @type {?} */ modelValue = this.innerValue;
            this.filteredOptions.forEach((test) => {
                modelValue.forEach((mdValue) => {
                    if (test[this.valuefield] === mdValue) {
                        if (test.hasOwnProperty('checked')) {
                            test.checked = true;
                        }
                        this.multiselectValues.push(test);
                    }
                });
            });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateKey(event) {
    }
    /**
     * @return {?}
     */
    getDisplayText() {
        if (this.innerValue != null || this.innerValue !== '') {
            if (this.multiselect) {
                this.displayValue = this.setMultiSelect();
            }
            else {
                this.displayValue = '';
                this.filteredOptions.forEach((test) => {
                    if (test[this.valuefield] === this.innerValue) {
                        this.displayValue = test[this.displayfield];
                    }
                });
                this.displayValue = this.displayValue === undefined ? '' : this.displayValue;
            }
        }
    }
    /**
     * @return {?}
     */
    setMultiSelect() {
        this.setMultiSelectData();
        let /** @type {?} */ multiselectDisplayString = '';
        this.multiselectValues.forEach((row) => {
            multiselectDisplayString === '' ? multiselectDisplayString +=
                row[this.displayfield] : multiselectDisplayString += ',' + row[this.displayfield];
        });
        if (this.multiselectValues.length > 0) {
            return multiselectDisplayString;
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        this.innerValue = event;
        this.isValid = true;
        this.getDisplayText();
        this.isComponentValid.emit(true);
    }
    /**
     * @param {?} input
     * @return {?}
     */
    onInput(input) {
        this.input.emit();
        this.isValid = input.valid;
        this.isComponentValid.emit(input.valid);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDropDownSearchKeyUp(event) {
        if (this.search) {
            const /** @type {?} */ keyword = event.target.value;
            if (keyword != null && keyword !== '' && keyword !== ' ') {
                this.filteredOptions = [];
                const /** @type {?} */ search_Term = keyword.toLowerCase();
                this.viewData.forEach((row) => {
                    if (row[this.displayfield].toLowerCase().startsWith(search_Term)) {
                        this.filteredOptions.push(row);
                    }
                });
            }
            if (keyword === '') {
                this.filteredOptions = this.viewData;
            }
        }
        if (event.keyCode === 8) {
            this.innerValue = '';
        }
        if (event.keyCode === 40 || event.keyCode === 38 || event.keyCode === 13) {
            this.navigateUsingKey(event);
        }
        this.onBaseFocusEvent({});
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateUsingKey(event) {
        if (this.selectedindex > this.filteredOptions.length) {
            this.selectedindex = 0;
        }
        if (event.keyCode === 40 || event.keyCode === 38 && this.selectedindex <
            this.filteredOptions.length) {
            this.navigateFilterOptions();
        }
        if (event.keyCode === 13 && this.filteredOptions[this.selectedindex]) {
            this.onItemSelect(this.filteredOptions[this.selectedindex]);
        }
    }
    /**
     * @return {?}
     */
    navigateFilterOptions() {
        if (!this.showToolTip) {
            this.showToolTip = true;
        }
        let /** @type {?} */ prevselectedindex = 0;
        if (this.selectedindex === 0) {
            this.selectedindex = 1;
        }
        else {
            prevselectedindex = this.selectedindex;
            this.scrollPositionIndex(event);
        }
        if (this.filteredOptions[this.selectedindex]) {
            this.filteredOptions[this.selectedindex].selected = true;
        }
        if (this.filteredOptions[prevselectedindex]) {
            this.filteredOptions[prevselectedindex].selected = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    scrollPositionIndex(event) {
        if (event.keyCode === 40) {
            this.selectedindex++;
            if ((this.selectedindex > 5)) {
                this.dropdownitems.nativeElement.scroll(0, this.scrollposition);
                this.scrollposition = this.scrollposition + 30;
            }
        }
        else if (event.keyCode === 38) {
            this.selectedindex--;
            if (this.scrollposition >= 0 && this.selectedindex > 1) {
                this.dropdownitems.nativeElement.scroll(0, this.scrollposition);
                this.scrollposition = this.scrollposition - 30;
            }
            if (this.selectedindex === 1) {
                this.scrollposition = 30;
            }
        }
    }
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v != null && v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onblur(event) {
        if (event.target && event.target.value && this.filteredOptions &&
            this.filteredOptions.length === 1) {
            const /** @type {?} */ fvalue = event.target.value;
            const /** @type {?} */ row = this.filteredOptions[0];
            const /** @type {?} */ rvalue = row[this.displayfield];
            if (fvalue && rvalue && (fvalue.toLowerCase() === rvalue.toLowerCase())) {
                this.onItemSelect(row);
            }
        }
        this.onTouchedCallback();
        this.onBaseBlurEvent(event);
        this.onBlur.emit();
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onFocus(elem) {
        this.onBaseFocusEvent(elem);
        this.showToolTip = true;
        this.posixUp = this.getListPosition(elem);
        this.focus.emit();
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        const /** @type {?} */ dropdownHeight = 325; // must be same in dropdown.scss
        if (window.screen.height - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value != null) {
            this.writeChangedValue(value);
        }
        else {
            this.innerValue = '';
            if (this.allowblank) {
                this.isValid = true;
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeChangedValue(value) {
        if (value !== this.innerValue) {
            let /** @type {?} */ status = false;
            if (this.viewData && this.viewData.length > 0) {
                this.viewData.forEach((item) => {
                    if (item[this.valuefield] === value) {
                        this.isValid = true;
                        this.displayValue = item[this.displayfield];
                        status = true;
                        return;
                    }
                });
            }
            if (!status) {
                this.displayValue = '';
            }
            this.value = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @return {?}
     */
    onIconClick() {
        if (!this.disabled) {
            this.onBaseFocusEvent({});
            this.showToolTip = !this.showToolTip;
        }
    }
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return ((!this.allowblank && (this.value || this.value === 0)) || this.allowblank) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioDropDownComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dropdown',
                template: `
    <div class="inputgroup" #rootDiv>

        <label *ngIf="haslabel" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
          {{fieldlabel}}
        </label>
  
        <input type="hidden"
               [ngModel]="value"
               (ngModelChange)="onChange($event)"
               #inp="ngModel"
        />
        <input type="text" class="input-control"
               [value]="displayValue"
               [ngClass]="{'input-control-error' : inp.invalid && (inp.dirty || inp.touched),'input-control-success' : inp.valid && (inp.dirty || inp.touched)}"
               (blur)="onblur($event)"
               (focus)="onFocus(rootDiv)"
               [attr.placeholder]="placeholder"
               [readonly]="readonly ? true : null"
               [attr.disabled]="disabled ? true: null"
               [required]="!allowblank" (keyup)="onDropDownSearchKeyUp($event)" (keydown)="navigateKey($event)"/>
  
  
        <span class="drodown-caret-down" (click)="onIconClick()">
          <amexio-form-icon key="dropdown_caret" *ngIf="!maskloader" ></amexio-form-icon>
          <em class="fa fa-spinner fa-spin" *ngIf="maskloader"></em>
        </span>
  
        <span #dropdownitems class="dropdown" [ngClass]="{'dropdown-up' : posixUp}" [ngStyle]="dropdownstyle">
              <ul class="dropdown-list">
  
                <li class="list-items" [ngClass]="{'list-items-selected':item.selected}" *ngFor="let item of filteredOptions" (mousedown)="onItemSelect(item)">
                  <ng-container *ngIf="bodyTemplate">
                    <ng-template [ngTemplateOutlet]="bodyTemplate" [ngTemplateOutletContext]="{ $implicit: { text : row }, row: item }">
                      </ng-template>
                    </ng-container>
                  <ng-container *ngIf="!bodyTemplate">
                    <span>{{item[displayfield]}}</span>
                  </ng-container>            <span style="float : right">{{item?.checked ? '&#10004;': ''}}</span>
                </li>
                 <ng-template *ngIf="filteredOptions && (filteredOptions.length < 1)">
                   <li class="list-items">No Options</li>
                 </ng-template>
              </ul>
            </span>
        <span class="inputfieldbar"></span>
      </div>
  
  
      <span *ngIf="iconfeedback && (inp.invalid && (inp.dirty || inp.touched) || inp.valid)"
            class="input-control-feedback">
              <span *ngIf="inp.invalid && (inp.dirty || inp.touched)">&#9888;</span>
              <span *ngIf="inp.valid && (inp.dirty || inp.touched)"> &#10004;</span>
  
      </span>
  
      <span *ngIf="showToolTip && enablepopover" class="tooltiptext">
              <div [innerHTML]="helpInfoMsg"></div>
      </span>
  
  
  
  
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioDropDownComponent), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef(() => AmexioDropDownComponent), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioDropDownComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
AmexioDropDownComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    data: [{ type: Input, args: ['data',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    search: [{ type: Input }],
    readonly: [{ type: Input }],
    multiselect: [{ type: Input, args: ['multi-select',] }],
    dropdownitems: [{ type: ViewChild, args: ['dropdownitems', { read: ElementRef },] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    onBlur: [{ type: Output }],
    input: [{ type: Output }],
    focus: [{ type: Output }],
    onSingleSelect: [{ type: Output }],
    onMultiSelect: [{ type: Output }],
    onClick: [{ type: Output }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    bodyTemplate: [{ type: ContentChild, args: ['amexioBodyTmpl',] }],
    isComponentValid: [{ type: Output }],
    name: [{ type: Input, args: ['name',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioLabelComponent {
    constructor() {
        this.enableclick = false;
        this.onClick = new EventEmitter();
        this.tempStyleArray = ['large', 'medium', 'small', 'bold', 'large-bold', 'medium-bold', 'small-bold',
            'large-44', 'large-24', 'large-50', 'large-54', 'large-56', 'large-60', 'large-64', 'large-68', 'large-78', 'large-9vw',
            'large-44-bold', 'large-50-bold', 'large-24-bold', 'large-4vw', 'large-4vw-bold',
            'large-54-bold', 'large-56-bold', 'large-60-bold', 'large-64-bold', 'large-68-bold', 'large-78-bold', 'large-9vw-bold'];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.styleClass == null) {
            this.styleClass = 'small';
        }
        else {
            this.styleClass = this.tempStyleArray.find((x) => x === this.styleClass);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onLabel(event) {
        if (this.enableclick) {
            this.onClick.emit(event);
        }
    }
}
AmexioLabelComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-label',
                template: `
  <label class="label-content {{styleClass}}" (click)="onLabel($event)"
    [ngStyle]="{'color' : fontColor,'cursor': enableclick ? 'pointer': 'text'}">
    <ng-content></ng-content>
    <span class="label-badge" *ngIf="badge">{{badge}}</span>
  </label>
  `,
            },] },
];
/** @nocollapse */
AmexioLabelComponent.ctorParameters = () => [];
AmexioLabelComponent.propDecorators = {
    badge: [{ type: Input, args: ['badge',] }],
    styleClass: [{ type: Input, args: ['size',] }],
    fontColor: [{ type: Input, args: ['font-color',] }],
    enableclick: [{ type: Input, args: ['enable-click',] }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioNumberInputComponent extends ValueAccessorBase {
    constructor() {
        super();
        this.isValid = false;
        /*
          Events
          name : onBlur
          datatype : any
          version : 4.0 onwards
          default :
          description : On blur event
          */
        this.onBlur = new EventEmitter();
        /*
         Events
         name : input
         datatype : any
         version : none
         default :
         description : 	On input event field.
         */
        this.input = new EventEmitter();
        /*
         Events
         name : focus
         datatype : any
         version : none
         default :
         description : On focus event field.
         */
        this.focus = new EventEmitter();
        /*
         Events
         name : change
         datatype : any
         version : none
         default :
         description : On field value change event
         */
        this.change = new EventEmitter();
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : true
        description : Flag to set label
        */
        this.haslabel = true;
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    get errormsg() {
        return this._errormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set errormsg(value) {
        this.helpInfoMsg = value + '<br/>';
    }
    /**
     * @return {?}
     */
    get minerrormsg() {
        return this._minerrormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set minerrormsg(value) {
        this.helpInfoMsg = this.helpInfoMsg + 'Min value: ' + value + '<br/>';
    }
    /**
     * @return {?}
     */
    get maxerrormsg() {
        return this._maxerrormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxerrormsg(value) {
        this.helpInfoMsg = this.helpInfoMsg + 'Max value: ' + value;
    }
    /**
     * @return {?}
     */
    get pattern() {
        return this._pattern;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set pattern(value) {
        if (value != null) {
            this.regEx = new RegExp(this.pattern);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'numberinput');
    }
    /**
     * @return {?}
     */
    onBlurEvent() {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.showToolTip = true;
        this.focus.emit(this.value);
    }
    /**
     * @return {?}
     */
    onInput() {
        this.isValid = this.isFieldValidate();
        this.input.emit(this.value);
    }
    /**
     * @return {?}
     */
    onChangeEv() {
        this.change.emit(this.value);
    }
    /**
     * @return {?}
     */
    isFieldValidate() {
        if (this.minvalue && !this.maxvalue) {
            return this.innerValue && (this.innerValue > this.minvalue);
        }
        else if (!this.minvalue && this.maxvalue) {
            return this.innerValue && (this.innerValue < this.maxvalue);
        }
        else if (!this.minvalue && !this.maxvalue && this.innerValue) {
            return true;
        }
        else {
            return this.innerValue && (this.innerValue > this.minvalue && this.innerValue < this.maxvalue);
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        const /** @type {?} */ isValid = (!this.allowblank && this.isFieldValidate()) || this.allowblank;
        return isValid ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioNumberInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-number-input',
                template: `



    <div class="inputgroup">

      <label *ngIf="haslabel" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
          {{fieldlabel}}
      </label>

      <input type="number" 
             class="input-control"
             [ngClass]="model.touched ? (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''"
             [(ngModel)]="value"
             (blur)="onBlurEvent()" 
             (focus)="onFocus()" 
             (input)="onInput()" 
             (change)="onChangeEv()"
             [name]="name" 
             [pattern]="regEx"
             [attr.placeholder]="placeholder" 
             [attr.max]="maxvalue" 
             [attr.min]="minvalue" 
             [attr.disabled]="disabled ? true: null"
             [required]="!allowblank" />


      <ng-container *ngIf="iconfeedback">
          <span class="input-control-feedback">
              <span *ngIf="!isValid && model.touched"><em class="fa fa-times"></em></span>
              <span *ngIf="isValid && model.touched"><em class="fa fa-check"></em></span>
          </span>
      </ng-container>


      <span *ngIf="showToolTip && enablepopover" class="dropdown tooltiptext">
          <div [innerHTML]="helpInfoMsg"></div>
      </span>
      <span class="inputfieldbar"></span>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioNumberInputComponent), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef(() => AmexioNumberInputComponent), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioNumberInputComponent.ctorParameters = () => [];
AmexioNumberInputComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    minvalue: [{ type: Input, args: ['min-value',] }],
    maxvalue: [{ type: Input, args: ['max-value',] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    minerrormsg: [{ type: Input, args: ['min-error-msg',] }],
    maxerrormsg: [{ type: Input, args: ['max-error-msg',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    minlength: [{ type: Input, args: ['min-length',] }],
    maxlength: [{ type: Input, args: ['max-length',] }],
    disabled: [{ type: Input }],
    onBlur: [{ type: Output }],
    input: [{ type: Output }],
    focus: [{ type: Output }],
    change: [{ type: Output }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    name: [{ type: Input, args: ['name',] }],
    pattern: [{ type: Input, args: ['pattern',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    model: [{ type: ViewChild, args: [NgModel,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioRadioGroupComponent extends ValueAccessorBase {
    /**
     * @param {?} amxHttp
     * @param {?} cd
     */
    constructor(amxHttp, cd) {
        super();
        this.amxHttp = amxHttp;
        this.cd = cd;
        /*
           Properties
           name : default-value
           datatype : string
           version : 4.0 onwards
           default :
           description : Default Value to be checked
           */
        this.defaultSelectedValue = '';
        /*
           Properties
           name : data
           datatype : any
           version : 4.0 onwards
           default :
           description : 	Local data for radio group.
           */
        this.data = [];
        /*
           Events
           name : onSelection
           datatype : any
           version : 4.0 onwards
           default :
           description : Fires selection event
           */
        this.onSelection = new EventEmitter();
        // Placeholders for the callbacks which are later provided
        // by the Control Value Accessor
        // private onTouchedCallback: () => void = noop;
        // private onChangeCallback: (_: any) => void = noop;
        this.isComponentValid = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'textinput');
        if (this.defaultSelectedValue) {
            this.value = this.defaultSelectedValue;
        }
        this.isValid = this.allowblank;
        this.isComponentValid.emit(this.allowblank);
        if (this.httpmethod && this.httpurl) {
            this.amxHttp.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.data = this.getResponseData(response);
            });
        }
        else if (this.data != null) {
            this.data = this.getResponseData(this.data);
        }
    }
    /**
     * @param {?} viewData
     * @return {?}
     */
    checkDefaultValidation(viewData) {
        viewData.forEach((opt) => {
            if (opt[this.valuefield] === this.innerValue || (opt.hasOwnProperty('selected') && opt.selected)) {
                this.isValid = true;
                this.isComponentValid.emit(true);
                return;
            }
        });
    }
    /**
     * @param {?} viewData
     * @return {?}
     */
    checkSelectedFlag(viewData) {
        viewData.forEach((opt) => {
            if (this.innerValue === '' && (opt.hasOwnProperty('selected') && opt.selected)) {
                this.value = opt[this.valuefield];
                return;
            }
        });
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getResponseData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            if (dr != null) {
                for (const /** @type {?} */ ir of dr) {
                    responsedata = responsedata[ir];
                }
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.checkSelectedFlag(responsedata);
        if (!this.allowblank) {
            this.checkDefaultValidation(responsedata);
        }
        return responsedata;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    onClick(row) {
        this.isValid = true;
        this.value = row[this.valuefield];
        this.isComponentValid.emit(true);
        this.onSelection.emit(row);
    }
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return ((!this.allowblank && this.value) || this.allowblank) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioRadioGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-radio-group',
                template: `
    <div class="inputgroup from-group">
      <div *ngIf="fieldlabel">
        <label>{{fieldlabel}}</label>
      </div>
      <ng-container *ngIf="horizontal">
        <ng-container *ngFor="let rData of data">
          <span class="input-box-container" style="padding-bottom:0px !important; margin: 5px !important" (click)="onClick(rData)" 
          [ngClass]="{'disable-component' : rData.disabled || disabled}">{{rData[displayfield]}}
            <input type="radio" [required]="!allowblank" [name]="name" 
            [value]="rData[valuefield]" [attr.disabled]="rData?.disabled ? true: null"
              [(ngModel)]="value" [checked]="(value === rData[valuefield])">
            <span class="input-box-radiobox-label"></span>
          </span>
        </ng-container>
      </ng-container>

      <ng-container *ngIf="!horizontal">
        <ng-container *ngFor="let rData of data">
          <div>
            <span class="input-box-container" style="padding-bottom:0px !important" (click)="onClick(rData)" [ngClass]="{'disable-component' : rData.disabled || disabled}">{{rData[displayfield]}}
              <input type="radio" [required]="!allowblank" [name]="name" [checked]="(value === rData[valuefield])" required
                [value]="rData[valuefield]" [attr.disabled]="rData?.disabled ? true: null" [(ngModel)]="value">
              <span class="input-box-radiobox-label"></span>
            </span>
          </div>
        </ng-container>
      </ng-container>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioRadioGroupComponent), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: AmexioRadioGroupComponent, multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioRadioGroupComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: ChangeDetectorRef }
];
AmexioRadioGroupComponent.propDecorators = {
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    name: [{ type: Input }],
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    defaultSelectedValue: [{ type: Input, args: ['default-value',] }],
    horizontal: [{ type: Input }],
    data: [{ type: Input }],
    disabled: [{ type: Input }],
    onSelection: [{ type: Output }],
    isComponentValid: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioRatingComponent {
    constructor() {
        /*
          Properties
          name : icon-class
          datatype : string
          version : 4.0 onwards
          default : star-icon
          description : Sets if custom icon class is required
          */
        this.iconclass = 'star-icon';
        /*
          Properties
          name : full-icon
          datatype : string
          version : 4.0 onwards
          default :
          description : 	Icon for selected rating .This attribute is useful only
          when user have custom rating icons.example
          */
        this.fullicon = 'â';
        /*
          Properties
          name : empty-icon
          datatype : string
          version : 4.0 onwards
          default :
          description : Icon for non-selected rating .This attribute is useful only
          when user have custom rating icons.example
          */
        this.emptyicon = 'â';
        /*
          Properties
          name : titles
          datatype : string array
          version : 4.0 onwards
          default : 1,2,3..
          description : Array of titles
          */
        this.titles = [];
        // -------------------------------------------------------------------------
        // Outputs
        // -------------------------------------------------------------------------
        /*
          Events
          name : onHover
          datatype : any
          version : 4.0 onwards
          default :
          description : Fires on hovering component
          */
        this.onHover = new EventEmitter();
        /*
          Events
          name : onLeave
          datatype : any
          version : 4.0 onwards
          default :
          description : fires on leaving component and returns its value
          */
        this.onLeave = new EventEmitter();
        this.hovered = 0;
        this.hoveredPercent = undefined;
        this._max = 5;
    }
    /**
     * @param {?} max
     * @return {?}
     */
    set max(max) {
        this._max = max;
        this.buildRanges();
    }
    /**
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        if (this.required && !c.value) {
            return {
                required: true,
            };
        }
        return null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.buildRanges();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    calculateWidth(item) {
        if (this.hovered > 0) {
            if (this.hoveredPercent !== undefined && this.hovered === item) {
                return this.hoveredPercent;
            }
            else {
                return this.hovered >= item ? 100 : 0;
            }
        }
        else {
            return this.model >= item ? 100 : 100 - Math.round((item - this.model) * 10) * 10;
        }
    }
    /**
     * @param {?} hovered
     * @return {?}
     */
    setHovered(hovered) {
        if (!this.readonly && !this.disabled) {
            this.hovered = hovered;
            this.onHover.emit(hovered);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    changeHovered(event) {
        if (!this.float) {
            return;
        }
        const /** @type {?} */ target = /** @type {?} */ (event.target);
        const /** @type {?} */ relativeX = event.pageX - target.offsetLeft;
        const /** @type {?} */ percent = Math.round((relativeX * 100 / target.offsetWidth) / 10) * 10;
        this.hoveredPercent = percent > 50 ? 100 : 50;
    }
    /**
     * @return {?}
     */
    resetHovered() {
        this.hovered = 0;
        this.hoveredPercent = undefined;
        this.onLeave.emit(this.hovered);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    rate(value) {
        if (!this.readonly && !this.disabled && value >= 0 && value <= this.ratingRange.length) {
            const /** @type {?} */ newValue = this.hoveredPercent ? (value - 1) + this.hoveredPercent / 100 : value;
            this.model = newValue;
        }
    }
    /**
     * @return {?}
     */
    buildRanges() {
        this.ratingRange = this.range(1, this.max);
    }
    /**
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    range(start, end) {
        const /** @type {?} */ foo = [];
        for (let /** @type {?} */ i = start; i <= end; i++) {
            foo.push(i);
        }
        return foo;
    }
}
AmexioRatingComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-rating-input',
                template: `
    <div class="inputgroup">
        <ng-container *ngIf="fieldlabel">
            <label>
              {{fieldlabel}}
            </label>
        </ng-container>


        <div (mouseleave)="resetHovered()" class="rating" [class.disabled]="disabled" [class.readonly]="readonly" tabindex="0" role="slider" aria-valuemin="0" [attr.aria-valuemax]="ratingRange.length" [attr.aria-valuenow]="model">
            <span *ngFor="let item of ratingRange; let index = index">
              <em (mouseenter)="setHovered(item)"
                 (mousemove)="changeHovered($event)"
                 (click)="rate(item)"
                 [attr.data-icon]="fullicon"
                 class="{{ iconclass }} half{{ calculateWidth(item) }}"
                 [title]="titles[index] || item">{{ emptyicon }}</em>
          </span>
        </div>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => AmexioRatingComponent),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => AmexioRatingComponent),
                        multi: true,
                    },
                ],
            },] },
];
AmexioRatingComponent.propDecorators = {
    iconclass: [{ type: Input, args: ['icon-class',] }],
    fullicon: [{ type: Input, args: ['full-icon',] }],
    emptyicon: [{ type: Input, args: ['empty-icon',] }],
    readonly: [{ type: Input, args: ['read-only',] }],
    disabled: [{ type: Input }],
    required: [{ type: Input }],
    float: [{ type: Input }],
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    titles: [{ type: Input }],
    max: [{ type: Input }],
    onHover: [{ type: Output }],
    onLeave: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioTextInputComponent extends ValueAccessorBase {
    constructor() {
        super();
        /*
        Properties
        name : icon-feedback
        datatype : boolean
        version : 4.0 onwards
        default :false
        description :
        */
        this.iconfeedback = false;
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : Flag to set label
        */
        this.haslabel = true;
        this.isValid = false;
        /*
         Events
         name : onBlur
         datatype : any
         version : 4.0 onwards
         default :
         description : On blur event
         */
        this.onBlur = new EventEmitter();
        /*
        Events
        name : input
        datatype : any
        version : none
        default :
        description :   On input event field.
        */
        this.input = new EventEmitter();
        /*
        Events
        name : focus
        datatype : any
        version : none
        default :
        description : On focus event field.
        */
        this.focus = new EventEmitter();
        /*
        Events
        name : change
        datatype : any
        version : none
        default :
        description : On field value change event
        */
        this.change = new EventEmitter();
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    get errormsg() {
        return this._errormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set errormsg(value) {
        this.helpInfoMsg = value + '<br/>';
    }
    /**
     * @return {?}
     */
    get minerrormsg() {
        return this._minerrormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set minerrormsg(value) {
        this.helpInfoMsg = this.helpInfoMsg + '<b>Min Length<b/>: ' + value + '<br/>';
    }
    /**
     * @return {?}
     */
    get maxerrormsg() {
        return this._maxerrormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxerrormsg(value) {
        this.helpInfoMsg = this.helpInfoMsg + 'Max Length: ' + value;
    }
    /**
     * @return {?}
     */
    get pattern() {
        return this._pattern;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set pattern(value) {
        if (value != null) {
            this._pattern = value;
            this.regEx = new RegExp(this._pattern);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'textinput');
    }
    /**
     * @return {?}
     */
    onBlurEvent() {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    }
    /**
     * @return {?}
     */
    onFocusEvent() {
        this.showToolTip = true;
        this.focus.emit(this.value);
    }
    /**
     * @return {?}
     */
    onInput() {
        this.isValid = this.isFieldValid();
        this.input.emit(this.value);
    }
    /**
     * @return {?}
     */
    onChangeEv() {
        this.change.emit(this.value);
    }
    /**
     * @return {?}
     */
    isFieldValid() {
        let /** @type {?} */ valid;
        valid = (!this.allowblank && (this.value && ((this.value.length >= this.minlength) && this.value.length > 0)) ||
            (!this.minlength && this.value && this.value.length > 0)) || this.allowblank;
        return valid;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.isFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioTextInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-text-input',
                template: `
    <div class="inputgroup">

        <label *ngIf="haslabel" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
          {{fieldlabel}}
      </label>
        <input type="text" #inp="ngModel"  class="input-control" [ngClass]="inp.touched ? (isValid && inp.touched) ? 'input-control-success' : 'input-control-error' :''" [(ngModel)]="value" (blur)="onBlurEvent()" (focus)="onFocusEvent()" (input)="onInput()" (change)="onChangeEv()"
            [name]="name" [pattern]="regEx" [attr.placeholder]="placeholder" [maxlength]="maxlength" [minlength]="minlength" [attr.disabled]="disabled ? true: null" [required]="!allowblank" />


        <ng-container *ngIf="iconfeedback">
            <span class="input-control-feedback">
              <span *ngIf="!isValid && inp.touched"><em class="fa fa-times"></em></span>
            <span *ngIf="isValid && inp.touched"><em class="fa fa-check"></em></span>
            </span>
        </ng-container>


        <span *ngIf="showToolTip && enablepopover" class="dropdown tooltiptext">
          <div [innerHTML]="helpInfoMsg"></div>
      </span>
        <span class="inputfieldbar"></span>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioTextInputComponent), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef(() => AmexioTextInputComponent), multi: true,
                    }],
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
AmexioTextInputComponent.ctorParameters = () => [];
AmexioTextInputComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    minlength: [{ type: Input, args: ['min-length',] }],
    maxlength: [{ type: Input, args: ['max-length',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    minerrormsg: [{ type: Input, args: ['min-error-msg',] }],
    maxerrormsg: [{ type: Input, args: ['max-error-msg',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    pattern: [{ type: Input, args: ['pattern',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    model: [{ type: ViewChild, args: [NgModel,] }],
    name: [{ type: Input, args: ['name',] }],
    onBlur: [{ type: Output }],
    input: [{ type: Output }],
    focus: [{ type: Output }],
    change: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const noop$6 = () => {
};
class AmexioToggleComponent extends AmexioFormValidator {
    constructor() {
        super();
        this.onChange = new EventEmitter();
        this.isComponentValid = new EventEmitter();
        this.innerValue = '';
        this.onTouchedCallback = noop$6;
        this.onChangeCallback = noop$6;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.shape === '' || this.shape == null) {
            this.shape = 'round';
        }
        this.isValid = !this.required;
        this.isComponentValid.emit(false);
    }
    /**
     * @return {?}
     */
    onToggle() {
        this.isValid = this.value;
        this.isComponentValid.emit(this.value);
        this.onChange.emit(this.value);
    }
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.onTouchedCallback();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value && value !== this.innerValue) {
            this.isValid = value;
        }
        if (!value && value !== this.innerValue) {
            this.isValid = value;
        }
        this.innerValue = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return ((this.required && this.value) || !this.required) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-toggle',
                template: `
    <div class="inputgroup ">

    <label>{{fieldlabel}}</label>
    <label class="toggle">
      <input type="checkbox" checked
             [name]="value"
             #rangeHndl
             (blur)="onBlur()"
             [(ngModel)]="value"
             (change)="onToggle()">
      <span class="toggle-slider {{shape}}"></span>
    </label>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioToggleComponent), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef(() => AmexioToggleComponent), multi: true,
                    }],
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
AmexioToggleComponent.ctorParameters = () => [];
AmexioToggleComponent.propDecorators = {
    shape: [{ type: Input }],
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    required: [{ type: Input }],
    onChange: [{ type: Output }],
    isComponentValid: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*****
 * Created by pratik on 18/12/17.

 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 ****/
class AmexioImageComponent {
    constructor() {
        /*
        Properties
        name : c-class
        datatype :  string
        version : 4.0 onwards
        default :
        description : Used for custom style classes
        */
        this.cclass = '';
        /*
        Events
        name : onClick
        datatype :  none
        version : none
        default : none
        description : Get image / icon click event.
        */
        this.onClick = new EventEmitter();
        this.overlay = false;
        this.imageCss = ' image-';
        this.overlayTextCss = 'overlay-text overlay-';
        this.textCss = '-text';
        this.imgFluidCss = ' img-fluid';
        this.overlayOverlayCss = 'overlay overlay-';
        this.imageTitleCss = 'image-title image-';
        this.imageTitleBottomCss = 'image-title image-bottom-right';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onImageClick(event) {
        this.onClick.emit(event);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!(this.width || this.height)) {
            this.cclass = this.cclass + this.imgFluidCss;
        }
        if (this.filter) {
            this.cclass = this.cclass + this.imageCss + this.filter;
        }
        if (this.overlayEffect) {
            this.overlay = true;
            if (!this.overlayText) {
                this.overlayText = '';
            }
            if (this.overlayText) {
                this.overlayTextClass = this.overlayTextCss + this.overlayEffect + this.textCss;
            }
            this.overlayEffect = this.overlayOverlayCss + this.overlayEffect;
        }
        if (this.position && !this.imgTitle) {
            this.imgTitle = '';
        }
        if (this.imgTitle) {
            if (this.position) {
                this.position = this.imageTitleCss + this.position;
            }
            else {
                this.position = this.imageTitleBottomCss;
            }
        }
    }
}
AmexioImageComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-image', template: `
    <!--Normal image-->
    <ng-container *ngIf="iconclass && (!path && !mda) && overlay || overlayText || titlePara || imgTitle ">
    <div class="img-container">
      <ng-container *ngIf="path || (path && iconclass)">
        <ng-container *ngIf="!(width || height)">
          <img alt="title" [src]="path" [attr.class]="cclass" (click)="onImageClick($event)" [attr.title]="tooltip">
          <div *ngIf="overlay" [ngClass]="overlayEffect">
            <div *ngIf="overlayText" [ngClass]="overlayTextClass">{{overlayText}}
              <p *ngIf="titlePara">{{titlePara}}</p>
            </div>
          </div>
          <div *ngIf="imgTitle" [ngClass]="position">{{imgTitle}}</div>
        </ng-container>
        <ng-container *ngIf="width || height">
          <img alt="title" [ngStyle]="{'width':width,'height':height}" [attr.class]="cclass" [src]="path" (click)="onImageClick($event)" [attr.title]="tooltip">
           <div *ngIf="overlay" [ngClass]="overlayEffect">
            <div *ngIf="overlayText" [ngClass]="overlayTextClass">{{overlayText}}
              <p *ngIf="titlePara">{{titlePara}}</p>
            </div>
          </div>
          <div *ngIf="imgTitle" [ngClass]="position">{{imgTitle}}</div>
        </ng-container>
      </ng-container>
      </div>
    </ng-container>



    <ng-container *ngIf="!(iconclass && (!path && !mda) && overlay || overlayText || titlePara || imgTitle )">
        <ng-container *ngIf="path || (path && iconclass)">
        <ng-container *ngIf="!(width || height)">
        <img alt="title" [src]="path" [attr.class]="cclass" (click)="onImageClick($event)" [attr.title]="tooltip">
        </ng-container>
        <ng-container *ngIf="width || height">
        <img alt="title" [ngStyle]="{'width':width,'height':height}" [attr.class]="cclass" [src]="path" (click)="onImageClick($event)" [attr.title]="tooltip">
        </ng-container>
        </ng-container>
        </ng-container>
    
    <!--this is for fontawesome-->
    <ng-container *ngIf="iconclass && (!path && !mda)">
      <em [attr.class]="iconclass" [attr.title]="tooltip" (click)="onImageClick($event)"></em>
      <label class="image-title" *ngIf="title" (click)="onImageClick($event)" style="cursor: pointer">{{title}}</label>
    </ng-container>

    <!--Material icon-->
    <ng-container *ngIf="(iconclass && mda) && !path">
      <em [attr.class]="iconclass" [attr.title]="tooltip" (click)="onImageClick($event)">{{mda}}</em>
    </ng-container>

    <ng-container *ngIf=" title && !iconclass">
      <span style="font-size: medium">{{title}}</span>
    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioImageComponent.ctorParameters = () => [];
AmexioImageComponent.propDecorators = {
    tooltip: [{ type: Input }],
    title: [{ type: Input }],
    path: [{ type: Input }],
    iconclass: [{ type: Input, args: ['icon-class',] }],
    cclass: [{ type: Input, args: ['c-class',] }],
    mda: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    onClick: [{ type: Output }],
    filter: [{ type: Input, args: ['filter',] }],
    overlayEffect: [{ type: Input, args: ['overlay-effect',] }],
    overlayText: [{ type: Input, args: ['overlay-text',] }],
    imgTitle: [{ type: Input, args: ['image-title',] }],
    position: [{ type: Input, args: ['title-position',] }],
    titlePara: [{ type: Input, args: ['para',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioTabActionComponent {
    constructor() {
        this.showContent = false;
        this.actionComponent = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    checkActionComponent() {
        this.textinput = this.queryTextinput.toArray();
        if (this.textinput.length > 0) {
            this.actionComponent = 'text';
            this.textinput[0].haslabel = false;
            this.textinput[0].iconfeedback = false;
        }
        this.checkbox = this.queryCheckbox.toArray();
        if (this.checkbox.length > 0) {
            this.actionComponent = 'checkbox';
            this.checkbox[0].fieldlabel = '';
        }
        this.radioGroup = this.queryRadioGroup.toArray();
        if (this.radioGroup.length > 0) {
            this.actionComponent = 'radiogroup';
            this.radioGroup[0].fieldlabel = '';
            this.radioGroup[0].horizontal = true;
        }
        this.label = this.queryLabel.toArray();
        if (this.label.length > 0) {
            this.actionComponent = 'label';
        }
        this.number = this.queryNumber.toArray();
        if (this.number.length > 0) {
            this.actionComponent = 'number';
            this.number[0].fieldlabel = '';
        }
        this.rating = this.queryRating.toArray();
        if (this.rating.length > 0) {
            this.actionComponent = 'rating';
            this.rating[0].fieldlabel = '';
        }
        this.toggle = this.queryToggle.toArray();
        if (this.toggle.length > 0) {
            this.actionComponent = 'toggle';
            this.toggle[0].fieldlabel = '';
        }
        this.button = this.queryButton.toArray();
        if (this.button.length > 0) {
            this.actionComponent = 'button';
        }
        this.image = this.queryImage.toArray();
        if (this.image.length > 0) {
            this.actionComponent = 'image';
        }
        this.dropdown = this.queryDropDown.toArray();
        if (this.dropdown.length > 0) {
            this.actionComponent = 'dropdown';
            this.dropdown[0].fieldlabel = '';
        }
        this.checkboxgroup = this.queryCheckBoxGroup.toArray();
        if (this.checkboxgroup.length > 0) {
            this.actionComponent = 'checkboxgroup';
            this.checkboxgroup[0].fieldlabel = '';
            this.checkboxgroup[0].horizontal = true;
        }
    }
}
AmexioTabActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tab-action',
                template: `
   <ng-content></ng-content>
   `,
            },] },
];
/** @nocollapse */
AmexioTabActionComponent.ctorParameters = () => [];
AmexioTabActionComponent.propDecorators = {
    queryTextinput: [{ type: ContentChildren, args: [AmexioTextInputComponent, { descendants: true },] }],
    queryCheckbox: [{ type: ContentChildren, args: [AmexioCheckBoxComponent, { descendants: true },] }],
    queryRadioGroup: [{ type: ContentChildren, args: [AmexioRadioGroupComponent, { descendants: true },] }],
    queryLabel: [{ type: ContentChildren, args: [AmexioLabelComponent, { descendants: true },] }],
    queryNumber: [{ type: ContentChildren, args: [AmexioNumberInputComponent, { descendants: true },] }],
    queryRating: [{ type: ContentChildren, args: [AmexioRatingComponent, { descendants: true },] }],
    queryToggle: [{ type: ContentChildren, args: [AmexioToggleComponent, { descendants: true },] }],
    queryButton: [{ type: ContentChildren, args: [AmexioButtonComponent, { descendants: true },] }],
    queryImage: [{ type: ContentChildren, args: [AmexioImageComponent, { descendants: true },] }],
    queryDropDown: [{ type: ContentChildren, args: [AmexioDropDownComponent, { descendants: true },] }],
    queryCheckBoxGroup: [{ type: ContentChildren, args: [AmexioCheckBoxGroupComponent, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/1/17.
 */
const TOP_COMPONENT_CLASS_MAP = {
    red: 'amexio-top-tab-red',
    green: 'amexio-top-tab-green',
    purple: 'amexio-top-tab-purple',
    blue: 'amexio-top-tab-blue',
    brown: 'amexio-top-tab-brown',
    yellow: 'amexio-top-tab-yellow',
    black: 'amexio-top-tab-black',
    pink: 'amexio-top-tab-pink',
    orange: 'amexio-top-tab-orange',
};
const BOTTOM_COMPONENT_CLASS_MAP = {
    red: 'amexio-bottom-tab-red',
    green: 'amexio-bottom-tab-green',
    purple: 'amexio-bottom-tab-purple',
    blue: 'amexio-bottom-tab-blue',
    brown: 'amexio-bottom-tab-brown',
    yellow: 'amexio-bottom-tab-yellow',
    black: 'amexio-bottom-tab-black',
    pink: 'amexio-bottom-tab-pink',
    orange: 'amexio-bottom-tab-orange',
};
class AmexioTabComponent {
    /**
     * @param {?} render
     * @param {?} componentFactoryResolver
     * @param {?} renderer
     */
    constructor(render, componentFactoryResolver, renderer) {
        this.render = render;
        this.componentFactoryResolver = componentFactoryResolver;
        this.renderer = renderer;
        /*
           Properties
           name :  context-menu
           datatype : string
           version : 5.0.1 onwards
           default :
           description : Context Menu provides the list of menus on right click.
           */
        this.contextmenu = [];
        /*
           Events
           name : rightClick
           datatype : none
           version : 5.0.1
           default : none
           description : It will gives you row clicked data.
           */
        this.rightClick = new EventEmitter();
        /*
           Events
           name : onClick
           datatype : none
           version : none
           default : none
           description : Callback to invoke on activated tab event.
           */
        this.onClick = new EventEmitter();
        this.showprev = false;
        this.shownext = false;
        this.mouseLocation = { left: 0, top: 0 };
        this.closeOthersConst = 'Close Others';
        this.dummyArray = [];
        this.tabPositionClass = '';
        this.componentId = '';
        this.map = new Map();
        this.headeralign = 'left';
        this.typeActionAlign = 'left';
        this.tabPosition = 'top';
        this.fullPageTabs = false;
        this.action = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set tabLocalData(value) {
        this._tabLocalData = value;
        if (this.componentLoaded) {
            this.updateTabComponent();
        }
    }
    /**
     * @return {?}
     */
    get tabLocalData() {
        return this._tabLocalData;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentLoaded = true;
        this.componentId = Math.floor(Math.random() * 90000) + 10000 + '_tabc';
    }
    /**
     * @return {?}
     */
    updateTabComponent() {
        if (this.tabs.nativeElement.scrollWidth > this.tabs.nativeElement.clientWidth) {
            this.headeralign = 'left';
        }
        this.adjustWidth();
        if (this.tabs && this.tabs.nativeElement
            && this.headerWidth && this.headerWidth.nativeElement
            && this.tabAction && this.tabAction.nativeElement
            && this.tabWidth1 !== this.tabs.nativeElement.offsetWidth) {
            this.headWidth = (this.tabAction.nativeElement.scrollWidth + this.headerWidth.nativeElement.scrollWidth);
            this.widthTabs = this.tabs.nativeElement.offsetWidth - this.headWidth;
        }
        if (JSON.stringify(this.tabPreviewData) !== JSON.stringify(this.tabLocalData)) {
            this.tabPreviewData = JSON.parse(JSON.stringify(this.tabLocalData));
            this.tabCollection = this.tabLocalData;
        }
        this.tabPositionClass = this.findTabStyleClass();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.tabWidth1 = this.tabs.nativeElement.offsetWidth;
        this.totalTabs = this.tabCollection.length;
        setTimeout(() => {
            this.updateTabComponent();
        }, 500);
    }
    /**
     * @return {?}
     */
    adjustWidth() {
        const /** @type {?} */ tWidth = this.tabs.nativeElement.clientWidth;
        const /** @type {?} */ tlistWidth = this.tabslist.nativeElement.scrollWidth;
        const /** @type {?} */ hWidth = 0;
        const /** @type {?} */ totalElWidth = tlistWidth + hWidth;
        if (totalElWidth > tWidth) {
            this.shownext = true;
        }
        else {
            this.shownext = false;
        }
        if (this.fullPageTabs === true) {
            if (totalElWidth > tWidth && this.fullPageTabs) {
                this.shownext = true;
            }
            else {
                this.singleTabWidth = totalElWidth / this.totalTabs;
            }
        }
        this.onAdjustHeight();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.tabLocalData && this.tabLocalData.length > 0) {
            this.tabPreviewData = JSON.parse(JSON.stringify(this.tabLocalData));
            this.tabCollection = this.tabLocalData;
        }
        else {
            this.tabCollection = [];
            this.tabCollection = this.queryTabs.toArray();
        }
        this.tabNodeProperties();
        // To add action in tab
        this.actionComp = this.queryAction.toArray();
        if (this.actionComp.length > 0) {
            this.actionComp[0].checkActionComponent();
        }
        this.tabPositionClass = this.findTabStyleClass();
    }
    /**
     * @param {?} title
     * @param {?} amexiocolor
     * @param {?} closable
     * @param {?} component
     * @return {?}
     */
    addDynamicTab(title, amexiocolor, closable, component) {
        // get a component factory for our TabComponent
        const /** @type {?} */ tpCF = this.componentFactoryResolver.resolveComponentFactory(AmexioTabPillComponent);
        const /** @type {?} */ tp = this.target.createComponent(tpCF);
        // set the according properties on our component instance
        const /** @type {?} */ instance = /** @type {?} */ (tp.instance);
        instance.title = title;
        instance.active = true;
        instance.closable = closable;
        instance['tabpillinstance'] = this.target;
        if (instance.amexiocolor === '') {
            instance.amexiocolor = 'amexio-top-tab-black';
        }
        else {
            instance.amexiocolor = 'amexio-top-tab-' + amexiocolor;
        }
        // create dynamic component
        const /** @type {?} */ dynCF = this.componentFactoryResolver.resolveComponentFactory(component);
        const /** @type {?} */ dynCmp = tp.instance.target.createComponent(dynCF);
        // Push new tab and select it.
        this.dummyArray.push(tp);
        this.tabCollection.push(tp.instance);
        this.selectTab(tp.instance);
        this.adjustWidth();
        return dynCmp.instance;
    }
    /**
     * @return {?}
     */
    closeAllTabs() {
        this.tabCollection.forEach((tabs) => {
            if (tabs.closable === true || this.closable === true) {
                this.closeTab(tabs);
            }
        });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    closeTabs(data) {
        const /** @type {?} */ tabList = [];
        this.tabCollection.forEach((tabs) => {
            tabs.active = false;
            data.forEach((opt) => {
                if (opt.toLowerCase() !== tabs.title.toLowerCase() && (tabs.closable === true || this.closable === true)) {
                    this.closeTab(tabs);
                }
                else {
                    tabList.push(tabs);
                    this.asignTabPillClass(tabs);
                }
            });
        });
        tabList[tabList.length - 1].active = true;
        this.asignTabPillClass(tabList[tabList.length - 1]);
    }
    /**
     * @param {?} input
     * @return {?}
     */
    setActiveTab(input) {
        let /** @type {?} */ flag = false;
        if (typeof input === 'string') {
            this.tabCollection.forEach((tabs) => {
                tabs.tabPillClass = '';
                if (input.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                    tabs.active = true;
                    flag = true;
                }
                else {
                    tabs.active = false;
                }
                this.asignTabPillClass(tabs);
            });
        }
        else if (typeof input === 'number') {
            this.tabCollection.forEach((tabs, index) => {
                tabs.tabPillClass = '';
                if (index + 1 === input) {
                    tabs.active = true;
                    flag = true;
                }
                else {
                    tabs.active = false;
                }
                this.asignTabPillClass(tabs);
            });
        }
        return flag;
    }
    /**
     * @param {?} disabledTabInput
     * @return {?}
     */
    setDisableTabs(disabledTabInput) {
        const /** @type {?} */ flag = false;
        if (disabledTabInput.length > 0) {
            disabledTabInput.forEach((ele) => {
                if (typeof ele === 'string') {
                    this.disableTabByString(flag, ele);
                }
                else if (typeof ele === 'number') {
                    this.disableTabByNumber(flag, ele);
                }
            });
        }
        return flag;
    }
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    disableTabByString(flag, ele) {
        this.tabCollection.forEach((tabs) => {
            tabs.tabPillClass = '';
            if (ele.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                tabs.disabled = true;
                flag = true;
            }
            this.asignTabPillClass(tabs);
        });
    }
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    disableTabByNumber(flag, ele) {
        this.tabCollection.forEach((tabs, index) => {
            tabs.tabPillClass = '';
            if (index + 1 === ele) {
                tabs.active = true;
                flag = true;
            }
            else {
                tabs.active = false;
            }
            this.asignTabPillClass(tabs);
        });
    }
    /**
     * @param {?} disabledTabInput
     * @return {?}
     */
    setEnableTabs(disabledTabInput) {
        const /** @type {?} */ flag = false;
        if (disabledTabInput.length > 0) {
            disabledTabInput.forEach((ele) => {
                if (typeof ele === 'string') {
                    this.enableTabByString(flag, ele);
                }
                else if (typeof ele === 'number') {
                    this.enableTabByNumber(flag, ele);
                }
            });
        }
        return flag;
    }
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    enableTabByString(flag, ele) {
        this.tabCollection.forEach((tabs) => {
            tabs.tabPillClass = '';
            if (ele.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                tabs.disabled = false;
                flag = true;
            }
            this.asignTabPillClass(tabs);
        });
    }
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    enableTabByNumber(flag, ele) {
        this.tabCollection.forEach((tabs, index) => {
            tabs.tabPillClass = '';
            if (index + 1 === ele) {
                tabs.disabled = false;
                flag = true;
            }
            this.asignTabPillClass(tabs);
        });
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    selectTab(tab) {
        // deactivate all tabs
        this.tabCollection.forEach((tab1) => {
            tab1.active = false;
        });
        tab.active = true;
        this.tabCollection.forEach((tab1) => {
            this.asignTabPillClass(tab1);
        });
    }
    /**
     * @return {?}
     */
    tabNodeProperties() {
        const /** @type {?} */ tabWidth = this.tabCollection.length;
        for (let /** @type {?} */ i = 0; i < tabWidth; i++) {
            if (this.tabPosition === 'top') {
                this.tabCollection[i].amexiocolor = TOP_COMPONENT_CLASS_MAP[this.tabCollection[i].amexiocolor];
            }
            else {
                this.tabCollection[i].amexiocolor = BOTTOM_COMPONENT_CLASS_MAP[this.tabCollection[i].amexiocolor];
            }
            if (this.closable) {
                if (this.tabCollection[i].closable === null || this.tabCollection[i].closable === true) {
                    this.tabCollection[i].closable = true;
                }
                else if (this.tabCollection[i].closable === false) {
                    this.tabCollection[i].closable = false;
                }
            }
            this.asignTabPillClass(this.tabCollection[i]);
        }
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    onTabClick(tab) {
        if (!tab.disabled && !tab.header) {
            for (const /** @type {?} */ i of this.tabCollection) {
                if (i === tab) {
                    i['active'] = true;
                    this.asignTabPillClass(tab);
                    this.onClick.emit(tab);
                }
                else {
                    i['active'] = false;
                    i['tabPillClass'] = '';
                }
            }
            this.tabCollection.forEach((tab1) => {
                this.asignTabPillClass(tab1);
            });
        }
    }
    /**
     * @return {?}
     */
    next() {
        const /** @type {?} */ nxt = this.tabs.nativeElement;
        nxt.scrollLeft = nxt.scrollLeft + 200;
        if ((nxt.scrollWidth - nxt.offsetWidth - nxt.scrollLeft) <= 0) {
            this.shownext = false;
        }
        this.showprev = true;
    }
    /**
     * @return {?}
     */
    previous() {
        const /** @type {?} */ prev = this.tabs.nativeElement;
        prev.scrollLeft = prev.scrollLeft - 200;
        if (prev.scrollLeft === 0) {
            this.showprev = false;
        }
        this.shownext = true;
    }
    /**
     * @param {?} tabNode
     * @return {?}
     */
    closeTab(tabNode) {
        const /** @type {?} */ newTab = [];
        let /** @type {?} */ index = 0;
        let /** @type {?} */ tabHighlightIndex = 0;
        this.tabCollection.forEach((tab, i) => {
            tab.active = false;
            if (tab.tabId === tabNode.tabId) {
                tabHighlightIndex = index;
                if (tab.hasOwnProperty('tabpillinstance')) {
                    tab.target.remove();
                }
                else {
                    const /** @type {?} */ removeNode = document.getElementById(tab.tabId).parentNode;
                    const /** @type {?} */ parentRefNode = removeNode.parentNode;
                    parentRefNode.removeChild(removeNode);
                }
            }
            else if (tab.tabId !== tabNode.tabId) {
                newTab.push(tab);
            }
            index++;
        });
        if (tabHighlightIndex === newTab.length) {
            tabHighlightIndex--;
        }
        this.tabCollection = newTab;
        if (tabHighlightIndex > -1) {
            this.activateTab(newTab[tabHighlightIndex].tabId);
        }
        else {
            this.activateTab(null);
        }
        if (this.tabCollection.length === 1) {
            this.closable = false;
        }
        if (newTab.length === 1) {
            newTab[0].closable = false;
        }
    }
    /**
     * @param {?} tabId
     * @return {?}
     */
    activateTab(tabId) {
        if (tabId !== null) {
            this.tabCollection.forEach((tab) => {
                tab.active = false;
                if (tab.tabId === tabId) {
                    tab.active = true;
                }
                this.asignTabPillClass(tab);
            });
        }
    }
    /**
     * @param {?} tabData
     * @return {?}
     */
    asignTabPillClass(tabData) {
        tabData.tabPillClass = '';
        if ((!tabData.amexiocolor || tabData.amexiocolor === '') && tabData.active && (this.tabPosition === 'top')) {
            tabData.tabPillClass = 'activetab';
        }
        if ((!tabData.amexiocolor || tabData.amexiocolor === '') && (this.tabPosition === 'bottom') && tabData.active) {
            tabData.tabPillClass = 'bottomActivetab';
        }
        if (tabData.disabled) {
            tabData.tabPillClass = 'disabled-tab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'top') && tabData.active) {
            tabData.tabPillClass = 'activecolortab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'bottom') && tabData.active) {
            tabData.tabPillClass = 'activebottomcolortab';
        }
    }
    /**
     * @return {?}
     */
    findTabStyleClass() {
        if (this.headeralign === 'right' && !this.fullPageTabs) {
            return 'tabposition-right';
        }
        if (this.headeralign === 'left' && !this.fullPageTabs) {
            return 'tabposition-left';
        }
        if (this.fullPageTabs === true) {
            return 'equally-align-tabs';
        }
    }
    /**
     * @return {?}
     */
    onAdjustHeight() {
        if (this.bodyheight) {
            let /** @type {?} */ h = (window.innerHeight / 100) * this.bodyheight;
            if (this.tabs && this.tabs.nativeElement && this.tabs.nativeElement.offsetHeight) {
                h = h - this.tabs.nativeElement.offsetHeight;
            }
            if (this.bodyheight === 100) {
                h = h - 40;
            }
            this.minHeight = h;
            this.height = h;
        }
    }
    /**
     * @param {?} event
     * @param {?} row
     * @param {?} id
     * @return {?}
     */
    loadContextMenu(event, row, id) {
        this.tempSelectedFlag(this.tabCollection);
        this.mouseLocation.left = event.clientX;
        this.mouseLocation.top = event.clientY;
        row.active = true;
        this.getContextMenu();
        this.posixUp = this.getListPosition(id);
        event.preventDefault();
        event.stopPropagation();
        this.rightClickRowData = row;
        this.contextStyle = this.getContextMenuStyle();
    }
    /**
     * @param {?} tabs
     * @return {?}
     */
    tempSelectedFlag(tabs) {
        tabs.forEach((tab) => {
            if (tab.active) {
                tab.active = false;
            }
        });
    }
    /**
     * @return {?}
     */
    getContextMenu() {
        if (this.defaultContextMenu) {
            const /** @type {?} */ obj = { text: 'Close All', icon: 'fa fa-close', disable: false };
            const /** @type {?} */ obj2 = { text: this.closeOthersConst, icon: 'fa fa-close', seperator: false, disabled: false };
            let /** @type {?} */ tmpflag = true;
            for (const /** @type {?} */ i of this.contextmenu) {
                if (i.text === 'Close All' || i.text === this.closeOthersConst) {
                    tmpflag = false;
                }
            }
            if (tmpflag) {
                this.contextmenu.push(obj, obj2);
            }
            this.contextMenuFlag = true;
            this.addListner();
        }
        else if (this.contextmenu && this.contextmenu.length > 0) {
            this.contextMenuFlag = true;
            this.addListner();
        }
    }
    /**
     * @return {?}
     */
    getContextMenuStyle() {
        return {
            'cursor': 'default',
            'position': 'fixed',
            'display': this.contextMenuFlag ? 'block' : 'none',
            'left': this.mouseLocation.left + 'px',
            'top': this.mouseLocation.top + 'px',
            'box-shadow': '1px 1px 2px #000000',
            'width': '15%',
        };
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        const /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} itemConfig
     * @return {?}
     */
    onContextNodeClick(itemConfig) {
        let /** @type {?} */ temptab;
        this.tabCollection.forEach((obj) => {
            if (obj.active) {
                temptab = obj;
            }
        });
        if (itemConfig.active) {
            temptab = itemConfig;
        }
        if (!itemConfig.disabled) {
            const /** @type {?} */ obj = {
                menuData: itemConfig,
                rowData: this.rightClickRowData,
            };
            if (itemConfig.text === 'Close All') {
                this.closeAllTabs();
            }
            if (itemConfig.text === this.closeOthersConst) {
                this.closeOtherTabs(temptab);
            }
            this.contextMenuFlag = false;
            this.removeListner();
            this.rightClick.emit(obj);
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    closeOtherTabs(data) {
        this.tabCollection.forEach((tabs) => {
            if (data.title.toLowerCase() !== tabs.title.toLowerCase() && (tabs.closable === true || this.closable === true)) {
                this.closeTab(tabs);
            }
        });
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (e) => {
            this.contextMenuFlag = false;
            if (!this.contextMenuFlag) {
                this.removeListner();
            }
        });
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
    }
}
AmexioTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tab-view',
                template: `
    <div class="tabwrapper">
      <div *ngIf="showprev" [ngClass]="{'tabnavigation float-right tabnavigation-bottom-left':tabPosition=='bottom', 'tabnavigation float-left':tabPosition=='top'}" (click)="previous()">
        <amexio-pane-icon key="tab_previous"></amexio-pane-icon>
      </div>
      <div *ngIf="shownext" [ngClass]="{'tabnavigation float-right tabnavigation-bottom-right':tabPosition=='bottom','tabnavigation float-right':tabPosition=='top'}" (click)="next()">
        <amexio-pane-icon key="tab_next"></amexio-pane-icon>
      </div>

      <div #tab class="tab" [ngClass]="{'bottomTab':tabPosition == 'bottom'}">

        <div #tabslist class="tablistitems {{tabPositionClass}}">
          <!-- HEADER -->

          <div class="tablink" style="padding-bottom:0%" *ngIf="(this.action == true || header) && (fullPageTabs == false)">
            <div class="table">
              <div class="tablerow">
                <div class="tablecol">
                  {{header}}
                </div>
                <div class="tablecol">
                  <ng-content select="amexio-tab-action"></ng-content>
                </div>
              </div>
            </div>
          </div>



          <div>
            <div *ngFor="let tabnode of tabCollection" class="tablink {{tabnode.amexiocolor+ ' '+tabnode.tabPillClass}}" [style.width.px]="singleTabWidth"
                 (click)="onTabClick(tabnode)" (contextmenu)="loadContextMenu($event,tabnode, tab)">
              <div class="table">
                <div class="tablerow">
                  <div *ngIf="tabnode.icon" class="tablecol">
                    <amexio-pane-icon *ngIf="tabnode.icon" [customclass]="tabnode.icon"></amexio-pane-icon>
                  </div>
                  <div class="tablecol">
                    {{tabnode.title}}
                  </div>
                  <div *ngIf="tabnode.closable" class="tablecol">
                    <amexio-pane-icon key="tab_close" (onClick)="closeTab(tabnode)"></amexio-pane-icon>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="tabcontent" [attr.id]="componentId" [ngStyle]="{'height.px' : height,'overflow-y' : height!= null ? 'auto' : '','min-height.px' : minHeight}" >
      <ng-content></ng-content>
      <ng-template #target></ng-template>
    </div>

    <span [ngStyle]="contextStyle">
      <ul *ngIf="contextMenuFlag" class="context-menu-list" [ngClass]="{'dropdown-up' : posixUp}">
        <li (click)="onContextNodeClick(itemConfig)" class="context-menu-list-items" [ngStyle]="{'cursor': itemConfig.disabled ? 'not-allowed':'pointer'}" [ngClass]="{'context-menu-separator':itemConfig.seperator}"
            *ngFor="let itemConfig of contextmenu">
          <em [ngStyle]="{'padding-left': itemConfig.icon ? '5px':'19px'}" [ngClass]="itemConfig.icon"></em>
          <span style="white-space: nowrap;display: inline ; padding-left:5px">{{itemConfig.text}}
          </span>
        </li>
      </ul>
    </span>
  `,
            },] },
];
/** @nocollapse */
AmexioTabComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ComponentFactoryResolver },
    { type: Renderer2 }
];
AmexioTabComponent.propDecorators = {
    closable: [{ type: Input }],
    headeralign: [{ type: Input, args: ['header-align',] }],
    action: [{ type: Input }],
    typeActionAlign: [{ type: Input, args: ['action-type-align',] }],
    fullPageTabs: [{ type: Input, args: ['divide-header-equally',] }],
    tabPosition: [{ type: Input, args: ['tab-position',] }],
    header: [{ type: Input }],
    bodyheight: [{ type: Input, args: ['body-height',] }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    defaultContextMenu: [{ type: Input, args: ['default-context-menu',] }],
    rightClick: [{ type: Output }],
    tabs: [{ type: ViewChild, args: ['tab', { read: ElementRef },] }],
    tabAction: [{ type: ViewChild, args: ['tabAction', { read: ElementRef },] }],
    headerWidth: [{ type: ViewChild, args: ['headerWidth', { read: ElementRef },] }],
    headerName: [{ type: ViewChild, args: ['headerName', { read: ElementRef },] }],
    tabslist: [{ type: ViewChild, args: ['tabslist', { read: ElementRef },] }],
    actionProperty: [{ type: ViewChild, args: ['actionProperty', { read: ElementRef },] }],
    queryTabs: [{ type: ContentChildren, args: [AmexioTabPillComponent,] }],
    target: [{ type: ViewChild, args: ['target', { read: ViewContainerRef },] }],
    queryAction: [{ type: ContentChildren, args: [AmexioTabActionComponent, { descendants: true },] }],
    onClick: [{ type: Output }],
    tabLocalData: [{ type: Input, args: ['tabLocalData',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/1/17.
 */
class AmexioVerticalTabComponent {
    /**
     * @param {?} render
     */
    constructor(render) {
        this.render = render;
        /*
        Events
        name : onClick
        datatype : none
        version : 4.0 onwards
        default :none
        description : Callback to invoke on activated tab event.
        */
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.tabCollection = this.queryTabs.toArray();
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    onTabClick(tab) {
        if (!tab.disabled) {
            for (const /** @type {?} */ i of this.tabCollection) {
                if (i === tab) {
                    i['active'] = true;
                    this.onClick.emit(tab);
                }
                else {
                    i['active'] = false;
                }
            }
        }
    }
    /**
     * @param {?} tabNode
     * @return {?}
     */
    closeTab(tabNode) {
        const /** @type {?} */ newTab = [];
        let /** @type {?} */ index = 0;
        let /** @type {?} */ tabHighlightIndex = 0;
        this.tabCollection.forEach((tab) => {
            tab.active = false;
            if (tab.tabId === tabNode.tabId) {
                tabHighlightIndex = index;
            }
            if (tab.tabId !== tabNode.tabId) {
                newTab.push(tab);
            }
            index++;
        });
        if (tabHighlightIndex === newTab.length) {
            tabHighlightIndex--;
        }
        this.activateTab(newTab[tabHighlightIndex].tabId);
        this.tabCollection = newTab;
    }
    /**
     * @param {?} tabId
     * @return {?}
     */
    activateTab(tabId) {
        this.tabCollection.forEach((tab) => {
            tab.active = false;
        });
    }
}
AmexioVerticalTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-vertical-tab-view',
                template: `
    <div class="vertical-table">
      <div class="vertical-tablerow">
        <div class="vertical-tablecol verticalalign-tableft">
          <div class="verticalnavtab verticalnavtab-left ">
            <ul>
              <li *ngFor="let tabnode of tabCollection">
                <div class="defaultnode" [ngClass]="{'leftactivetab':tabnode.active,'disabled-tab':tabnode.disabled }" (click)="onTabClick(tabnode)">
                  <span *ngIf="tabnode.icon" [ngClass]="tabnode.icon" style="padding-right:8px"  aria-hidden="true"></span>
                  <span>{{tabnode.title}}</span>
                </div>
              </li>
            </ul>
          </div>
        </div>

        <div class="vertical-tablecol verticalalign-tabcontent">
          <div class="tabcontent">
            <ng-content></ng-content>
          </div>
        </div>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioVerticalTabComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexioVerticalTabComponent.propDecorators = {
    tabs: [{ type: ViewChild, args: ['tab', { read: ElementRef },] }],
    queryTabs: [{ type: ContentChildren, args: [AmexioTabPillComponent,] }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexiotimelineeventComponent {
    constructor() {
        this.timelineclass = 'timeline-item';
        /*
          Properties
          name :contentborder
          datatype :string
          version : 4.2onwards
          default : false
          description : This will specify the content border in timeline.
          */
        this.contentborder = true;
        this.alignment = 'center';
    }
}
AmexiotimelineeventComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-timeline-event',
                template: `<div class="timeline-badge " [ngClass]="{'timeline-badge-center': (alignment === 'center')
  , 'timeline-badge-left': (alignment === 'right')
  , 'timeline-badge-right': (alignment === 'left')}">
<amexio-pane-icon [customclass]="icon"></amexio-pane-icon>
</div>
<div class="timeline-panel" [ngClass]="{'timeline-panel-border':contentborder,
 'timeline-panel-float-right': (contentalignment == 'right'),
 'timeline-panel-float-left': (contentalignment == 'left'),
 'timeline-panel-center': (alignment === 'center'),
 'timeline-panel-right': (alignment === 'right'),
 'timeline-panel-left': (alignment === 'left')}">
<div *ngIf="label"><b>{{label}}</b></div>
<ng-content></ng-content>
</div>`,
            },] },
];
/** @nocollapse */
AmexiotimelineeventComponent.ctorParameters = () => [];
AmexiotimelineeventComponent.propDecorators = {
    timelineclass: [{ type: HostBinding, args: ['attr.class',] }],
    label: [{ type: Input, args: ['label',] }],
    icon: [{ type: Input, args: ['icon',] }],
    contentborder: [{ type: Input, args: ['content-border',] }],
    contentalignment: [{ type: Input, args: ['content-alignment',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioTimeLineModel {
    /**
     * @param {?} timelineevents
     * @param {?} contentalignment
     * @param {?} alignment
     */
    constructor(timelineevents, contentalignment, alignment) {
        this.timelineevents = timelineevents;
        this.alignment = alignment;
        this.contentalignment = contentalignment;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexiotimelineComponent {
    /**
     * @param {?} matchMediaService
     */
    constructor(matchMediaService) {
        this.matchMediaService = matchMediaService;
        this.alignment = 'center';
        const /** @type {?} */ that = this;
        this.matchMediaService.OnPhone((mediaQueryList) => {
            that.mobileOrTabletMode();
        });
        this.matchMediaService.OnTablet((mediaQueryList) => {
            that.mobileOrTabletMode();
        });
        this.matchMediaService.OnDesktop((mediaQueryList) => {
            that.desktopMode();
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.timelineevents = this.querylist.toArray();
        this.initContentAlignment();
    }
    /**
     * @return {?}
     */
    initContentAlignment() {
        if (this.contentalignment) {
            this.alignment = this.contentalignment;
        }
        let /** @type {?} */ hasContentAlignment = true;
        this.timelineevents.forEach((timeline) => {
            if (timeline.contentalignment) {
                hasContentAlignment = false;
            }
        });
        if (hasContentAlignment) {
            this.timelineevents.forEach((timeline, index) => {
                if (this.contentalignment) {
                    timeline.contentalignment = this.contentalignment;
                }
                else {
                    timeline.contentalignment = ((index % 2) === 0) ? 'right' : 'left';
                }
                timeline.alignment = this.alignment;
            });
        }
        this.timelineModel = new AmexioTimeLineModel(JSON.parse(JSON.stringify(this.timelineevents)), this.contentalignment, this.alignment);
    }
    /**
     * @return {?}
     */
    mobileOrTabletMode() {
        this.alignment = 'right';
        this.timelineevents.forEach((timeline, index) => {
            timeline.contentalignment = 'right';
            timeline.alignment = this.alignment;
        });
    }
    /**
     * @return {?}
     */
    desktopMode() {
        this.alignment = this.timelineModel.alignment;
        this.contentalignment = this.timelineModel.contentalignment;
        this.timelineevents.forEach((timeline, index) => {
            const /** @type {?} */ originalTimelineEvent1 = this.timelineModel.timelineevents[index];
            timeline.contentalignment = originalTimelineEvent1.contentalignment;
            timeline.alignment = originalTimelineEvent1.alignment;
        });
    }
}
AmexiotimelineComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-timeline',
                template: `
    <div class='timeline' [ngClass]="{'timelinecenter': (alignment == 'center'), 
                                    'timelineleft': (alignment == 'left'), 
                                    'timelineright': (alignment == 'right')}">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexiotimelineComponent.ctorParameters = () => [
    { type: DeviceQueryService }
];
AmexiotimelineComponent.propDecorators = {
    querylist: [{ type: ContentChildren, args: [AmexiotimelineeventComponent,] }],
    contentalignment: [{ type: Input, args: ['content-alignment',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioWindowHeaderComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioWindowHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-window-header', template: `
    <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioWindowHeaderComponent.ctorParameters = () => [];
AmexioWindowHeaderComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/18/17.
 */
/** @enum {number} */
const KEY_CODE_window = {
    esc: 27,
};
KEY_CODE_window[KEY_CODE_window.esc] = "esc";
class AmexioWindowPaneComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        /*
           Properties
           name : relative
           datatype : boolean
           version : 4.1 onwards
           default : none
           description : Place floating button at relative position
           */
        this.relative = false;
        this.showChange = new EventEmitter();
        this.window = ' window-';
        this.nodeRightClick = new EventEmitter();
        this.rightClick = new EventEmitter();
        this.close = new EventEmitter();
        this.mouseLocation = { left: 0, top: 0 };
        this.absoluteposition = false;
        this.header = true;
        this.closable = true;
        this.closeonescape = true;
        if (this.verticalposition == null) {
            this.verticalposition = 'center';
        }
        if (this.horizontalposition == null) {
            this.horizontalposition = 'center';
        }
        this.positionclass = this.window + this.verticalposition + this.window + this.horizontalposition;
    }
    /**
     * @return {?}
     */
    sizeChange() {
        this.isFullWindow = !this.isFullWindow;
        this.setClass();
    }
    /**
     * @return {?}
     */
    onCloseClick() {
        if (this.closable) {
            this.showWindow = false;
            this.show = false;
            this.showChange.emit(false);
            this.close.emit(this.showWindow);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.showWindow) {
            this.show = this.showWindow;
        }
        if (this.maximize == null) {
            this.maximize = false;
            this.isFullWindow = false;
        }
        else if (this.maximize) {
            this.isFullWindow = true;
            this.bodyHeight = '100%';
        }
        if (this.footeralign == null) {
            this.footeralign = 'right';
        }
        if (this.verticalposition === '') {
            this.verticalposition = 'center';
        }
        if (this.horizontalposition === '') {
            this.horizontalposition = 'center';
        }
        this.positionclass = this.window + this.verticalposition + this.window + this.horizontalposition;
        this.setClass();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['show']) {
            this.setShowFlag(changes["show"].currentValue);
        }
        if (changes['showWindow']) {
            this.setShowFlag(changes["showWindow"].currentValue);
        }
    }
    /**
     * @param {?} changedValue
     * @return {?}
     */
    setShowFlag(changedValue) {
        this.show = changedValue;
        if (this.show && this.closeonescape) {
            this.globalListenFunc = this.renderer.listen('document', 'keyup.esc', (e) => {
                this.showWindow = false;
                this.showChange.emit(false);
            });
        }
        else if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    }
    /**
     * @return {?}
     */
    setClass() {
        if (this.isFullWindow) {
            this.styleClass = 'modal-window-content-max';
        }
        else {
            this.styleClass = this.positionclass;
        }
    }
    /**
     * @return {?}
     */
    getContextMenu() {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        const /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    loadContextMenu(rightClickData) {
        this.mouseLocation.left = rightClickData.event.clientX;
        this.mouseLocation.top = rightClickData.event.clientY;
        this.getContextMenu();
        this.posixUp = this.getListPosition(rightClickData.ref);
        rightClickData.event.preventDefault();
        rightClickData.event.stopPropagation();
        this.rightClickNodeData = rightClickData.data;
        this.contextStyle = this.getContextMenuStyle();
        this.nodeRightClick.emit(rightClickData);
    }
    /**
     * @param {?} itemConfig
     * @return {?}
     */
    onContextNodeClick(itemConfig) {
        if (!itemConfig.disabled) {
            const /** @type {?} */ obj = {
                menuData: itemConfig,
                NodeData: this.rightClickNodeData,
            };
            this.flag = false;
            this.removeListner();
            this.rightClick.emit(obj);
        }
    }
    /**
     * @return {?}
     */
    getContextMenuStyle() {
        return {
            'cursor': 'default',
            'position': 'fixed',
            'display': this.flag ? 'block' : 'none',
            'left': this.mouseLocation.left + 'px',
            'top': this.mouseLocation.top + 'px',
            'box-shadow': '1px 1px 2px #000000',
            'width': '15%',
        };
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (e) => {
            this.flag = false;
            if (!this.flag) {
                this.removeListner();
            }
        });
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
        if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    }
}
AmexioWindowPaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-window',
                template: `
    <div #id class="root-window model-fade" [ngClass]="{'modal-window-max': isFullWindow,'modal-window-min': !isFullWindow}"
        [ngStyle]="{'display' : show ? 'block' : 'none'}" (contextmenu)="loadContextMenu({event:$event,ref:id})">
        <div class="modal-window-lg" [ngStyle]="{'height': bodyHeight ? '100%':'auto'}">
            <div class="modal-window-content" [ngClass]="styleClass" [style.height]="bodyHeight+'%'">
                <header [ngClass]="{ 'window-material-design-header':materialDesign,'modal-window-header':!materialDesign}"
                    *ngIf="header">
                    <div class="modal-window-table">
                        <div class="tablerow">
                            <div class="tablecol">
                                <ng-content select="amexio-header"></ng-content>
                                <ng-content select="amexio-window-header"></ng-content>
                            </div>
                            <div class="tablecol float-right">
                                <ng-container *ngIf="(!isFullWindow && maximize)">
                                    <amexio-pane-icon [key]="'window_maximize'" (onClick)="sizeChange()"></amexio-pane-icon>
                                    &nbsp;
                                </ng-container>
                                <ng-container *ngIf="(isFullWindow && maximize)">
                                    <amexio-pane-icon [key]="'window_restore'" (click)="sizeChange()"></amexio-pane-icon>
                                    &nbsp;
                                </ng-container>
                                <ng-container *ngIf="closable">
                                    <amexio-pane-icon [key]="'window_close'" (onClick)="onCloseClick()"></amexio-pane-icon>
                                    &nbsp;
                                </ng-container>
                            </div>
                        </div>
                    </div>
                </header>
                <div class="modal-window-middle">
                    <ng-content select="amexio-body"></ng-content>
                </div>
                <footer *ngIf="footer" class="modal-window-footer" [ngClass]="{'window-material-design-footer':materialDesign ,
             'modal-window-footer':!materialDesign,
             'modal-window-footer-max': isFullWindow && maximize,'flex-start':(footeralign =='left'),
             'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}">
                    <div [ngClass]="{'footer-right-align': (isFullWindow && maximize)}">
                        <ng-content select="amexio-action"></ng-content>
                    </div>
                </footer>
            </div>

        </div>
    </div>
    <ng-container *ngIf="flag">
        <span [ngStyle]="contextStyle" style=" z-index: 5; position: absolute;">
            <ul class="context-menu-list" [ngClass]="{'dropdown-up' : posixUp}">
                <li (click)="onContextNodeClick(itemConfig)" class="context-menu-list-items" [ngStyle]="{'cursor': itemConfig.disabled ? 'not-allowed':'pointer'}"
                    [ngClass]="{'context-menu-separator':itemConfig.seperator}" *ngFor="let itemConfig of contextmenu">
                    <em [ngStyle]="{'padding-left': itemConfig.icon ? '5px':'19px'}" [ngClass]="itemConfig.icon"></em>
                    <span style="white-space: nowrap;display: inline ; padding-left:5px">{{itemConfig.text}}
                    </span>
                </li>
            </ul>
        </span>
    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioWindowPaneComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexioWindowPaneComponent.propDecorators = {
    verticalposition: [{ type: Input, args: ['vertical-position',] }],
    horizontalposition: [{ type: Input, args: ['horizontal-position',] }],
    closeonescape: [{ type: Input, args: ['close-on-escape',] }],
    top: [{ type: Input, args: ['position-top',] }],
    bottom: [{ type: Input, args: ['position-bottom',] }],
    relative: [{ type: Input, args: ['relative',] }],
    footeralign: [{ type: Input, args: ['footer-align',] }],
    showWindow: [{ type: Input, args: ['show-window',] }],
    materialDesign: [{ type: Input, args: ['material-design',] }],
    show: [{ type: Input }],
    windowHeader: [{ type: ViewChild, args: ['windowHeader', { read: ElementRef },] }],
    showChange: [{ type: Output }],
    bodyHeight: [{ type: Input, args: ['body-height',] }],
    maximize: [{ type: Input }],
    closable: [{ type: Input }],
    header: [{ type: Input }],
    footer: [{ type: Input }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    parentRef: [{ type: Input }],
    nodeRightClick: [{ type: Output }],
    rightClick: [{ type: Output }],
    amexioHeader: [{ type: ContentChildren, args: [AmexioWindowHeaderComponent,] }],
    close: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioSearchAdvanceComponent {
    constructor() {
        this.title = 'Advance Search';
        this.advanceSearchFlag = false;
    }
    /**
     * @return {?}
     */
    closeSearchForm() {
        this.advanceSearchFlag = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioSearchAdvanceComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-searchbox-options',
                template: `
  <form class="advancesearchform" *ngIf="advanceSearchFlag"  [style.width]="formwidth+'px'">
    <label class="search-form-label">
        {{title}}
    </label>
    <span class="fa fa-window-close fa-1x close-icon"  (click)="closeSearchForm()"></span>
    <hr class="hrclass">
             <ng-content></ng-content>
</form>
`,
            },] },
];
/** @nocollapse */
AmexioSearchAdvanceComponent.ctorParameters = () => [];
AmexioSearchAdvanceComponent.propDecorators = {
    title: [{ type: Input }],
    formwidth: [{ type: Input, args: ['form-width',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SearchboxtoolComponent extends BaseFormValidator {
    /**
     * @param {?} element
     * @param {?} dataService
     * @param {?} renderer
     * @param {?} _cd
     */
    constructor(element, dataService, renderer, _cd) {
        super(renderer, element, _cd);
        this.element = element;
        this.dataService = dataService;
        this.renderer = renderer;
        /*
           Properties
           name : title
           datatype : string
           version : 4.2 onwards
           default : none
           description : sets title to advance search form
           */
        this.title = 'Advance Search';
        /*
           Properties
           name : width
           datatype : number
           version : 4.2 onwards
           default : none
           description : Sets width to auto recommendation list.
           */
        this.width = 500;
        /*
           Events
           name : keyup
           description : Fires when keyup event occurs
           */
        this.keyup = new EventEmitter();
        /*
           Events
           name : onSearchItemClick
           description : Fires when search item is selected
           */
        this.onSearchItemClick = new EventEmitter();
        /*
           Events
           name : onSearchClick
           description : Fires when search button is clicked
           */
        this.onSearchClick = new EventEmitter();
        this.caretFlag = false;
        this.searchFlag = false;
        this.searchTextBox = false;
        this.selectedValue = '';
        this.advanceSearchFlag = false;
        this.selectedindex = 0;
        this.scrollposition = 30;
        this.enableAdvanceSearch = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.advanceSearchRef.formwidth = this.width;
        this.enableAdvnSearch = this.advanceSearchRef.advanceSearchFlag;
        this.enableAdvanceSearch = true;
        if (this.advanceSearchRef) {
            this.enableAdvanceSearch = true;
            if (this.advanceSearchRef.title) {
                this.advanceButtonLabel = this.advanceSearchRef.title;
            }
            else if (!this.advanceSearchRef.title || this.advanceSearchRef.title === '') {
                this.advanceButtonLabel = 'Advance Search';
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.responseData = response;
            }, (error) => {
            }, () => {
                this.setData(this.responseData);
            });
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.previousData) !== JSON.stringify(this.data)) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @return {?}
     */
    onSelectClick() {
        this.advanceSearchFlag = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInputClick(event) {
        this.searchFlag = true;
        this.onBaseFocusEvent({});
        const /** @type {?} */ keyword = event.target.value;
        this.viewData = [];
        if (keyword != null && keyword !== ' ') {
            const /** @type {?} */ search_term = keyword.toLowerCase();
            this.localData.forEach((item) => {
                if (item != null && item[this.displayfield].toLowerCase().startsWith(search_term)) {
                    this.viewData.push(item);
                }
            });
            this.keyup.emit(event);
        }
        // logic for arrow keys and enter key press
        // 40=down-arrow and 38=up-arrow and 13=enter
        if (event.keyCode === 40 || event.keyCode === 38 || event.keyCode === 13) {
            // if key pressed is up down or enter then process accordingly
            // call function for process
            this.navigateKeys(event);
        }
        if (!this.selectedValue || this.selectedValue === '') {
            this.viewData = [];
        }
    }
    /**
     * @return {?}
     */
    onFocus() {
        if (this.selectedValue.length > 0) {
            const /** @type {?} */ keyword = this.selectedValue;
            this.viewData = [];
            if (keyword != null && keyword !== ' ') {
                const /** @type {?} */ search_term = keyword.toLowerCase();
                this.localData.forEach((item1) => {
                    if (item1 != null && item1[this.displayfield].toLowerCase().startsWith(search_term)) {
                        // if word exist in start
                        this.viewData.push(item1);
                    }
                });
                this.searchFlag = true;
                this.onBaseFocusEvent({});
                this.keyup.emit(event);
            }
            this.selectedValueOnFocus();
        }
    }
    /**
     * @return {?}
     */
    selectedValueOnFocus() {
        if (!this.selectedValue || this.selectedValue === '') {
            this.viewData = [];
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateKeys(event) {
        if (this.selectedindex > this.viewData.length) {
            this.selectedindex = 0;
        }
        if (event.keyCode === 40 ||
            event.keyCode === 38
                && this.selectedindex < this.viewData.length) {
            this.navigateKeysCondition(event);
        }
        if (event.keyCode === 13 && this.viewData[this.selectedindex]) {
            this.onItemSelect(this.viewData[this.selectedindex]);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateKeysCondition(event) {
        let /** @type {?} */ prevselectedindex = 0;
        if (this.selectedindex === 0) {
            this.selectedindex = 1;
        }
        else {
            prevselectedindex = this.selectedindex;
            if (event.keyCode === 40) {
                this.selectedindex++;
                if ((this.selectedindex > 5)) {
                    this.dropdownitems.nativeElement.scroll(0, this.scrollposition);
                    this.scrollposition = this.scrollposition + 30;
                }
            }
            else if (event.keyCode === 38) {
                this.eventKeyCodeCondition();
            }
        }
        if (this.viewData[this.selectedindex]) {
            this.viewData[this.selectedindex].selected = true;
        }
        if (this.viewData[prevselectedindex]) {
            this.viewData[prevselectedindex].selected = false;
        }
    }
    /**
     * @return {?}
     */
    eventKeyCodeCondition() {
        this.selectedindex--;
        if (this.scrollposition >= 0 && this.selectedindex > 1) {
            this.dropdownitems.nativeElement.scroll(1, this.scrollposition);
            this.scrollposition = this.scrollposition - 30;
        }
        if (this.selectedindex === 1) {
            this.scrollposition = 30;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSearchButtonClick(event) {
        this.onSearchClick.emit(event);
    }
    /**
     * @return {?}
     */
    selectCssClass() {
        if (this.viewData.length > 5) {
            return 'dropdown-list scroll';
        }
        else {
            return 'dropdown-list';
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onItemSelect(item) {
        this.value = item[this.valuefield];
        this.selectedValue = item[this.displayfield];
        this.searchFlag = this.onBaseBlurEvent({});
        this.onSearchItemClick.emit(item);
    }
    /**
     * @return {?}
     */
    advanceSearch() {
        this.advanceSearchRef.advanceSearchFlag = true;
        this.advanceSearchFlag = true;
        this.searchFlag = this.onBaseBlurEvent({});
    }
    /**
     * @return {?}
     */
    closeSearchForm() {
        this.advanceSearchFlag = false;
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getResponseData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            if (dr != null) {
                for (const /** @type {?} */ ir of dr) {
                    responsedata = responsedata[dr[ir]];
                }
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        // Check if key is added?
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[dr[ir]];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewData = responsedata;
        this.localData = JSON.parse(JSON.stringify(this.viewData));
    }
}
SearchboxtoolComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-searchbox',
                template: `
    <div class="input-group">
      <div class="input-group-prepend">
        <input type="text" class="form-control" (keyup)="onInputClick($event)" #inp [(ngModel)]="selectedValue"
          [attr.placeholder]="placeholder" (click)="onSelectClick()" (focus)="onFocus()">
      </div>



      <div class="input-group-text-search " (click)="onSearchButtonClick($event)">
        <em class="fa fa-search iconColor">
        </em>
      </div>

    </div>



    <form [ngStyle]="dropdownstyle" class="dropdownposition">
      <ng-container *ngIf="!advanceSearchFlag">
        <ul #dropdownitems [style.width]="width+'px'" class="search-dropdown-list" [ngClass]="selectCssClass()">

          <li class="search-list-items " [ngClass]="{'search-list-items-selected':item.selected}" *ngFor="let item of viewData"
            (click)="onItemSelect(item)">
            <div style="white-space: nowrap;display: inline;">{{item[displayfield]}}</div>
          </li>
        </ul>
        <ng-container *ngIf="selectedValue.length > 0">
          <div [style.width]="width+'px'" class="advancesearchbuttondiv">
            <button class="fa fa-search btncolor" [style.width]="width+'px'" class="advancesearchbtn fa fa-search" (click)="advanceSearch()">
              {{advanceButtonLabel}}
            </button>
          </div>
        </ng-container>

      </ng-container>
    </form>

    <div [ngStyle]="{'block': advanceSearchRef.advanceSearchFlag ? 'block' : 'none'}">

      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
SearchboxtoolComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: CommonDataService },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
SearchboxtoolComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    title: [{ type: Input }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    width: [{ type: Input }],
    keyup: [{ type: Output }],
    onSearchItemClick: [{ type: Output }],
    onSearchClick: [{ type: Output }],
    advanceSearchRef: [{ type: ContentChild, args: [AmexioSearchAdvanceComponent,] }],
    dropdownitems: [{ type: ViewChild, args: ['dropdownitems', { read: ElementRef },] }],
    inp: [{ type: ViewChild, args: ['inp', { read: ElementRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioButtonDropDownItemComponent {
    constructor() {
        /*
        Events
        name : onItemClick
        datatype : none
        version : none
        default : none
        description : Fire when button-dropdown item button/link click
        */
        this.onItemClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioButtonDropDownItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-btn-dropdown-item', template: '',
            },] },
];
/** @nocollapse */
AmexioButtonDropDownItemComponent.ctorParameters = () => [];
AmexioButtonDropDownItemComponent.propDecorators = {
    label: [{ type: Input }],
    badge: [{ type: Input, args: ['badge',] }],
    disabled: [{ type: Input }],
    icon: [{ type: Input }],
    onClickRoute: [{ type: Input }],
    onItemClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioButtonDropdownComponent extends BaseFormValidator {
    /**
     * @param {?} element
     * @param {?} renderer
     * @param {?} _cd
     */
    constructor(element, renderer, _cd) {
        super(renderer, element, _cd);
        this.element = element;
        this.dropdownItemData = [];
        /*
        Events
        name : click
        datatype :  none
        version : none
        default : none
        description : Fire when button-dropdown item button/link click
        */
        this.click = new EventEmitter();
        /*
        Events
        name : getLinkData
        datatype :  none
        version : none
        default : none
        description : Fire when button-dropdown item button/link click
        */
        this.getLinkData = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._buttonGroupLocalData = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get buttonGroupLocalData() {
        return this._buttonGroupLocalData;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.buttonGroupPreviewData) !== JSON.stringify(this.buttonGroupLocalData)) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.dropdownItemData = this.buttonGroupLocalData;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.buttonGroupLocalData && this.buttonGroupLocalData.length > 0) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.dropdownItemData = this.buttonGroupLocalData;
            this.createDropdownItemConfig(this.dropdownItemData);
        }
        else {
            this.createDropdownItemConfig(this.buttons.toArray());
        }
        this.componentLoaded = true;
    }
    /**
     * @param {?} btnCollection
     * @return {?}
     */
    createDropdownItemConfig(btnCollection) {
        const /** @type {?} */ itemRefArray = btnCollection;
        for (const /** @type {?} */ itemConfig of itemRefArray) {
            const /** @type {?} */ data = {
                label: itemConfig.label,
                disabled: itemConfig.disabled,
                onItemClick: itemConfig.onItemClick,
                iconStyleClass: itemConfig.iconStyleClass,
                icon: itemConfig.icon,
                badge: itemConfig.badge,
                onClickRoute: itemConfig.onClickRoute,
            };
            data.iconStyleClass = data.icon;
            this.dropdownItemData.push(data);
        }
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onClick(elem) {
        this.openContent = !this.openContent;
        if (this.openContent) {
            this.onBaseFocusEvent({});
        }
        else {
            this.openContent = this.onBaseBlurEvent(elem);
        }
        this.posixUp = this.getListPosition(elem);
        this.click.emit();
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        const /** @type {?} */ dropdownHeight = 325; // must be same in dropdown.scss
        if (window.screen.height - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} eve
     * @return {?}
     */
    onblur(eve) {
        this.openContent = this.onBaseBlurEvent(eve);
    }
    /**
     * @param {?} clickEvent
     * @param {?} itemData
     * @return {?}
     */
    btnItemClick(clickEvent, itemData) {
        if (this.buttonGroupLocalData && this.buttonGroupLocalData.length > 0) {
            this.getLinkData.emit({ event: clickEvent, parentRef: this, data: itemData });
        }
        else {
            if (!itemData.disabled) {
                itemData.onItemClick.emit(clickEvent);
                this.openContent = !this.openContent;
                this.onBaseBlurEvent(event);
            }
        }
    }
}
AmexioButtonDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-btn-dropdown', template: `
    <div class="button-group" #rootDiv>
       <button class="button-dropdown-main" (blur)="onblur($event)" (click)="onClick(rootDiv)" #btnRef
               [ngClass]="{'button-default': size=='default' || size ==null,
               'button-small': size=='small',
               'button-large' : size=='large',
               'button-primary' : type == 'primary' || type == null || type == 'theme-color',
               'button-success' : type == 'success' || type == 'green',
               'button-danger' : type=='danger' || type == 'red',
               'button-warning' : type=='warning' ||  type == 'yellow'}">
         <amexio-form-icon style="float:right;" key="button_caret-down"></amexio-form-icon>
         <span [attr.disabled]="disabled ? true: null">{{label}} &nbsp;&nbsp;</span>
         <!--<i class="fa fa-caret-down" style="float:right;" ></i>-->
       </button>
      <div class="button-dropdown" [ngClass]="{'button-dropdown-up' : posixUp}"  [ngStyle]="dropdownstyle">
        <ng-container *ngFor="let itemData of dropdownItemData">
          <div [ngClass]="{'button-default': size=='default' || size ==null,'button-small': size=='small','button-large' : size=='large'}">
            <div [ngStyle]="{'cursor': itemData.disabled ? 'not-allowed':'pointer'}"
                 (click)="btnItemClick($event,itemData)">
              <amexio-form-icon style="padding-right: 5px;" [customclass]="itemData.iconStyleClass"></amexio-form-icon>
              <span [attr.disabled]="itemData.disabled ? true: null">{{itemData.label}}&nbsp;&nbsp;</span>
              <!--<i [class]="itemData.iconStyleClass" aria-hidden="true" style="float:right;" ></i>-->
              <ng-container *ngIf="itemData.badge">
              <span class="btn-dropdown-badge">{{itemData.badge}}</span>
              </ng-container>
            </div>
          </div>
        </ng-container>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioButtonDropdownComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
AmexioButtonDropdownComponent.propDecorators = {
    btnReference: [{ type: ViewChild, args: ['btnRef',] }],
    label: [{ type: Input }],
    buttons: [{ type: ContentChildren, args: [AmexioButtonDropDownItemComponent,] }],
    data: [{ type: Input, args: ['buttonGroupLocalData',] }],
    type: [{ type: Input }],
    disabled: [{ type: Input }],
    size: [{ type: Input }],
    badge: [{ type: Input, args: ['badge',] }],
    click: [{ type: Output }],
    getLinkData: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 13/12/17.
 */
class AmexioSpiltButtonDropdownComponent {
    constructor() {
        this.dropdownItemData = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.createDropdownItemConfig();
    }
    /**
     * @return {?}
     */
    createDropdownItemConfig() {
        let /** @type {?} */ itemRefArray = [];
        itemRefArray = this.buttons.toArray();
        for (const /** @type {?} */ itemConfig of itemRefArray) {
            const /** @type {?} */ data = {
                label: itemConfig.label,
                disabled: itemConfig.disabled,
                onItemClick: itemConfig.onItemClick,
                iconStyleClass: itemConfig.iconStyleClass,
                icon: itemConfig.icon,
                onClickRoute: itemConfig.onClickRoute,
            };
            data.iconStyleClass = data.icon;
            this.dropdownItemData.push(data);
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        this.openContent = !this.openContent;
    }
    /**
     * @param {?} event
     * @param {?} itemData
     * @return {?}
     */
    itemClick(event, itemData) {
        itemData.onItemClick.emit(event);
    }
    /**
     * @return {?}
     */
    getBackgroundColor() {
        let /** @type {?} */ colorCode;
        if (this.type === 'primary' || this.type === 'theme-color') {
            colorCode = '#0275d8';
        }
        else if (this.type === 'success' || this.type === 'green') {
            colorCode = '#5cb85c';
        }
        else if (this.type === 'danger' || this.type === 'red') {
            colorCode = '#d9534f';
        }
        else if (this.type === 'warning' || this.type === 'yellow') {
            colorCode = '#f0ad4e';
        }
        return {
            'background-color': colorCode,
        };
    }
}
AmexioSpiltButtonDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-btn-split-dropdown', template: `
    <div class="dropdown-button" [ngStyle]="getBackgroundColor()">
      <button class="button" [attr.disabled]="disabled ? true: null"
              [ngClass]="{'button-default': size=='default' || size ==null,
              'button-small': size=='small','button-large' : size=='large',
              'button-primary' : type == 'primary' || type == null,
              'button-success' : type == 'success',' button-danger' : type=='danger',
              'button-warning' : type=='warning'}">
        {{label}}
      </button>
      <button class="button"
              [ngClass]="{'button-default': size=='default' || size ==null,
              'button-small': size=='small',
              'button-large' : size=='large',
              'button-primary' : type == 'primary' || type == null || type == 'theme-color',
              'button-success' : type == 'success' || type == 'green',
              'button-danger' : type=='danger' || type == 'red',
              'button-warning' : type=='warning' ||  type == 'yellow'}">
              (click)="onClick()"><i class="fa fa-chevron-down" aria-hidden="true"></i></button>
      <div class="dropdown-button-content" [ngStyle]="{'display' : openContent ? 'block' : 'none'}">
        <ul class="dropdown-list">
          <ng-container *ngFor="let itemData of dropdownItemData">
            <li class="list-items" [ngClass]="{'disabled':itemData.disabled}" (click)="itemClick($event,itemData)">
            <ng-container *ngIf="itemData.icon!=null">
              <!--<i [class]="itemData.iconStyleClass" aria-hidden="true"></i>-->
              <amexio-form-icon style="padding-right: 5px;" [customclass]="itemData.iconStyleClass"></amexio-form-icon>
            </ng-container>{{itemData.label}}
            </li>
          </ng-container>
        </ul>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioSpiltButtonDropdownComponent.ctorParameters = () => [];
AmexioSpiltButtonDropdownComponent.propDecorators = {
    label: [{ type: Input }],
    badge: [{ type: Input, args: ['badge',] }],
    buttons: [{ type: ContentChildren, args: [AmexioButtonDropDownItemComponent,] }],
    type: [{ type: Input }],
    disabled: [{ type: Input }],
    size: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CheckboxComponent {
    /**
     * @param {?} checkboxGroup
     */
    constructor(checkboxGroup) {
        this.checkboxGroup = checkboxGroup;
    }
    /**
     * @return {?}
     */
    toggleCheck() {
        if (!this.checked) {
            this.checkboxGroup.add(this.value);
        }
        else {
            this.checkboxGroup.remove(this.value);
        }
        this.checked = !this.checked;
    }
    /**
     * @return {?}
     */
    isChecked() {
        return this.checked || this.checkboxGroup.contains(this.value);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        setTimeout(() => {
            if (this.checked) {
                this.checkboxGroup.add(this.value);
            }
        }, 200);
    }
}
CheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'checkbox',
                template: `
    <!-- <div style="display: flex;" (click)="toggleCheck()">
        <input class="form-control" type="checkbox" [checked]="isChecked()" />
        <label>{{label}}</label>
    </div> <br/> -->

    <label class="input-box-container" [ngClass]="{'disable-component' : disabled || disabled}">
        {{label}}
        <input type="checkbox" class="form-control" [ngClass]="{'checkbox-disable' : disabled}" [checked]="checked" (click)="toggleCheck()">
        <span class="input-box-checkbox-label"></span>
      </label>
  `,
            },] },
];
/** @nocollapse */
CheckboxComponent.ctorParameters = () => [
    { type: AmexioCheckBoxGroupComponent, decorators: [{ type: Host }] }
];
CheckboxComponent.propDecorators = {
    label: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioChipComponent {
    constructor() {
        /*
            Events
            name :  closeClick
            datatype : none
            version : none
            default : none
            description : It will fire only on selection of checkbox and gives you selected record data.
            */
        this.closeClick = new EventEmitter();
        /*
           Events
           name :  labelClick
           datatype : none
           version : none
           default : none
           description : It will fire only on selection of checkbox and gives you selected record data.
           */
        this.labelClick = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onCloseClick(event) {
        this.closeClick.emit(this.createObject());
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onLabelClick(event) {
        this.labelClick.emit(this.createObject());
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    createObject() {
        const /** @type {?} */ obj = {};
        obj['icon'] = this.icon;
        obj['label'] = this.label;
        obj['badge'] = this.badge;
        obj['closable'] = this.closable;
        obj['color'] = this.color;
        return obj;
    }
}
AmexioChipComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chip',
                template: `

    <div class="chips" style="cursor: pointer;" [ngStyle]="{'background-color': color}">
        <amexio-form-icon [customclass]="icon"></amexio-form-icon>
        <amexio-label (click)=" onLabelClick($event)">
          <span style="cursor: pointer;padding-left:10px">
            {{label}}
          </span>
        </amexio-label>
        <span class="badge" *ngIf="badge">{{badge}}</span>
        <ng-container *ngIf="closable">
          <i class="fa fa-times" style="cursor: pointer; margin-left:10px" (click)="onCloseClick($event) "></i>
        </ng-container>
      </div>
  `,
                styles: [`

  `],
            },] },
];
/** @nocollapse */
AmexioChipComponent.ctorParameters = () => [];
AmexioChipComponent.propDecorators = {
    icon: [{ type: Input, args: ['icon',] }],
    label: [{ type: Input, args: ['label',] }],
    color: [{ type: Input, args: ['color',] }],
    badge: [{ type: Input, args: ['badge',] }],
    closable: [{ type: Input, args: ['closable',] }],
    closeClick: [{ type: Output }],
    labelClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioChipsComponent {
    constructor() {
        /*
            Events
            name : selectedRowData
            datatype : none
            version : none
            default : none
            description : It will fire only on selection of checkbox and gives you selected record data.
            */
        this.selectedchipsData = new EventEmitter();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onCloseChipsClick(item) {
        this.data.forEach((element, index) => {
            if (element.label === item.label) {
                this.data.splice(index, 1);
            }
        });
        this.emitSelectedLabel(item);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    emitSelectedLabel(item) {
        this.selectedchipsData.emit(item);
    }
}
AmexioChipsComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chips',
                template: `
    <ng-container *ngIf="data?.length > 0; else elseBlock">
      <ng-container *ngFor="let item of data">
          <amexio-chip [icon]="item.icon" [label]="item.label" [badge]="item.badge" [closable]="item.closable" [color]="item.color"
              (closeClick)="onCloseChipsClick($event)" (labelClick)="emitSelectedLabel($event) ">
          </amexio-chip>
      </ng-container>
    </ng-container>
    <ng-template #elseBlock>
          <ng-content></ng-content>
    </ng-template>
  `,
                styles: [`

  `],
            },] },
];
/** @nocollapse */
AmexioChipsComponent.ctorParameters = () => [];
AmexioChipsComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    selectedchipsData: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioCreditCardModel {
    constructor() {
        this.owner = '';
        this.cvv = null;
        this.cardnumber = null;
        this.expMonth = 1;
        this.expYear = 2018;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const noop$7 = () => {
};
class AmexioCreditcardComponent {
    constructor() {
        /*
          Properties
          name : yearcount
          datatype : string
          version : 5.2.3onwards
          default :
          description : the minexp will set the dropdown to user defined dropdown.
          */
        this.yearcount = 12;
        /*
         Properties
         name : showlabel
         datatype : boolean
         version : 5.2.3onwards
         default :
         description : the showlabel will set the label of creditcard.
         */
        this.showlabel = 'false';
        this.isNameValid = false;
        this.isCvvValid = false;
        this.visaEagerReg = /^4/;
        this.visaReg = /^4\d{12}(\d{3}|\d{6})?$/;
        this.mastropattern = /^(?:5[06789]\d\d|(?!6011[0234])(?!60117[4789])(?!60118[6789])(?!60119)(?!64[456789])(?!65)6\d{3})\d{8,15}$/;
        this.masttroeagerPattern = /^(5(018|0[23]|[68])|6[37]|60111|60115|60117([56]|7[56])|60118[0-5]|64[0-3]|66)/;
        this.masterpattern = /^5[1-5]\d{14}$/;
        this.mastereagerPattern = /^5[1-5]/;
        this.isFullCardValid = false;
        this.cvvRegex = /^[0-9]{3,4}$/;
        this.year = new Date();
        this.yearList = [];
        this.eagarValue = '';
        this.fullPatternValue = '';
        this.onTouchedCallback = noop$7;
        this.onChangeCallback = noop$7;
        if (this.template === 'single-column') {
            this.templateFlag = true;
        }
        else if (this.template === 'double-column') {
            this.templateFlag = false;
        }
        this.creditCardModel = new AmexioCreditCardModel();
        this.dummyMonth = '0' + this.creditCardModel.expMonth;
        this.dateData = [
            {
                month: '01',
            },
            {
                month: '02',
            },
            {
                month: '03',
            },
            {
                month: '04',
            },
            {
                month: '05',
            },
            {
                month: '06',
            },
            {
                month: '07',
            },
            {
                month: '08',
            },
            {
                month: '09',
            },
            {
                month: '10',
            },
            {
                month: '11',
            },
            {
                month: '12',
            },
        ];
        this.cardGroupData = [
            {
                iconName: 'fa fa-cc-visa',
                key: 'eagerflagvisa',
                color: 'black',
            },
            {
                iconName: 'fa fa-cc-mastercard',
                key: 'mastereagerPattern',
                color: 'black',
            },
            {
                iconName: 'fa fa-credit-card',
                key: 'masttroeagerPattern',
                color: 'black',
            },
        ];
    }
    /**
     * @param {?} modelValue
     * @return {?}
     */
    writeValue(modelValue) {
        if (modelValue) {
            this.creditCardModel = modelValue;
            this.onChangeCardNumber(this.creditCardModel.cardnumber);
            this.onChangeMonth('0' + this.creditCardModel.expMonth);
            this.isNameValid = true;
            this.isCvvValid = this.cvvRegex.test(this.creditCardModel.cvv);
            this.cardRegexMap.forEach((value, key) => {
                const /** @type {?} */ isEagarValid = value.test(this.dummyCreditCardNumber);
                if (isEagarValid) {
                    this.eagarflag = isEagarValid;
                    this.eagarValue = key;
                }
            });
            this.validEagerCard = this.eagarValue;
            this.switchCaseMethod();
            this.onCheckValidation();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeCardNumber(event) {
        this.dummyCreditCardNumber = this.creditCardNumberSpaceRemove(event);
        const /** @type {?} */ concatCardNumber = this.replaceSpace(this.dummyCreditCardNumber);
        this.cardPatternMap.forEach((value, key) => {
            // Condition for Full String Regex
            this.isValidFullString = value.test(concatCardNumber);
            if (this.isValidFullString) {
                this.fullPatternflag = this.isValidFullString;
                this.fullPatternValue = key;
            }
        });
        this.validPatternCard = this.fullPatternValue;
        this.creditCardModel.cardnumber = +concatCardNumber;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} inp
     * @return {?}
     */
    onNameClick(inp) {
        if (inp.model.length > 0) {
            this.isNameValid = true;
        }
        else {
            this.isNameValid = false;
        }
    }
    /**
     * @param {?} inpcvv
     * @return {?}
     */
    onClick(inpcvv) {
        this.isCvvValid = this.cvvRegex.test(inpcvv.model);
    }
    /**
     * @param {?} inp
     * @return {?}
     */
    onInput(inp) {
        // Condition for null check
        if (inp.model !== '') {
            let /** @type {?} */ isValidFullString;
            let /** @type {?} */ fullPatternValue = '';
            const /** @type {?} */ concatValue = this.replaceSpace(inp.model);
            this.cardPatternMap.forEach((value, key) => {
                // Condition for Full String Regex
                isValidFullString = value.test(concatValue);
                if (isValidFullString) {
                    fullPatternValue = key;
                }
            });
            this.validPatternCard = fullPatternValue;
            let /** @type {?} */ eagarValue = '';
            this.cardRegexMap.forEach((value, key) => {
                const /** @type {?} */ isEagarValid = value.test(concatValue);
                if (isEagarValid) {
                    eagarValue = key;
                }
            });
            this.validEagerCard = eagarValue;
        }
        else {
            this.validEagerCard = '';
        }
        this.switchCaseMethod();
        this.onCheckValidation();
        if (inp.model !== '') {
            this.cardNumberValue = this.creditCardNumberSpaceRemove(inp.model);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    replaceSpace(value) {
        let /** @type {?} */ newString = '';
        if (value) {
            const /** @type {?} */ stringArray = value.split(' ');
            if (stringArray) {
                stringArray.forEach((element) => {
                    newString = newString.concat(element);
                });
            }
        }
        return newString;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.cardRegexMap = new Map();
        this.cardPatternMap = new Map();
        this.cardRegexMap.set('eagerflagvisa', this.visaEagerReg);
        this.cardRegexMap.set('mastereagerPattern', this.mastereagerPattern);
        this.cardRegexMap.set('masttroeagerPattern', this.masttroeagerPattern);
        this.cardPatternMap.set('visaReg', this.visaReg);
        this.cardPatternMap.set('masterpattern', this.masterpattern);
        this.cardPatternMap.set('mastropattern', this.mastropattern);
        this.cardName = '';
        this.currentYear = this.year.getFullYear();
        if (this.template === 'single-column') {
            this.templateFlag = true;
        }
        else if (this.template === 'double-column') {
            this.templateFlag = false;
        }
        for (let /** @type {?} */ i = 0; i < this.yearcount; i++) {
            this.yearList.push(this.currentYear + i);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    creditCardNumberSpaceRemove(value) {
        value = value.toString();
        const /** @type {?} */ v = value.replace(/\s+/g, '').replace(/[^0-9]/gi, '');
        const /** @type {?} */ matches = v.match(/\d{4,16}/g);
        const /** @type {?} */ match = matches && matches[0] || '';
        const /** @type {?} */ parts = [];
        let /** @type {?} */ len;
        let /** @type {?} */ i;
        for (i = 0, len = match.length; i < len; i += 4) {
            parts.push(match.substring(i, i + 4));
        }
        if (parts.length) {
            return parts.join(' ');
        }
        else {
            return value;
        }
    }
    /**
     * @return {?}
     */
    switchCaseMethod() {
        switch (this.validEagerCard) {
            case 'eagerflagvisa':
                this.cardName = 'fa fa-cc-visa';
                break;
            case 'mastereagerPattern':
                this.cardName = 'fa fa-cc-mastercard';
                break;
            case 'masttroeagerPattern':
                this.cardName = 'fa fa-credit-card';
                break;
            case '':
                this.cardName = '';
                break;
            default:
                this.cardName = '';
                break;
        }
    }
    /**
     * @return {?}
     */
    onCheckValidation() {
        this.cardGroupData.forEach((element) => {
            if (element.key === this.validEagerCard) {
                element.color = 'blue';
            }
            else {
                element.color = 'black';
            }
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeMonth(event) {
        this.dummyMonth = event;
        this.creditCardModel.expMonth = +this.dummyMonth;
    }
}
AmexioCreditcardComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-creditcard',
                template: `
    <!-- <pre><code>{{creditCardModel|json}}</code></pre> -->
    <ng-container *ngIf="templateFlag">

            <div class="creditCardFormSglCol">
                <div class="imageSglCol">
                    <i *ngFor="let cardimage of cardGroupData" [style.color]="cardimage.color" [attr.class]="cardimage.iconName" style="font-size:50px">
                    </i>
                </div>
                <div class="ownerdetailsSglCol">
                    <label *ngIf="showlabel">CARD HOLDER NAME</label>
                    <div class="ownerSglCol">
                        <input [ngClass]="{'input-control-success':isNameValid,'input-control-failure':(!isNameValid && inpowner.touched)}" type="text" placeholder="CARD HOLDER NAME"
                            #inpowner="ngModel" class="input-control" [(ngModel)]="creditCardModel.owner" (keyup)="onNameClick(inpowner)">
                    </div>
                </div>
        
                <div class="cardNumberSglCol">
                    <label *ngIf="showlabel">CARD NUMBER</label>
                    <input type="text" placeholder="CARD NUMBER" maxlength="19" class="input-control" [ngModel]="dummyCreditCardNumber" (ngModelChange)="onChangeCardNumber($event)"
                    [value]="cardNumberValue" #inp="ngModel" [ngClass]="{'input-control-success':validPatternCard,'input-control-failure':(!validPatternCard && (inp.dirty || inp.touched))}" (keyup)="onInput(inp)"
                    />
                </div>
                <label *ngIf="showlabel">EXP DATE</label>
                <div class="expiration-dateSglCol">
                    <div class="monthSglCol">
                        <select [ngModel]="dummyMonth" (ngModelChange)="onChangeMonth($event)" placeholder="MM" style="padding:10px">
                            <option *ngFor="let months of dateData">{{months.month}}</option>
                        </select>
                    </div>
                    <div class="dateSglCol">
                        <select [(ngModel)]="creditCardModel.expYear" yearControl="yearControl" style="padding:10px" placeholder="YY">
                            <option *ngFor="let year of yearList">{{year}}</option>
                        </select>
                    </div>
                </div>
                <div class="cvvSglCol">
                    <label *ngIf="showlabel">CVV</label>
                    <input #inpcvv="ngModel" [ngClass]="{'input-control-success':isCvvValid,'input-control-failure':(!isCvvValid && inpcvv.touched)}"
                        type="password" placeholder="CVV" maxlength="3" class="input-control" [(ngModel)]="creditCardModel.cvv" (keyup)="onClick(inpcvv)">
                </div>
            </div>
            </ng-container>
            <br>
            <ng-container *ngIf="!templateFlag">
            <div class="creditCardForm">
                <div class="owner">
                    <label *ngIf="showlabel">CARD HOLDER NAME</label>
                    <input [ngClass]="{'input-control-success':isNameValid,'input-control-failure':(!isNameValid && inpowner.touched)}" type="text" placeholder="CARD HOLDER NAME"
                       #inpowner="ngModel" class="input-control" [(ngModel)]="creditCardModel.owner" (keyup)="onNameClick(inpowner)">
                </div>
                <div [ngClass]="{'image-label':showlabel==true,'image':showlabel==false}">
                    <i *ngFor="let cardimage of cardGroupData" [style.color]="cardimage.color" [attr.class]="cardimage.iconName" style="font-size:40px"></i>
                </div>
        
        
                <div class="cardNumber">
                    <label *ngIf="showlabel">CARD NUMBER</label>
                    <input type="text" placeholder="CARD NUMBER" maxlength="19" class="input-control" [ngModel]="dummyCreditCardNumber" (ngModelChange)="onChangeCardNumber($event)"
                    [value]="cardNumberValue"   #inp="ngModel" [ngClass]="{'input-control-success':validPatternCard,'input-control-failure':(!validPatternCard && (inp.dirty || inp.touched))}" (keyup)="onInput(inp)" />
                </div>
        
                <div [ngClass]="{'expiration-date-label':showlabel==true,'expiration-date':showlabel==false}" >
                    <label *ngIf="showlabel">EXP DATE</label>
                    <div class="exp-month-date-label">
                        <div class="month">
                            <select [ngModel]="dummyMonth" (ngModelChange)="onChangeMonth($event)" style="padding:10px" placeholder="MM">
                                <option *ngFor="let months of dateData">{{months.month}}</option>
                            </select>
                        </div>
                        <div class="date">
                            <select [(ngModel)]="creditCardModel.expYear" yearControl="yearControl" style="padding:10px" placeholder="YY">
                                <option *ngFor="let year of yearList">{{year}}</option>
                            </select>
                        </div>
                    </div>
        
                </div>
        
                <div class="cvv">
                    <label *ngIf="showlabel">CVV</label>
                    <input #inpcvv="ngModel" [ngClass]="{'input-control-success':isCvvValid,'input-control-failure':(!isCvvValid && (inpcvv.dirty ||inpcvv.touched))}"
                        type="password" placeholder="CVV" maxlength="3" class="input-control" [(ngModel)]="creditCardModel.cvv" (keyup)="onClick(inpcvv)">
                </div>
            </div>
            </ng-container>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioCreditcardComponent), multi: true,
                    }],
                styles: [`

  `],
            },] },
];
/** @nocollapse */
AmexioCreditcardComponent.ctorParameters = () => [];
AmexioCreditcardComponent.propDecorators = {
    yearcount: [{ type: Input, args: ['year-count',] }],
    showlabel: [{ type: Input, args: ['show-label',] }],
    template: [{ type: Input, args: ['template',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class ListBaseDatepickerComponent extends AmexioFormValidator {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} cd
     */
    constructor(renderer, element, cd) {
        super();
        this.renderer = renderer;
        this.element = element;
        this.cd = cd;
        this.self = false;
        this.itemClick = false;
        this.hide();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focus(event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'visible' };
        this.bindDocumentClickListener();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    blur(event) {
        this.itemClicked();
    }
    /**
     * @return {?}
     */
    itemClicked() {
        this.itemClick = true;
        this.hide();
        this.unbindDocumentClickListener();
        this.clearClicks();
    }
    /**
     * @return {?}
     */
    bindDocumentClickListener() {
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer
                .listen('document', 'click', (event) => this.handleDocumentListener(event));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleDocumentListener(event) {
        if (!this.self && !this.itemClick) {
            this.hide();
            this.unbindDocumentClickListener();
        }
        this.clearClicks();
        this.cd.markForCheck();
    }
    /**
     * @return {?}
     */
    clearClicks() {
        this.self = false;
        this.itemClick = false;
    }
    /**
     * @return {?}
     */
    unbindDocumentClickListener() {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    }
    /**
     * @return {?}
     */
    hide() {
        this.dropdownstyle = { visibility: 'hidden' };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const noop$8 = () => {
};
class AmexioDateTimePickerComponent extends ListBaseDatepickerComponent {
    /**
     * @param {?} element
     * @param {?} cdf
     * @param {?} renderer
     */
    constructor(element, cdf, renderer) {
        super(renderer, element, cdf);
        this.element = element;
        this.cdf = cdf;
        /*
           Properties
           name : diabled-date
           datatype :  any
           version : 4.2 onwards
           default : none
           description : sets disabled dates range
           */
        this.diabledDate = [];
        /*
           Properties
           name : inline-datepicker
           datatype :  boolean
           version : 4.2 onwards
           default : none
           description : sets inline calender
           */
        this.inlineDatepicker = false;
        /*
           Properties
           name : dropdown-datepicker
           datatype :  boolean
           version : 4.2 onwards
           default : none
           description : sets dropdown datepicker
           */
        this.dropdownDatepicker = false;
        /*
           Properties
           name : required
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : Flag to allow blank field or not
           */
        this.required = false;
        /*
           Events
           name : blur
           description : On blur event
           */
        // @Output() blur: EventEmitter<any> = new EventEmitter<any>();
        /*
           Properties
           name : change
           description : On field value change event
           */
        this.change = new EventEmitter();
        /*
           Properties
           name : input
           description : On input event field.
           */
        this.input = new EventEmitter();
        this.drop = false;
        this.tempFlag = true;
        this.hostFlag = false;
        this.isComponentValid = new EventEmitter();
        this.backArrowFlag = false;
        this.forwardArrowFlag = false;
        this.innerValue = '';
        this.onTouchedCallback = noop$8;
        this.onChangeCallback = noop$8;
        this.viewmode = '1';
        this.yearList1 = [{ year: 0, flag: false, disabled: false }, { year: 0, flag: false, disabled: false },
            { year: 0, flag: false, disabled: false }, { year: 0, flag: false, disabled: false },
            { year: 0, flag: false, disabled: false }];
        this.yearList2 = [{ year: 0, flag: false, disabled: false }, { year: 0, flag: false, disabled: false },
            { year: 0, flag: false, disabled: false }, { year: 0, flag: false, disabled: false },
            { year: 0, flag: false, disabled: false }];
        this.monthList1 = [{ name: 'Jan', flag: false, num: 4 }, { name: 'Feb', flag: false },
            { name: 'Mar', flag: false }, { name: 'Apr', flag: false }, { name: 'May', flag: false },
            { name: 'Jun', flag: false }];
        this.monthList2 = [{ name: 'Jul', flag: false }, { name: 'Aug', flag: false }, { name: 'Sep', flag: false },
            { name: 'Oct', flag: false }, { name: 'Nov', flag: false }, { name: 'Dec', flag: false }];
        this.minDate = '';
        this.maxDate = '';
        this.elementId = new Date().getTime() + '';
        this.selectedDate = new Date();
        this.currrentDate = new Date();
        this.curYear = this.currrentDate.getFullYear();
        let /** @type {?} */ i = 0;
        let /** @type {?} */ j = 0;
        for (i = 4; i >= 0; i--) {
            this.yearList1[j].year = this.curYear - i;
            j++;
        }
        j = 0;
        for (i = 1; i <= 5; i++) {
            this.yearList2[j].year = this.curYear + i;
            j++;
        }
        this.daysTitle = [];
        this.daysArray = [];
        this.timepicker = false;
        this.hrs = this.currrentDate.getHours();
        this.min = this.currrentDate.getMinutes();
        this.initDaysTitle();
        this.createDaysForCurrentMonths(this.currrentDate);
        this.monthList1.forEach((tmpElement) => {
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.inlineDatepicker) {
            this.showToolTip = true;
            this.dropdownstyle = { visibility: 'visible' };
        }
        this.isValid = !this.required;
        this.isComponentValid.emit(!this.required);
        if (this.dateformat != null) {
            this.dateformat = 'dd/MM/yyyy';
        }
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            this.minMaxDateFound();
        } // main if ends
        // logic for disabling yrs before min and after max
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            const /** @type {?} */ min = new Date(this.minDate);
            const /** @type {?} */ max = new Date(this.maxDate);
            this.yearList1.forEach((element) => {
                this.disableMinMaxYear(element, min, max);
            });
            this.yearList2.forEach((element) => {
                this.disableMinMaxYear(element, min, max);
            });
        }
    }
    /**
     * @return {?}
     */
    initDaysTitle() {
        this.daysTitle.push({ text: 'Mo' });
        this.daysTitle.push({ text: 'Tu' });
        this.daysTitle.push({ text: 'We' });
        this.daysTitle.push({ text: 'Th' });
        this.daysTitle.push({ text: 'Fr' });
        this.daysTitle.push({ text: 'Sa' });
        this.daysTitle.push({ text: 'Su' });
    }
    /**
     * @param {?} selectedPeriod
     * @return {?}
     */
    createDaysForCurrentMonths(selectedPeriod) {
        this.daysArray = [];
        const /** @type {?} */ date = new Date(selectedPeriod.getFullYear(), selectedPeriod.getMonth(), 1, 0, 0, 0, 0); // Starting at the 1st of the month
        const /** @type {?} */ extras = (date.getDay() + 6) % 7; // How many days of the last month do we need to include?
        date.setDate(date.getDate() - extras); // Skip back to the previous monday
        while (this.daysArray.length < 6) {
            const /** @type {?} */ rowDays = [];
            for (let /** @type {?} */ i = 0; i < 7; i++) {
                const /** @type {?} */ day = {
                    date: null, selected: false, isCurrentMonth: null, isDisabled: false,
                };
                day.date = new Date(date.getTime());
                day.isCurrentMonth = (date.getMonth() === selectedPeriod.getMonth());
                if (this.dateModel && (date.getMonth() === this.dateModel.getMonth()) && (date.getDate() === this.dateModel.getDate())) {
                    day.selected = true;
                }
                else if ((date.getMonth() === this.currrentDate.getMonth()) && (date.getDate() === this.currrentDate.getDate())) {
                    if (this.dateModel) {
                        day.selected = false;
                    }
                    else {
                        day.selected = true;
                    }
                }
                rowDays.push(day);
                date.setDate(date.getDate() + 1);
            }
            this.daysArray.push(rowDays);
        }
    }
    /**
     * @param {?} dateObj
     * @return {?}
     */
    onDateClick(dateObj) {
        if (this.inlineDatepicker === false) {
            super.itemClicked();
        }
        this.hostFlag = true;
        this.selectedDate = dateObj;
        this.selectedDate.setHours(this.hrs);
        this.selectedDate.setMinutes(this.min);
        this.resetSelection(dateObj);
        this.dateModel = this.selectedDate;
        this.value = this.selectedDate;
        this.isValid = true;
        this.isComponentValid.emit(true);
        if (this.inlineDatepicker) {
            this.showToolTip = true;
        }
        else {
            this.showToolTip = !this.showToolTip;
        }
    }
    /**
     * @param {?} dateObj
     * @return {?}
     */
    resetSelection(dateObj) {
        for (const /** @type {?} */ i of this.daysArray) {
            for (const /** @type {?} */ j of i) {
                const /** @type {?} */ day = j;
                if (day.date.getTime() === dateObj.getTime()) {
                    day.selected = true;
                }
                else {
                    day.selected = false;
                }
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInput(event) {
        if (event.target.value != null && event.target.value !== '') {
            const /** @type {?} */ timeValue = event.target.value.split(':');
            if (timeValue != null) {
                const /** @type {?} */ hrs = parseInt(timeValue[0].trim(), 10);
                const /** @type {?} */ mins = parseInt(timeValue[1].trim(), 10);
                this.selectedDate.setHours(hrs);
                this.selectedDate.setMinutes(mins);
                this.hrs = hrs;
                this.min = mins;
                this.value = this.selectedDate;
                this.change.emit(this.value);
                event.stopPropagation();
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    nextMonth(event) {
        this.setDateData('plus', 1, event);
        this.disableddays(this.diabledDate);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    prevMonth(event) {
        this.setDateData('minus', 1, event);
        this.disableddays(this.diabledDate);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    nextYear(event) {
        this.setDateData1('plus', 12, event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    prevYear(event) {
        this.setDateData1('minus', 12, event);
    }
    /**
     * @param {?} state
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    setDateData(state, mon, event) {
        const /** @type {?} */ d = new Date(this.currrentDate.getFullYear(), this.currrentDate.getMonth(), this.currrentDate.getDate());
        const /** @type {?} */ min = new Date(this.minDate);
        const /** @type {?} */ max = new Date(this.maxDate);
        // checks if selected date is within maximum range of month
        if (state === 'plus') {
            this.setPlusData(d, max, mon);
        }
        else if (state === 'minus') {
            this.setMinusData(d, min, mon);
        }
        this.currrentDate = d;
        this.initDate();
        event.stopPropagation();
    }
    /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    setPlusData(d, max, mon) {
        if (this.maxDate.length > 0) {
            if (d.getFullYear() === max.getFullYear()) {
                this.setMaxFullYear(d, max, mon);
            }
            else {
                // logic to chk if year is valid
                if (d.getFullYear() <= max.getFullYear()) {
                    d.setMonth(d.getMonth() + mon);
                }
            }
        }
        else {
            // outer ends
            d.setMonth(d.getMonth() + mon);
        } // checks if selected date is within minimum range of month
    }
    /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    setMaxFullYear(d, max, mon) {
        if ((d.getMonth() !== max.getMonth()) && d.getFullYear() <= max.getFullYear() && d.getMonth() <= max.getMonth()) {
            d.setMonth(d.getMonth() + mon);
        }
    }
    /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    setMinusData(d, min, mon) {
        if (this.minDate.length > 0) {
            if (d.getFullYear() === min.getFullYear()) {
                this.setMinFullYear(d, min, mon);
            }
            else {
                d.setMonth(d.getMonth() - mon);
            }
        }
        else {
            d.setMonth(d.getMonth() - mon);
        }
    }
    /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    setMinFullYear(d, min, mon) {
        if ((d.getMonth() !== min.getMonth()) && d.getFullYear() >= min.getFullYear() && d.getMonth() >= min.getMonth()) {
            // logic to chk if year is valid
            d.setMonth(d.getMonth() - mon);
        }
    }
    /**
     * @param {?} state
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    setDateData1(state, mon, event) {
        const /** @type {?} */ d = new Date(this.currrentDate.getFullYear(), this.currrentDate.getMonth(), this.currrentDate.getDate());
        const /** @type {?} */ min = new Date(this.minDate);
        const /** @type {?} */ max = new Date(this.maxDate);
        // checks if selected date is within maximum range of year
        if (state === 'plus') {
            if (this.maxDate.length > 0) {
                if (d.getFullYear() <= max.getFullYear() - 1) {
                    d.setMonth(d.getMonth() + mon);
                }
            }
            else {
                d.setMonth(d.getMonth() + mon);
            } // checks if selected date is within minimum range of year
        }
        else if (state === 'minus') {
            if (this.minDate.length > 0) {
                if (d.getFullYear() >= min.getFullYear() + 1) {
                    d.setMonth(d.getMonth() - mon);
                }
            }
            else {
                d.setMonth(d.getMonth() - mon);
            }
        }
        this.currrentDate = d;
        this.initDate();
        event.stopPropagation();
    }
    /**
     * @return {?}
     */
    setToday() {
        this.currrentDate = new Date();
        this.initDate();
        this.showToolTip = !this.showToolTip;
    }
    /**
     * @return {?}
     */
    initDate() {
        this.daysArray = [];
        this.createDaysForCurrentMonths(this.currrentDate);
        this.selectedDate = this.currrentDate;
        this.dateModel = this.selectedDate;
        this.value = this.selectedDate;
        this.innerValue = '';
    }
    /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    plus(type, event) {
        if (type === 'min') {
            if (this.min === 59) {
                this.min = -1;
                this.hrs++;
            }
            this.min++;
        }
        if (type === 'hrs') {
            this.hrs++;
        }
        if (this.hrs === 24) {
            this.hrs = 0;
        }
        this.selectedDate.setHours(this.hrs);
        this.selectedDate.setMinutes(this.min);
        this.value = this.selectedDate;
        this.isValid = true;
        this.isComponentValid.emit(true);
        this.change.emit(this.value);
        event.stopPropagation();
    }
    /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    minus(type, event) {
        if (type === 'min') {
            if (this.min === 0) {
                this.min = 60;
                this.hrs--;
            }
            this.min--;
        }
        if (type === 'hrs') {
            this.hrs--;
        }
        if (this.hrs === 0) {
            this.hrs = 23;
        }
        this.selectedDate.setHours(this.hrs);
        this.selectedDate.setMinutes(this.min);
        this.value = this.selectedDate;
        this.isValid = true;
        this.isComponentValid.emit(true);
        this.change.emit(this.value);
        event.stopPropagation();
    }
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.onTouchedCallback();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== '') {
            if (value !== this.innerValue) {
                this.validateWriteValue(value);
            }
        }
        else {
            this.dateModel = '';
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    validateWriteValue(value) {
        this.innerValue = value;
        if (this.innerValue instanceof Date || ('number' === typeof this.innerValue)) {
            if (('number' === typeof this.innerValue)) {
                this.innerValue = new Date(this.innerValue);
            }
            this.dateModel = this.innerValue;
            this.currrentDate = this.dateModel;
            this.selectedDate = this.currrentDate;
            this.createDaysForCurrentMonths(this.dateModel);
            if (this.required) {
                this.isValid = true;
            }
        }
        else {
            this.negateisValid();
        }
    }
    /**
     * @return {?}
     */
    negateisValid() {
        this.isValid = false;
        this.hrs = 0;
        this.min = 0;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onFocus(elem) {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onFocusOut(value) {
        if (isNaN(Date.parse(value.value))) {
            this.isValid = false;
            value.value = '';
        }
        else {
            this.value = Date.parse(value.value);
            this.isValid = true;
        }
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    openPicker(elem) {
        super.focus(elem);
        this.hostFlag = false;
        this.pickerele = elem;
        if (this.inlineDatepicker) {
            this.showToolTip = this.inlineDatepicker;
        }
        else {
            this.showToolTip = true;
        }
        this.posixUp = this.getListPosition(elem);
        this.disableddays(this.diabledDate);
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        const /** @type {?} */ dropdownHeight = 350; // must be same in dropdown.scss
        if (window.innerHeight - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
            if ((elementRef.getBoundingClientRect().top - dropdownHeight - elementRef.getBoundingClientRect().height) > 0) {
                this.positionClass = {
                    top: (elementRef.getBoundingClientRect().top - dropdownHeight - elementRef.getBoundingClientRect().height) + 'px',
                };
            }
            else if ((dropdownHeight - elementRef.getBoundingClientRect().top) > 0) {
                this.positionClass = {
                    top: (dropdownHeight - elementRef.getBoundingClientRect().top) + 'px',
                };
            }
            else if ((elementRef.getBoundingClientRect().top - dropdownHeight) > 0) {
                this.positionClass = {
                    top: (elementRef.getBoundingClientRect().top - dropdownHeight) + 'px',
                };
            }
            return true;
        }
        else {
            this.positionClass = {
                top: (elementRef.getBoundingClientRect().top + elementRef.getBoundingClientRect().height) + 'px'
            };
            return false;
        }
    }
    /**
     * @return {?}
     */
    onSelect() {
        this.showToolTip = false;
    }
    /**
     * @param {?} days
     * @return {?}
     */
    validateDays(days) {
        const /** @type {?} */ max = new Date(this.maxDate);
        const /** @type {?} */ min = new Date(this.minDate);
        // check1: if min max is null return false
        if (this.maxDate.length <= 0 && this.minDate.length <= 0) {
            return false;
        }
        if ((this.maxDate.length > 0 && this.minDate.length <= 0) ||
            (this.maxDate.length > 0 && this.minDate.length > 0)) {
            this.validateMaxDate(days, max);
        }
        if ((this.maxDate.length <= 0 && this.minDate.length > 0) || (this.maxDate.length > 0 && this.minDate.length > 0)) {
            // 3
            if (days.getDate() < min.getDate() &&
                days.getMonth() === min.getMonth() && days.getFullYear() === min.getFullYear()) {
                return true;
                // 4
            }
            else if (days.getMonth() < min.getMonth() && days.getFullYear() === min.getFullYear()) {
                return true;
            }
        }
        this.disableddays(this.diabledDate);
    }
    /**
     * @param {?} days
     * @param {?} max
     * @return {?}
     */
    validateMaxDate(days, max) {
        // check if days greater than max return
        // 1
        if (days.getDate() > max.getDate() &&
            days.getMonth() >= max.getMonth() && days.getFullYear() >= max.getFullYear()) {
            return true;
            // 2
        }
        else if (days.getMonth() > max.getMonth() && days.getFullYear() === max.getFullYear()) {
            return true;
        }
    }
    /**
     * @param {?} dates
     * @return {?}
     */
    disableddays(dates) {
        if (dates) {
            dates.forEach((element) => {
                const /** @type {?} */ From = new Date(element.from);
                const /** @type {?} */ To = new Date(element.to);
                this.daysArray.forEach((element2) => {
                    element2.forEach((element1) => {
                        if (element1.date.getFullYear() <= To.getFullYear() && element1.date.getMonth()
                            <= To.getMonth() && element1.date.getDate() <= To.getDate() && element1.date.getFullYear() >= From.getFullYear() &&
                            element1.date.getMonth() >= From.getMonth() &&
                            element1.date.getDate() >= From.getDate()) {
                            element1.isDisabled = true;
                        }
                    });
                });
            });
        }
    }
    /**
     * @return {?}
     */
    dropdownDatePicker() {
        this.monthList1.forEach((element) => {
            this.elementFlagMethod(element);
        });
        this.monthList2.forEach((element) => {
            this.elementFlagMethod(element);
        });
        this.yearList1.forEach((element) => {
            this.elementFlagMethod(element);
        });
        this.yearList2.forEach((element) => {
            this.elementFlagMethod(element);
        });
        this.hostFlag = true;
        this.tempFlag = false;
        this.drop = true;
        super.focus({});
    }
    /**
     * @param {?} element
     * @return {?}
     */
    elementFlagMethod(element) {
        if (element.flag) {
            element.flag = false;
        }
    }
    /**
     * @return {?}
     */
    negateDrop() {
        this.hostFlag = true;
        this.drop = false;
        this.showToolTip = true;
        this.tempFlag = true;
    }
    /**
     * @param {?} month
     * @return {?}
     */
    getDropdownMonth(month) {
        this.monthList1.forEach((element) => {
            this.elementFlagMethod(element);
        });
        this.monthList2.forEach((element) => {
            this.elementFlagMethod(element);
        });
        this.monthList1.forEach((element) => {
            this.chkMonth(element, month);
        });
        this.monthList2.forEach((element) => {
            this.chkMonth(element, month);
        });
        switch (month.name) {
            case 'Jan':
                this.monthNo = 0;
                break;
            case 'Feb':
                this.monthNo = 1;
                break;
            case 'Mar':
                this.monthNo = 2;
                break;
            case 'Apr':
                this.monthNo = 3;
                break;
            case 'May':
                this.monthNo = 4;
                break;
            case 'Jun':
                this.monthNo = 5;
                break;
            case 'Jul':
                this.monthNo = 6;
                break;
            case 'Aug':
                this.monthNo = 7;
                break;
            case 'Sep':
                this.monthNo = 8;
                break;
            case 'Oct':
                this.monthNo = 9;
                break;
            case 'Nov':
                this.monthNo = 10;
                break;
            case 'Dec':
                this.monthNo = 11;
                break;
            default:
                break;
        }
        super.focus({});
    }
    /**
     * @param {?} element
     * @param {?} month
     * @return {?}
     */
    chkMonth(element, month) {
        if (element.name === month.name) {
            element.flag = true;
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    yearFlagNegate(element) {
        this.elementFlagMethod(element);
    }
    /**
     * @param {?} element
     * @param {?} year
     * @return {?}
     */
    yearFlag(element, year) {
        if (element.year === year.year) {
            element.flag = true;
        }
    }
    /**
     * @param {?} year
     * @return {?}
     */
    getDropdownYear(year) {
        this.yearList1.forEach((element) => {
            // negate dropdown year flag
            this.yearFlagNegate(element);
        });
        this.yearList2.forEach((element) => {
            // negate dropdown year flag
            this.yearFlagNegate(element);
        });
        this.yearList1.forEach((element) => {
            this.yearFlag(element, year);
        });
        this.yearList2.forEach((element) => {
            this.yearFlag(element, year);
        });
        this.yearNo = year.year;
        super.focus({});
    }
    /**
     * @return {?}
     */
    navigateDropdown() {
        this.hostFlag = true;
        this.selectedDate = new Date();
        if (this.yearNo != null && this.monthNo != null) {
            this.selectedDate.setFullYear(this.yearNo);
            this.selectedDate.setMonth(this.monthNo);
        }
        else if (this.yearNo != null && this.monthNo === null) {
            this.selectedDate.setFullYear(this.yearNo);
        }
        else if (this.yearNo === null && this.monthNo != null) {
            this.selectedDate.setMonth(this.monthNo);
        }
        this.drop = false;
        this.daysArray = [];
        this.createDaysForCurrentMonths(this.selectedDate);
        this.disableddays(this.diabledDate);
        this.tempFlag = true;
        this.cdf.detectChanges();
        this.yearList1.forEach((element) => {
            this.elementFlagMethod(element);
        });
        this.yearList2.forEach((element) => {
            this.elementFlagMethod(element);
        });
        this.daysArray = [];
        this.createDaysForCurrentMonths(this.selectedDate);
        this.disableddays(this.diabledDate);
        super.focus({});
    }
    /**
     * @return {?}
     */
    cancelDropdown() {
        this.drop = false;
        this.showToolTip = true;
    }
    /**
     * @return {?}
     */
    arrowClickBack() {
        let /** @type {?} */ i;
        // disable flag logic
        this.disableYearFlag();
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            // arrow click logic
            this.backArrow();
        }
        else {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year - 10;
                this.yearList2[i].year = this.yearList2[i].year - 10;
            } // for ends
        } // main else ends
        // disable flag logic
        this.disableYearFlag();
        // rechking arrow flags after reinitialization of yrlist1 & 2
        this.rechkYearFlag();
    }
    /**
     * @return {?}
     */
    backArrow() {
        const /** @type {?} */ min = new Date(this.minDate);
        const /** @type {?} */ max = new Date(this.maxDate);
        this.yearList1.forEach((element) => {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear() && element.year !== min.getFullYear()) {
                this.forwardArrowFlag = true;
                this.backArrowFlag = false;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                this.forwardArrowFlag = false;
                this.backArrowFlag = false;
            }
        });
        // resets Arrow Flag
        this.resetYearFlag();
    }
    /**
     * @param {?} element
     * @param {?} min
     * @return {?}
     */
    alterBackArrow(element, min) {
        if (element.year === min.getFullYear()) {
            this.backArrowFlag = true;
        }
    }
    /**
     * @return {?}
     */
    resetArrowFlag() {
        const /** @type {?} */ min = new Date(this.minDate);
        const /** @type {?} */ max = new Date(this.maxDate);
        this.yearList2.forEach((element) => {
            this.alterBackArrow(element, min);
            if (element.year === max.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.forwardArrowFlag = true;
            }
        });
    }
    /**
     * @return {?}
     */
    resetYearFlag() {
        let /** @type {?} */ i;
        if (!this.backArrowFlag) {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year - 10;
                this.yearList2[i].year = this.yearList2[i].year - 10;
                this.yearList1[i].disabled = false;
                this.yearList2[i].disabled = false;
            }
        } /* if ends */
    }
    /**
     * @param {?} element
     * @return {?}
     */
    alterBackForwardArrow(element) {
        const /** @type {?} */ min = new Date(this.minDate);
        const /** @type {?} */ max = new Date(this.maxDate);
        if (element.year === min.getFullYear()) {
            this.backArrowFlag = true;
        }
        if (element.year === max.getFullYear() ||
            (element.year === min.getFullYear() && element.year === max.getFullYear())) {
            this.forwardArrowFlag = true;
        }
    }
    /**
     * @return {?}
     */
    forwardArrow() {
        let /** @type {?} */ i;
        // chk yearlist1
        this.chkYearList1();
        this.yearList2.forEach((element) => {
            this.alterBackForwardArrow(element);
        });
        if (!this.forwardArrowFlag) {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year + 10;
                this.yearList2[i].year = this.yearList2[i].year + 10;
                this.yearList1[i].disabled = false;
                this.yearList2[i].disabled = false;
            } // for ends
        } // if ends
    }
    /**
     * @return {?}
     */
    chkYearList1() {
        const /** @type {?} */ min = new Date(this.minDate);
        const /** @type {?} */ max = new Date(this.maxDate);
        this.yearList1.forEach((element) => {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.backArrowFlag = true;
            }
            if (element.year === min.getFullYear() && element.year !== max.getFullYear()) {
                this.forwardArrowFlag = false;
                this.backArrowFlag = true;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                this.forwardArrowFlag = false;
                this.backArrowFlag = false;
            }
            if (element.year === max.getFullYear()) {
                this.forwardArrowFlag = true;
            }
        });
    }
    /**
     * @return {?}
     */
    rechkYearFlag() {
        this.yearList1.forEach((element) => {
            const /** @type {?} */ min = new Date(this.minDate);
            const /** @type {?} */ max = new Date(this.maxDate);
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear()) {
                this.forwardArrowFlag = true;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                this.forwardArrowFlag = false;
                this.backArrowFlag = false;
            }
        });
        this.yearList2.forEach((element) => {
            this.alterBackForwardArrow(element);
        });
    }
    /**
     * @param {?} element
     * @return {?}
     */
    yearFlagDisable(element) {
        const /** @type {?} */ min = new Date(this.minDate);
        const /** @type {?} */ max = new Date(this.maxDate);
        if (element.year < min.getFullYear() || element.year > max.getFullYear()) {
            element.disabled = true;
        } // if ends
    }
    /**
     * @return {?}
     */
    disableYearFlag() {
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            this.yearList1.forEach((element) => {
                this.yearFlagDisable(element);
            }); // for ends
            this.yearList2.forEach((element) => {
                this.yearFlagDisable(element);
            }); // for ends
        } // outer if ends
    }
    /**
     * @return {?}
     */
    arrowClickForward() {
        let /** @type {?} */ i;
        // disable flag logic
        this.disableYearFlag();
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            this.forwardArrow();
        }
        else {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year + 10;
                this.yearList2[i].year = this.yearList2[i].year + 10;
            }
        }
        // disable flag logic
        this.disableYearFlag();
        // rechking arrow flags after reinitialization of yrlist1 & 2
        this.rechkYearFlag();
    }
    /**
     * @return {?}
     */
    minMaxDateFound() {
        const /** @type {?} */ min = new Date(this.minDate);
        const /** @type {?} */ max = new Date(this.maxDate);
        this.yearList1.forEach((element) => {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear()) {
                this.forwardArrowFlag = true;
            }
        });
        this.yearList2.forEach((element) => {
            if (element.year === min.getFullYear()) {
                this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.forwardArrowFlag = true;
            }
        });
    }
    /**
     * @param {?} element
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    disableMinMaxYear(element, min, max) {
        if (element.year < min.getFullYear() || element.year > max.getFullYear()) {
            element.disabled = true;
        }
    }
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return (this.value || !this.required) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioDateTimePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-date-time-picker',
                template: `
    <div>
      <div class="inputgroup" *ngIf="!inlineDatepicker" #rootDiv>

        <label>
          {{fieldlabel}}
        </label>

        <ng-container *ngIf="datepicker && !timepicker">
          <input type="text" #pickerDt value="{{dateModel|date:dateformat}}" [attr.disabled]="disabled ? true: null" [required]="required ? true: null"
                 (blur)="onBlur()" (focus)="onFocus(rootDiv)" (focusout)="onFocusOut(pickerDt)" (change)="change.emit()" class="input-control"
                 [ngStyle]="{'cursor': readonly ? 'not-allowed':'pointer'}" placeholder="Choose Date" />
        </ng-container>

        <ng-container *ngIf="timepicker">
          <input type="text" [(ngModel)]="selectedDate" value="{{selectedDate|date:dateformat}} {{hrs + ' : ' + min}}" [attr.disabled]="disabled ? true: null"
                 [attr.required]="required ? true: null" (blur)="onBlur()" (focus)="onFocus(rootDiv)" (input)="onInput($event)"
                 (change)="change.emit()" class="input-control" [ngStyle]="{'cursor': readonly ? 'not-allowed':'pointer'}" placeholder="Choose Time"
          />
        </ng-container>

        <div class="drodown-caret-down" style="cursor: pointer" (click)="openPicker(rootDiv)">
          <ng-container *ngIf="timepicker">
            <amexio-form-icon key="datepicker-clock-icon"></amexio-form-icon>
          </ng-container>
          <ng-container *ngIf="!timepicker">
            <amexio-form-icon key="datepicker_calendar"></amexio-form-icon>
          </ng-container>

        </div>


      </div>

      <div [ngStyle]="dropdownstyle" [ngStyle]="positionClass" [ngClass]="{'datetimepicker1':inlineDatepicker , 'datetimepicker':!inlineDatepicker}">

        <div class="datetimepickertopbar" [ngStyle]="{'display': datepicker ? 'block' : 'none'}">
          <ul>
            <li class="prev">
              <amexio-form-icon key="datepicker_previous_fast" (onClick)="prevYear($event)"></amexio-form-icon>
              <amexio-form-icon key="datepicker_previous" (onClick)="prevMonth($event)"></amexio-form-icon>
            </li>
            <li class="next">
              <amexio-form-icon key="datepicker_next" (onClick)="nextMonth($event)"></amexio-form-icon>
              <amexio-form-icon key="datepicker_next_fast" (onClick)="nextYear($event)"></amexio-form-icon>
            </li>
            <li>
                        <span *ngIf="dropdownDatepicker">
                        <span style="cursor:pointer"(click)="dropdownDatePicker()">
                            {{selectedDate | date:'MMMM'}}
                            <br>
                            <span class="title">{{selectedDate | date:'y'}}</span>
                        </span>
                        <span  (onClick)=" dropdownDatePicker()" style="cursor:pointer">
                            <amexio-form-icon key="dropdown_caret" (onClick)="dropdownDatePicker()"></amexio-form-icon>
                        </span>
                    </span>

              <span *ngIf="!dropdownDatepicker">
                        {{selectedDate | date:'MMMM'}}
                        <br>
                        <span class="title" style="cursor:auto">{{selectedDate | date:'y'}}</span>
                    </span>

            </li>
          </ul>
        </div>
        <div *ngIf="!drop">
          <ul class="weekdays" [ngStyle]="{'display': datepicker ? 'block' : 'none'}">
            <li *ngFor="let dayTitle of daysTitle">{{dayTitle.text}}</li>
          </ul>

          <ul class="days" [ngStyle]="{'display': datepicker ? 'block' : 'none'}">

            <ng-container *ngFor="let dayArray of daysArray">
              <li *ngFor="let day of dayArray" (click)="onDateClick(day.date)" [ngClass]="{'date1':validateDays(day.date) , 'date1':day.isDisabled}">
                            <span (click)="onDateClick(day.date)" class="day" [ngClass]="{'active':day.selected, 'currentMonth':day.isCurrentMonth, 'notCurrentMonth':!day.isCurrentMonth,'invaliddays':validateDays(day.date), 'disabled':day.isDisabled}">
                                {{ day.date | date:'d' }}
                            </span>
              </li>
            </ng-container>


            <li class="date-today">
              <amexio-button type="primary" label="TODAY" (onClick)="setToday()" size="small"></amexio-button>
            </li>


          </ul>
        </div>
        <table class="table"  [ngStyle]="{'display': timepicker ? 'block' : 'none'}" style="cursor : pointer;text-align: center;padding: 5px;">
          <!--if picker is true-->
          <tr style="padding: 10px;">
            <td colspan="2"></td>
            <td (click)="plus('hrs', $event);">&#9650;</td>
            <td></td>
            <td (click)="plus('min', $event);">&#9650;</td>
            <td colspan="2"></td>
          </tr>
          <tr>
            <td colspan="2"></td>
            <td>{{hrs}}</td>
            <td>:</td>
            <td>{{min}}</td>
            <td colspan="2">
            </td>
          </tr>
          <tr>
            <td colspan="2"></td>
            <td (click)="minus('hrs', $event);">&#9660;</td>
            <td></td>
            <td (click)="minus('min', $event);">&#9660;</td>
            <td colspan="2">
            </td>
          </tr>

        </table>

        <!--dropdown datepicker -->
        <div [ngStyle]="positionClass" class="datedropdown" *ngIf="drop && !timepicker">

          <div class="dropdiv1">

                    <span class="dropspan1">
                        <ul class="dropul1">
                            <li class="li4" (click)="getDropdownMonth(month)" *ngFor="let month of monthList1">
                                <span [ngClass]="{'change4':month.flag}"> {{month.name}}</span>
                            </li>

                        </ul>
                    </span>

            <span class="dropspan2">
                        <ul class="dropul2">
                            <li class="li4" (click)="getDropdownMonth(month)" *ngFor="let month of monthList2">
                                <span [ngClass]="{'change4':month.flag}"> {{month.name}}</span>
                            </li>

                        </ul>
                    </span>

            <span class="dropspan1">
                        <ul class="dropul1">
                            <li [ngClass]="{ 'disablearrow':backArrowFlag}" class="dropiconpadding" (click)="arrowClickBack()">
                                <amexio-form-icon key="paginator_first" (onClick)="arrowClickBack()"></amexio-form-icon>
                            </li>
                            <li [ngClass]="{ 'disablearrow':year.disabled}" class="li4" (click)="getDropdownYear(year)" *ngFor="let year of yearList1">
                                <span [ngClass]="{'change4':year.flag && !year.disabled}">
                                    {{year.year}}
                                </span>
                            </li>


                        </ul>
                    </span>

            <span class="dropspan4">
                        <ul class="dropul2">

                            <li [ngClass]="{ 'disablearrow':forwardArrowFlag}" class="dropiconpadding" (click)="arrowClickForward()">
                                <amexio-form-icon key="paginator_last" (onClick)="arrowClickForward()"></amexio-form-icon>
                            </li>
                            <li [ngClass]="{ 'disablearrow ':year.disabled}" class="li4" (click)="getDropdownYear(year)" *ngFor="let year of yearList2">
                                <span [ngClass]="{'change4':year.flag && !year.disabled}">
                                    {{year.year}}
                                </span>
                            </li>

                        </ul>
                    </span>

          </div>
          <div class="btndiv1">
                    <span class="dropbtnspan">
                        <button (click)="navigateDropdown()" class="datedropbtn">
                            ok
                        </button>
                        <button class="datedropbtn" (click)="negateDrop()">
                            cancel
                        </button>
                    </span>


          </div>
        </div>
      </div>
    </div>
  `,
                styles: [`
  `],
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioDateTimePickerComponent), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef(() => AmexioDateTimePickerComponent), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioDateTimePickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Renderer2 }
];
AmexioDateTimePickerComponent.propDecorators = {
    dateformat: [{ type: Input, args: ['date-format',] }],
    datepicker: [{ type: Input, args: ['date-picker',] }],
    timepicker: [{ type: Input, args: ['time-picker',] }],
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    disabled: [{ type: Input, args: ['disabled',] }],
    readonly: [{ type: Input, args: ['read-only',] }],
    minDate: [{ type: Input, args: ['min-date',] }],
    maxDate: [{ type: Input, args: ['max-date',] }],
    diabledDate: [{ type: Input, args: ['disabled-date',] }],
    inlineDatepicker: [{ type: Input, args: ['inline-datepicker',] }],
    dropdownDatepicker: [{ type: Input, args: ['dropdown-datepicker',] }],
    required: [{ type: Input }],
    change: [{ type: Output }],
    input: [{ type: Output }],
    isComponentValid: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 Component Name : Amexio  Dropdown Menu
 Component Selector : <amexio-drop-down-menu-items>
 Component Description : Amexio Dropdown component with various modes and configurations .
 */
class AmexioDropDownitemsComponent {
    constructor() {
        /*
           Properties
           name : add-seperator
           datatype :  boolean
           version : 4.2 onwards
           default : false
           description : add divider to the dropdown menu list
           */
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.iconalign && this.labelalign
            && this.iconalign.toLowerCase() === this.labelalign.toLowerCase()) {
            this.iconalign = null;
            this.labelalign = null;
        }
        else if (this.iconalign && this.iconalign === 'left') {
            this.labelalign = 'right';
            this.iconalign = null;
        }
        else if (this.iconalign && this.iconalign === 'right') {
            this.labelalign = null;
        }
    }
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    onItemClick(clickEvent) {
        this.toggle = false;
        const /** @type {?} */ e = {
            event: clickEvent,
            this: this,
        };
        this.onClick.emit(e);
    }
}
AmexioDropDownitemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-drop-down-menu-item',
                template: `
    <div *ngIf="!(icon && label)" class="dropdowndivider" style="padding-bottom: 5px;">
      <ng-content></ng-content>
    </div>
    <a *ngIf=" (icon || label)" (click)="onItemClick($event)" [ngClass]="{'dropdowndivider':separator}">

      <ng-container *ngIf="icon">
        <em [style.float]="iconalign" [ngClass]="icon"></em>
      </ng-container>

      <ng-container *ngIf="label">
        <span [style.float]="labelalign" style="padding: 5px;">
          {{label}}
        </span>
      </ng-container>

    </a>
  `,
            },] },
];
AmexioDropDownitemsComponent.propDecorators = {
    label: [{ type: Input }],
    icon: [{ type: Input }],
    labelalign: [{ type: Input, args: ['label-align',] }],
    iconalign: [{ type: Input, args: ['icon-align',] }],
    separator: [{ type: Input, args: ['separator',] }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioDropDownMenuComponent {
    /**
     * @param {?} element
     * @param {?} matchMediaService
     */
    constructor(element, matchMediaService) {
        this.element = element;
        this.matchMediaService = matchMediaService;
        this.xposition = false;
        /*
           Properties
           name : menu icon
           datatype : string
           version : 4.2 onwards
           default :
           description : icon on menu
           */
        this.downArrowIcon = true;
        /*
           Properties
           name : transparent
           datatype : string
           version : 4.2 onwards
           default :
           description : transparent style for menu
           */
        this.transparent = false;
        this.onClick = new EventEmitter();
        this.optionsCollection = [];
        this.iconalign = 'left';
        this.padding = '5px 10px';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.data) {
            this.data.forEach((node) => {
                if (!node.iconalign && this.iconalign) {
                    node.iconalign = this.iconalign;
                }
                if (!node.labelalign) {
                    node.labelalign = 'left';
                }
            });
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.optionsCollection = this.dropdowns.toArray();
        this.optionsCollection.forEach((node) => node.onClick.subscribe((eventdata) => {
            this.toggle = false;
        }));
    }
    /**
     * @param {?} targetElement
     * @return {?}
     */
    onElementOutClick(targetElement) {
        let /** @type {?} */ parentFound = false;
        while (targetElement !== null && !parentFound) {
            if (targetElement === this.element.nativeElement) {
                parentFound = true;
            }
            targetElement = targetElement.parentElement;
        }
        if (!parentFound) {
            this.toggle = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    showDropDownContent(event) {
        this.toggle = !this.toggle;
        this.top = event.target.getBoundingClientRect().top + 25;
        if ((this.matchMediaService.browserWindow().innerWidth - event.clientX) < 200) {
            this.xposition = true;
        }
        else {
            this.xposition = false;
        }
    }
    /**
     * @param {?} childposition
     * @param {?} parentIconPosition
     * @return {?}
     */
    getIconPosition(childposition, parentIconPosition) {
        if (childposition.hasOwnProperty('iconalign') && childposition.iconalign !== '') {
            if (childposition.iconalign === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (parentIconPosition === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDropDownMenuClick(event) {
        this.toggle = false;
        this.onClick.emit(event);
    }
    /**
     * @param {?} childPosition
     * @param {?} parentLabelPosition
     * @return {?}
     */
    getLabelPosition(childPosition, parentLabelPosition) {
        if (childPosition.hasOwnProperty('labelalign') && childPosition.labelalign !== '') {
            if (childPosition.labelalign === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (parentLabelPosition === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
    }
}
AmexioDropDownMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-drop-down-menu',
                template: `
    <div (click)="showDropDownContent($event)" class="dropdown-menu" 
         [style.padding]="padding"
         [ngStyle]="{'background-color':(transparent)?'unset':'null'}">

      <span >
        <em *ngIf="icon" style="padding-right: 5px;" [ngClass]="icon">&nbsp;</em>{{title}}&nbsp;</span>
      <ng-container *ngIf="downArrowIcon">
        <em *ngIf="!toggle"  class="fa fa-angle-down "></em>
        <em *ngIf="toggle"  class="fa fa-angle-up "></em>
      </ng-container>

    </div>

    <div   *ngIf="toggle" class="dropdown-menu-content"
         [style.height]="height"   [ngClass]="{'menu-right':xposition}">

      <ng-content></ng-content>
      <amexio-drop-down-menu-item (onClick)="onDropDownMenuClick($event)"  *ngFor="let node of data"
                                    [icon-align]="node.iconalign"
                                    [label-align]="node.labelalign"
                                    [label]="node.label"
                                    [separator]="node.separator"
                                    [icon]="node.icon">
      </amexio-drop-down-menu-item>

    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioDropDownMenuComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: DeviceQueryService }
];
AmexioDropDownMenuComponent.propDecorators = {
    dropDownMenuLocalData: [{ type: Input }],
    data: [{ type: Input }],
    title: [{ type: Input }],
    icon: [{ type: Input }],
    iconalign: [{ type: Input, args: ['icon-align',] }],
    padding: [{ type: Input }],
    downArrowIcon: [{ type: Input, args: ['down-arrow-icon',] }],
    transparent: [{ type: Input }],
    height: [{ type: Input }],
    onClick: [{ type: Output }],
    dropdowns: [{ type: ContentChildren, args: [AmexioDropDownitemsComponent,] }],
    onElementOutClick: [{ type: HostListener, args: ['document:click', ['$event.target'],] }, { type: HostListener, args: ['document: touchstart', ['$event.target'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioEmailInputComponent extends ValueAccessorBase {
    constructor() {
        super();
        /*
           Properties
           name : has-label
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : Flag to set label
           */
        this.hasLabel = true;
        this.emailpattern = /\S+@\S+\.\S+/;
        /*
           Events
           name : onBlur
           datatype : any
           version : 4.0 onwards
           default :
           description : On blur event
           */
        this.onBlur = new EventEmitter();
        /*
           Events
           name : input
           datatype : any
           version : none
           default :
           description : 	On input event field.
           */
        this.input = new EventEmitter();
        /*
           Events
           name : focus
           datatype : any
           version : none
           default :
           description : On focus event field.
           */
        this.focus = new EventEmitter();
        /*
           Events
           name : change
           datatype : any
           version : none
           default :
           description : On field value change event
           */
        this.change = new EventEmitter();
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    get errormsg() {
        return this._errormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set errormsg(value) {
        this.helpInfoMsg = value + '<br/>';
    }
    /**
     * @return {?}
     */
    get pattern() {
        return this._pattern;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set pattern(value) {
        if (value != null) {
            this._pattern = value;
            this.regEx = new RegExp(this._pattern);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'emailinput');
    }
    /**
     * @return {?}
     */
    onblur() {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.showToolTip = true;
        this.focus.emit(this.value);
    }
    /**
     * @return {?}
     */
    onInput() {
        this.isValid = this.isFieldValid();
        this.input.emit(this.value);
    }
    /**
     * @return {?}
     */
    onChangeEv() {
        this.change.emit(this.value);
    }
    /**
     * @return {?}
     */
    isFieldValid() {
        return (!this.allowblank && this.emailpattern.test(this.value)) || this.allowblank;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.isFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioEmailInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-email-input',
                template: `

    <div class="inputgroup">

      <label *ngIf="hasLabel" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
        {{fieldlabel}}
      </label> 

      <input type="email" 
             class="input-control"
             [ngClass]="model.touched ? (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''"
             [(ngModel)]="value"
             (blur)="onblur()"
             (focus)="onFocus()"
             (input)="onInput()"
             (change)="onChangeEv()"
             [name]="name"
             [pattern]="regEx"
             [attr.placeholder]="placeholder"
             [attr.disabled] = "disabled ? true: null"
             [required]="!allowblank"/>

             <ng-container *ngIf="iconfeedback">
              <span class="input-control-feedback">
                  <span *ngIf="!isValid && model.touched"><em class="fa fa-times"></em></span>
                  <span *ngIf="isValid && model.touched"><em class="fa fa-check"></em></span>
              </span>
          </ng-container>
    
    
          <span *ngIf="showToolTip && enablepopover" class="dropdown tooltiptext">
              <div [innerHTML]="helpInfoMsg"></div>
          </span>
          <span class="inputfieldbar"></span>
        </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioEmailInputComponent), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef(() => AmexioEmailInputComponent), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioEmailInputComponent.ctorParameters = () => [];
AmexioEmailInputComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    hasLabel: [{ type: Input, args: ['has-label',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    model: [{ type: ViewChild, args: [NgModel,] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    pattern: [{ type: Input, args: ['pattern',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    onBlur: [{ type: Output }],
    input: [{ type: Output }],
    focus: [{ type: Output }],
    change: [{ type: Output }],
    name: [{ type: Input, args: ['name',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioFileUploadComponent {
    /**
     * @param {?} dataService
     */
    constructor(dataService) {
        this.dataService = dataService;
        /*
           Events
           name : onRemove
           datatype : any
           version : none
           default :
           description : On remove click event
           */
        this.onRemove = new EventEmitter();
        this.uploadedFiles = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    ngAfterViewInit() { }
    /**
     * @param {?} bytes
     * @param {?} decimals
     * @return {?}
     */
    formatBytes(bytes, decimals) {
        if (bytes === 0) {
            return '0 Bytes';
        }
        const /** @type {?} */ k = 1024;
        const /** @type {?} */ dm = decimals || 2;
        // tslint:disable-next-line:one-variable-per-declaration
        const /** @type {?} */ sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const /** @type {?} */ i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFileDrop(event) {
        event.preventDefault();
        this.dropClass = '';
        const /** @type {?} */ dt = event.dataTransfer;
        if (dt.items) {
            // Use DataTransferItemList interface to access the file(s)
            // tslint:disable-next-line:prefer-for-of
            for (let /** @type {?} */ i = 0; i < dt.items.length; i++) {
                if (dt.items[i].kind === 'file') {
                    const /** @type {?} */ f = dt.items[i].getAsFile();
                    this.uploadFile(f, true);
                }
            }
        }
        else {
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        event.preventDefault();
        this.dropClass = 'drop';
    }
    /**
     * @param {?} filedata
     * @param {?} index
     * @return {?}
     */
    closeFile(filedata, index) {
        this.onRemove.emit({ fileData: filedata });
        this.uploadedFiles.splice(index, 1);
    }
    /**
     * @param {?} event
     * @param {?} singleFile
     * @return {?}
     */
    uploadFile(event, singleFile) {
        if (singleFile) {
            const /** @type {?} */ formData = new FormData();
            formData.append(this.paramname, event);
            this.dataService
                .uploadFile(this.httpurl, this.httpmethod, formData)
                .subscribe((response) => {
                this.responseData = response;
            }, (error) => { }, () => {
            });
            this.uploadedFiles.push({
                name: event.name,
                size: this.formatBytes(event.size, 2),
            });
        }
        else {
            this.serviceCall(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    serviceCall(event) {
        const /** @type {?} */ fileList = event.target.files != null ? event.target.files : event;
        const /** @type {?} */ formData = new FormData();
        if (fileList) {
            // tslint:disable-next-line:prefer-for-of
            for (let /** @type {?} */ i = 0; i < fileList.length; i++) {
                if (!this.paramname) {
                    this.paramname = 'file';
                }
                formData.append(this.paramname, fileList[i]);
            }
            this.uploadService(formData);
            if (fileList.length === 1) {
                const /** @type {?} */ fsize = this.formatBytes(fileList[0].size, 2);
                this.uploadedFiles.push({ name: fileList[0].name, size: fsize });
            }
            else if (fileList.length > 1) {
                // tslint:disable-next-line:prefer-for-of
                for (let /** @type {?} */ i = 0; i < fileList.length; i++) {
                    const /** @type {?} */ fsize = this.formatBytes(fileList[i].size, 2);
                    this.uploadedFiles.push({ name: fileList[i].name, size: fsize });
                }
            }
        }
    }
    /**
     * @param {?} formData
     * @return {?}
     */
    uploadService(formData) {
        this.dataService.uploadFile(this.httpurl, this.httpmethod, formData)
            .subscribe((response) => {
            this.responseData = response;
        }, (error) => { }, () => {
        });
    }
}
AmexioFileUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-fileupload',
                template: `
    <div class='input-group' *ngIf='!droppable'>
        <ng-container *ngIf='fieldlabel'>
            <label>{{fieldlabel}}</label>
        </ng-container>
        <ng-container *ngIf='!fieldlabel'>
            <label>Choose File</label>
        </ng-container>
        <input type='file' class='input-control' [attr.accept]='filetype' (change)='uploadFile($event,false)' [attr.multiple]='multiplefile' #inp>
    </div>
    <ng-container *ngIf='droppable'>
        <ng-container *ngIf='fieldlabel'>
            <label>{{fieldlabel}}</label>
        </ng-container>
        <ng-container *ngIf='!fieldlabel'>
            <label>Drag and Drop Files below</label>
        </ng-container>
        <div class='upload-drop-zone {{dropClass}}' (drop)='onFileDrop($event)' (dragover)='onDragOver($event)' (dragleave)='dropClass = "";' #drpZone>
            Just drag and drop files here
        </div>
    </ng-container>

    <div class='file-upload-box' style='width: 100%'>
        <li *ngFor='let file of uploadedFiles ; let index = index' class='file-upload-info'>
            <span class='uploaded-file-name'>({{file.name}} &nbsp;  &nbsp; ({{file.size}}) )</span>
            <amexio-form-icon key='tab_close' class='close-icon' (onClick)='closeFile(file,index)'>
            </amexio-form-icon>
        </li>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioFileUploadComponent.ctorParameters = () => [
    { type: CommonDataService }
];
AmexioFileUploadComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    filetype: [{ type: Input, args: ['file-type',] }],
    multiplefile: [{ type: Input, args: ['multiple-file',] }],
    paramname: [{ type: Input, args: ['param-name',] }],
    droppable: [{ type: Input }],
    onRemove: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioFloatingButtonComponent {
    constructor() {
        /*
          Properties
          name : block
          datatype : none
          version : 4.1 onwards
          default : none
          description : Display button as round or square
          */
        this.block = 'circle';
        /*
          Properties
          name : relative
          datatype : boolean
          version : 4.1 onwards
          default : none
          description : Place floating button at relative position
          */
        this.relative = false;
        /*
          Events
          name : onClick
          datatype : any
          version : none
          default : none
          description : Event is fired when button is click
          */
        this.onClick = new EventEmitter();
        this.absoluteposition = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.addCSSClasses();
    }
    /**
     * @return {?}
     */
    addCSSClasses() {
        if (this.top || this.bottom || this.right || this.left) {
            this.absoluteposition = true;
        }
        this.positionclass = '';
        if (this.relative) {
            this.positionclass = ' floatingbutton-relative ';
        }
        else {
            this.positionclass = ' floatingbutton-fixed ';
        }
        if (!this.absoluteposition && !this.relative) {
            this.btnPositionCss();
        }
        if (this.block === 'circle') {
            this.setCricle();
        }
        else if (this.block === 'square') {
            this.positionclass = this.positionclass + ' floatingbutton-square';
        }
        if (this.type === 'theme-color') {
            this.themeColorCss();
        }
        else if (this.type === 'green') {
            this.greenColorType();
        }
        else if (this.type === 'red') {
            this.redColorType();
        }
        else if (this.type === 'yellow') {
            this.yellowColorType();
        }
        else {
            this.defaultType();
        }
        return this.positionclass;
    }
    /**
     * @return {?}
     */
    setCricle() {
        if (this.size && (this.size === 'large' || this.size === 'small')) {
            this.positionclass = this.positionclass + ' floatingbutton-circle-' + this.size;
        }
        else {
            this.positionclass = this.positionclass + ' floatingbutton-circle';
        }
        this.label = '';
    }
    /**
     * @return {?}
     */
    themeColorCss() {
        this.positionclass = this.disabled ? this.positionclass + ' floatingbutton-theme-color-disabled' :
            this.positionclass + ' floatingbutton-theme-color';
    }
    /**
     * @return {?}
     */
    defaultType() {
        this.positionclass = this.disabled ? this.positionclass + ' floatingbutton-default-disabled' :
            this.positionclass + 'floatingbutton-default';
    }
    /**
     * @return {?}
     */
    yellowColorType() {
        this.positionclass = this.disabled ? this.positionclass + 'floatingbutton-yellow-disabled' :
            this.positionclass + ' floatingbutton-yellow';
    }
    /**
     * @return {?}
     */
    redColorType() {
        this.positionclass = this.disabled ? this.positionclass + 'floatingbutton-red-disabled' :
            this.positionclass + ' floatingbutton-red';
    }
    /**
     * @return {?}
     */
    greenColorType() {
        this.positionclass = this.disabled ? this.positionclass + ' floatingbutton-green-disabled' :
            this.positionclass + ' floatingbutton-green';
    }
    /**
     * @return {?}
     */
    btnPositionCss() {
        if (this.verticalposition === null) {
            this.verticalposition = 'top';
        }
        else if (this.horizontalposition === null) {
            this.horizontalposition = 'right';
        }
        this.positionclass = this.positionclass + ' floatingbutton-' +
            this.verticalposition + ' floatingbutton-' + this.horizontalposition +
            ' floatingbutton-default';
    }
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    buttonClick(clickEvent) {
        if (!this.disabled) {
            this.onClick.emit({ thisObj: this, event: clickEvent });
        }
    }
}
AmexioFloatingButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-floating-button',
                template: `
    <div class="floatingbutton" [ngClass]="addCSSClasses()" [ngStyle]="{'top':top,'bottom':bottom,'left':left,'right':right}" (click)="buttonClick($event)">
        <amexio-form-icon *ngIf="icon" [customclass]="icon">
        </amexio-form-icon>
        {{label}}
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
AmexioFloatingButtonComponent.ctorParameters = () => [];
AmexioFloatingButtonComponent.propDecorators = {
    verticalposition: [{ type: Input, args: ['vertical-position',] }],
    horizontalposition: [{ type: Input, args: ['horizontal-position',] }],
    top: [{ type: Input, args: ['position-top',] }],
    bottom: [{ type: Input, args: ['position-bottom',] }],
    left: [{ type: Input, args: ['position-left',] }],
    right: [{ type: Input, args: ['position-right',] }],
    label: [{ type: Input, args: ['label',] }],
    block: [{ type: Input, args: ['block',] }],
    icon: [{ type: Input, args: ['icon',] }],
    type: [{ type: Input, args: ['type',] }],
    disabled: [{ type: Input, args: ['disabled',] }],
    relative: [{ type: Input, args: ['relative',] }],
    onClick: [{ type: Output }],
    size: [{ type: Input, args: ['size',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioFloatingGroupButtonComponent extends ListBaseDatepickerComponent {
    /**
     * @param {?} elementref
     * @param {?} cdf
     * @param {?} renderer
     */
    constructor(elementref, cdf, renderer) {
        super(renderer, elementref, cdf);
        this.elementref = elementref;
        this.cdf = cdf;
        /*
         Properties
         name : relative
         datatype : boolean
         version : 4.1 onwards
         default : none
         description : Place floating buttong at relative position
         */
        this.relative = false;
        /*
         Events
         name : onClick
         datatype : any
         version : none
         default : none
         description : Event is fired when button is click
         */
        this.onClick = new EventEmitter();
        this.togglefloatinggroup = false;
        this.datacount = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.dropdownstyle = { visibility: 'hidden' };
        if (this.data && this.data.length > 0) {
            this.datacount = this.data.length;
            this.data.forEach((node) => {
                if (!node['type']) {
                    node['type'] = this.type;
                    node['typeclass'] = 'floatingbutton-' + this.type;
                }
                else {
                    node['typeclass'] = 'floatingbutton-' + node['type'];
                }
            });
        }
    }
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    buttonClick(clickEvent) {
        const /** @type {?} */ x = clickEvent.currentTarget.getBoundingClientRect().left;
        const /** @type {?} */ y = clickEvent.currentTarget.getBoundingClientRect().top;
        if (!this.disabled) {
            if (this.floatinggroupposition === 'bottom') {
                this.floatinggroupxposition = (x) + 'px';
                this.floatinggroupyposition = (y + 70) + 'px';
            }
            if (this.floatinggroupposition === 'top') {
                this.floatinggroupxposition = (x) + 'px';
                this.floatinggroupyposition = (y - (70 * this.datacount)) + 'px';
            }
            this.toggleVisibility();
            this.togglefloatinggroup = !this.togglefloatinggroup;
            this.onClick.emit({ thisObj: this, event: clickEvent });
        }
    }
    /**
     * @return {?}
     */
    toggleVisibility() {
        if (this.dropdownstyle.visibility === 'visible') {
            super.itemClicked();
        }
        else {
            const /** @type {?} */ event = '';
            super.focus(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFloatingButtonClick(event) {
        this.buttonClick(event.event);
    }
    /**
     * @param {?} node
     * @param {?} clickEvent
     * @return {?}
     */
    onButtonClick(node, clickEvent) {
        this.toggleVisibility();
        this.togglefloatinggroup = !this.togglefloatinggroup;
        this.onClick.emit({ this: node, parent: this, event: clickEvent });
    }
}
AmexioFloatingGroupButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-floating-group-button',
                template: `

    <amexio-floating-button (onClick)="onFloatingButtonClick($event)" 
            [vertical-position]="verticalposition" 
            [horizontal-position]="horizontalposition" 
            [icon]="icon" 
            [type]="type"
            [disabled]="disabled"
            [relative]="relative"
            [position-top]="top"
            [position-bottom]="bottom"
            [position-left]="left"
            [position-right]="right">
    </amexio-floating-button>                
    
    <!-- *ngIf="togglefloatinggroup" -->
    <div class="floatinggroup"  [ngStyle]="dropdownstyle" 
    [ngStyle]="{'top':floatinggroupyposition, 'left':floatinggroupxposition}">
        <div class="floatinggroupitems" *ngFor="let node of data" >
            <div *ngIf="node.icon" class="floatingbutton-circle" [ngClass]="node.typeclass" (click)="onButtonClick(node,$event)">
                <amexio-form-icon [customclass]="node.icon" >
                </amexio-form-icon>
            </div>
        </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioFloatingGroupButtonComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Renderer2 }
];
AmexioFloatingGroupButtonComponent.propDecorators = {
    verticalposition: [{ type: Input, args: ['vertical-position',] }],
    horizontalposition: [{ type: Input, args: ['horizontal-position',] }],
    top: [{ type: Input, args: ['position-top',] }],
    bottom: [{ type: Input, args: ['position-bottom',] }],
    left: [{ type: Input, args: ['position-left',] }],
    right: [{ type: Input, args: ['position-right',] }],
    icon: [{ type: Input, args: ['icon',] }],
    type: [{ type: Input, args: ['type',] }],
    disabled: [{ type: Input, args: ['disabled',] }],
    relative: [{ type: Input, args: ['relative',] }],
    floatinggroupposition: [{ type: Input, args: ['floating-group-position',] }],
    data: [{ type: Input, args: ['data',] }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioFormIconComponent {
    /**
     * @param {?} iconLoaderService
     */
    constructor(iconLoaderService) {
        this.iconLoaderService = iconLoaderService;
        /*
        Events
        name : onClick
        datatype : any
        version : none
        default : none
        description : Event is fired when button is click
        */
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.iconClass = this.getIconClass();
    }
    /**
     * @return {?}
     */
    getIconClass() {
        if (this.iconLoaderService.iconMappings != null) {
            const /** @type {?} */ iconObject = this.iconLoaderService.iconMappings.find((obj) => obj.component === this.key);
            if (iconObject != null) {
                return iconObject[this.iconLoaderService.iconToUse.toString()];
            }
            else {
                return '';
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['key']) {
            this.key = changes["key"].currentValue;
            this.iconClass = this.getIconClass();
        }
    }
}
AmexioFormIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-form-icon',
                template: `
    <ng-container *ngIf="iconLoaderService.iconToUse == 'fa' ">
      <ng-container *ngIf="customclass != null">
        <i class="{{customclass}}" aria-hidden="true" (click)="onClick.emit($event)"></i>
      </ng-container>
      <ng-container *ngIf="customclass == null">
        <i class="{{iconClass}}" aria-hidden="true" (click)="onClick.emit($event)"></i>
      </ng-container>
    </ng-container>
    <ng-container *ngIf="iconLoaderService.iconToUse == 'mat'">
      <ng-container *ngIf="customclass != null">
        <i class="material-icons" (click)="onClick.emit($event)">{{customclass}}</i>
      </ng-container>
      <ng-container *ngIf="customclass == null">
        <i class="material-icons" (click)="onClick.emit($event)">{{iconClass}}</i>
      </ng-container>
    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioFormIconComponent.ctorParameters = () => [
    { type: IconLoaderService }
];
AmexioFormIconComponent.propDecorators = {
    key: [{ type: Input }],
    onClick: [{ type: Output }],
    customclass: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioPasswordComponent extends ValueAccessorBase {
    constructor() {
        super();
        /*
          Properties
          name : has-label
          datatype : boolean
          version : 4.0 onwards
          default : false
          description : flag to set label
          */
        this.haslabel = true;
        /*
          Events
          name : onBlur
          datatype : any
          version : 4.0 onwards
          default :
          description : On blur event
          */
        this.onBlur = new EventEmitter();
        /*
        Events
        name : input
        datatype : any
        version : none
        default :
        description : 	On input event field.
        */
        this.input = new EventEmitter();
        /*
        Events
        name : focus
        datatype : any
        version : none
        default :
        description : On focus event field.
        */
        this.focus = new EventEmitter();
        /*
        Events
        name : change
        datatype : any
        version : none
        default :
        description : On field value change event
        */
        this.change = new EventEmitter();
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    get errormsg() {
        return this._errormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set errormsg(value) {
        this.helpInfoMsg = value + '<br/>';
    }
    /**
     * @return {?}
     */
    get minerrormsg() {
        return this._minerrormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set minerrormsg(value) {
        this.helpInfoMsg = this.helpInfoMsg + '<b>Min Length<b/>: ' + value + '<br/>';
    }
    /**
     * @return {?}
     */
    get maxerrormsg() {
        return this._maxerrormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxerrormsg(value) {
        this.helpInfoMsg = this.helpInfoMsg + 'Max Length: ' + value;
    }
    /**
     * @return {?}
     */
    get pattern() {
        return this._pattern;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set pattern(value) {
        if (value != null) {
            this.regEx = new RegExp(this.pattern);
        }
    }
    /**
     * @return {?}
     */
    onblur() {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.showToolTip = true;
        this.focus.emit(this.value);
    }
    /**
     * @return {?}
     */
    onInput() {
        this.isValid = this.isFieldValid();
        this.input.emit(this.value);
    }
    /**
     * @return {?}
     */
    onChangeEv() {
        this.change.emit(this.value);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isValid = this.isFieldValid();
        this.name = this.generateName(this.name, this.fieldlabel, 'passwordinput');
    }
    /**
     * @return {?}
     */
    isFieldValid() {
        return (!this.allowblank && (this.value && ((this.value.length >= this.minlength) && this.value.length > 0)) ||
            (!this.minlength && this.value && this.value.length > 0)) || this.allowblank;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.isFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioPasswordComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-password-input',
                template: `



    <div class="inputgroup">

      <label *ngIf="haslabel" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
          {{fieldlabel}}
      </label>

      <input type="password" 
             class="input-control"
             [ngClass]="model.touched ? (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''"
             [(ngModel)]="value"
             (blur)="onblur()" 
             (focus)="onFocus()" 
             (input)="onInput()" 
             (change)="onChangeEv()"
             [name]="name" 
             [pattern]="regEx"
             [attr.placeholder]="placeholder" 
             [maxlength]="maxlength" 
             [minlength]="minlength"
             [attr.disabled]="disabled ? true: null"
             [required]="!allowblank" />


      <ng-container *ngIf="iconfeedback">
          <span class="input-control-feedback">
              <span *ngIf="!isValid && model.touched"><em class="fa fa-times"></em></span>
              <span *ngIf="isValid && model.touched"><em class="fa fa-check"></em></span>
          </span>
      </ng-container>


      <span *ngIf="showToolTip && enablepopover" class="dropdown tooltiptext">
          <div [innerHTML]="helpInfoMsg"></div>
      </span>
      <span class="inputfieldbar"></span>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioPasswordComponent), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef(() => AmexioPasswordComponent), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioPasswordComponent.ctorParameters = () => [];
AmexioPasswordComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    minlength: [{ type: Input, args: ['min-length',] }],
    maxlength: [{ type: Input, args: ['max-length',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    minerrormsg: [{ type: Input, args: ['min-error-msg',] }],
    maxerrormsg: [{ type: Input, args: ['max-error-msg',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    pattern: [{ type: Input, args: ['pattern',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    onBlur: [{ type: Output }],
    input: [{ type: Output }],
    focus: [{ type: Output }],
    change: [{ type: Output }],
    model: [{ type: ViewChild, args: [NgModel,] }],
    name: [{ type: Input, args: ['name',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LoadRecaptchaService {
    constructor() {
    }
    /**
     * @return {?}
     */
    loadScript() {
        const /** @type {?} */ script = document.createElement('script');
        script.innerHTML = '';
        script.src = 'https://www.google.com/recaptcha/api.js?render=explicit';
        script.async = true;
        script.defer = true;
        return script;
    }
}
LoadRecaptchaService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
LoadRecaptchaService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class RecaptchaComponent {
    /**
     * @param {?} _loadRecaptchaService
     */
    constructor(_loadRecaptchaService) {
        this._loadRecaptchaService = _loadRecaptchaService;
        this.onSuccess = new EventEmitter();
        this.onFailure = new EventEmitter();
        this.responseStructure = {};
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId =
            +Math.floor(Math.random() * 90000) + 10000 + 'google';
        const /** @type {?} */ script = this._loadRecaptchaService.loadScript();
        const /** @type {?} */ body = /** @type {?} */ (document.body);
        script.onload = () => {
            grecaptcha.ready(() => {
                this.rendercaptcha();
            });
        };
        body.appendChild(script);
    }
    /**
     * @return {?}
     */
    rendercaptcha() {
        grecaptcha.render(this.componentId, {
            sitekey: this.sitekey, callback: (response) => {
                if (response && response.length > 0) {
                    this.responseStructure['success'] = true;
                    this.responseStructure['response'] = response;
                    this.onSuccess.emit(this.responseStructure);
                }
                else {
                    this.responseStructure['success'] = false;
                    this.responseStructure['response'] = '';
                    this.onFailure.emit(this.responseStructure);
                }
            },
        });
    }
}
RecaptchaComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-google-recaptcha',
                template: `
    <div class="g-recaptcha" [attr.id]="componentId">
    </div>
  `,
            },] },
];
/** @nocollapse */
RecaptchaComponent.ctorParameters = () => [
    { type: LoadRecaptchaService }
];
RecaptchaComponent.propDecorators = {
    sitekey: [{ type: Input, args: ['site-key',] }],
    onSuccess: [{ type: Output }],
    onFailure: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DomHandler {
    constructor() {
        this.calculatedScrollbarWidth = null;
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    addClass(element, className) {
        if (element.classList) {
            element.classList.add(className);
        }
        else {
            element.className += ' ' + className;
        }
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    addMultipleClasses(element, className) {
        if (element.classList) {
            const /** @type {?} */ styles = className.split(' ');
            for (const /** @type {?} */ i of styles) {
                element.classList.add([i]);
            }
        }
        else {
            const /** @type {?} */ styles = className.split(' ');
            for (const /** @type {?} */ i of styles) {
                element.className += ' ' + [i];
            }
        }
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    removeClass(element, className) {
        if (element.classList) {
            element.classList.remove(className);
        }
        else {
            element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
        }
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    hasClass(element, className) {
        if (element.classList) {
            return element.classList.contains(className);
        }
        else {
            return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    siblings(element) {
        return Array.prototype.filter.call(element.parentNode.children, (child) => {
            return child !== element;
        });
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    find(element, selector) {
        return element.querySelectorAll(selector);
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    findSingle(element, selector) {
        return element.querySelector(selector);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    index(element) {
        const /** @type {?} */ children = element.parentNode.childNodes;
        let /** @type {?} */ num = 0;
        for (const /** @type {?} */ i of children) {
            if (i === element) {
                return num;
            }
            if (i.nodeType === 1) {
                num++;
            }
        }
        return -1;
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    relativePosition(element, target) {
        const /** @type {?} */ elementDimensions = (element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } :
            this.getHiddenElementDimensions(element));
        const /** @type {?} */ targetHeight = target.offsetHeight;
        const /** @type {?} */ targetWidth = target.offsetWidth;
        const /** @type {?} */ targetOffset = target.getBoundingClientRect();
        const /** @type {?} */ viewport = this.getViewport();
        let /** @type {?} */ top;
        let /** @type {?} */ left;
        if ((targetOffset.top + targetHeight + elementDimensions.height) > viewport.height) {
            top = -1 * (elementDimensions.height);
            if (targetOffset.top + top < 0) {
                top = 0;
            }
        }
        else {
            top = targetHeight;
        }
        if ((targetOffset.left + elementDimensions.width) > viewport.width) {
            left = targetWidth - elementDimensions.width;
        }
        else {
            left = 0;
        }
        element.style.top = top + 'px';
        element.style.left = left + 'px';
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    absolutePosition(element, target) {
        const /** @type {?} */ elementDimensions = (element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight }
            : this.getHiddenElementDimensions(element));
        const /** @type {?} */ elementOuterHeight = elementDimensions.height;
        const /** @type {?} */ elementOuterWidth = elementDimensions.width;
        const /** @type {?} */ targetOuterHeight = target.offsetHeight;
        const /** @type {?} */ targetOuterWidth = target.offsetWidth;
        const /** @type {?} */ targetOffset = target.getBoundingClientRect();
        const /** @type {?} */ windowScrollTop = this.getWindowScrollTop();
        const /** @type {?} */ windowScrollLeft = this.getWindowScrollLeft();
        const /** @type {?} */ viewport = this.getViewport();
        let /** @type {?} */ top;
        let /** @type {?} */ left;
        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
            top = targetOffset.top + windowScrollTop - elementOuterHeight;
            if (top < 0) {
                top = 0 + windowScrollTop;
            }
        }
        else {
            top = targetOuterHeight + targetOffset.top + windowScrollTop;
        }
        if (targetOffset.left + targetOuterWidth + elementOuterWidth > viewport.width) {
            left = targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth;
        }
        else {
            left = targetOffset.left + windowScrollLeft;
        }
        element.style.top = top + 'px';
        element.style.left = left + 'px';
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getHiddenElementOuterHeight(element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        const /** @type {?} */ elementHeight = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementHeight;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getHiddenElementOuterWidth(element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        const /** @type {?} */ elementWidth = element.offsetWidth;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementWidth;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getHiddenElementDimensions(element) {
        const /** @type {?} */ dimensions = {};
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        dimensions.width = element.offsetWidth;
        dimensions.height = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return dimensions;
    }
    /**
     * @param {?} container
     * @param {?} item
     * @return {?}
     */
    scrollInView(container, item) {
        const /** @type {?} */ borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');
        const /** @type {?} */ borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
        const /** @type {?} */ paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');
        const /** @type {?} */ paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
        const /** @type {?} */ containerRect = container.getBoundingClientRect();
        const /** @type {?} */ itemRect = item.getBoundingClientRect();
        const /** @type {?} */ offset = (itemRect.top + document.body.scrollTop) - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
        const /** @type {?} */ scroll = container.scrollTop;
        const /** @type {?} */ elementHeight = container.clientHeight;
        const /** @type {?} */ itemHeight = this.getOuterHeight(item);
        if (offset < 0) {
            container.scrollTop = scroll + offset;
        }
        else if ((offset + itemHeight) > elementHeight) {
            container.scrollTop = scroll + offset - elementHeight + itemHeight;
        }
    }
    /**
     * @param {?} element
     * @param {?} duration
     * @return {?}
     */
    fadeIn(element, duration) {
        element.style.opacity = 0;
        let /** @type {?} */ last = +new Date();
        let /** @type {?} */ opacity = 0;
        const /** @type {?} */ tick = () => {
            opacity = +element.style.opacity.replace(',', '.') + (new Date().getTime() - last) / duration;
            element.style.opacity = opacity;
            last = +new Date();
        };
        tick();
    }
    /**
     * @param {?} element
     * @param {?} ms
     * @return {?}
     */
    fadeOut(element, ms) {
        let /** @type {?} */ opacity = 1;
        const /** @type {?} */ interval = 50;
        const /** @type {?} */ duration = ms;
        const /** @type {?} */ gap = interval / duration;
        const /** @type {?} */ fading = setInterval(() => {
            opacity = opacity - gap;
            if (opacity <= 0) {
                opacity = 0;
                clearInterval(fading);
            }
            element.style.opacity = opacity;
        }, interval);
    }
    /**
     * @return {?}
     */
    getWindowScrollTop() {
        const /** @type {?} */ doc = document.documentElement;
        return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    }
    /**
     * @return {?}
     */
    getWindowScrollLeft() {
        const /** @type {?} */ doc = document.documentElement;
        return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    matches(element, selector) {
        const /** @type {?} */ p = Element.prototype;
        const /** @type {?} */ f = p['matches'] || p.webkitMatchesSelector || p['mozMatchesSelector'] || p.msMatchesSelector || function (s) {
            return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
        };
        return f.call(element, selector);
    }
    /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    getOuterWidth(el, margin) {
        let /** @type {?} */ width = el.offsetWidth;
        if (margin) {
            const /** @type {?} */ style = getComputedStyle(el);
            width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }
        return width;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getHorizontalPadding(el) {
        const /** @type {?} */ style = getComputedStyle(el);
        return parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getHorizontalMargin(el) {
        const /** @type {?} */ style = getComputedStyle(el);
        return parseFloat(style.marginLeft) + parseFloat(style.marginRight);
    }
    /**
     * @param {?} el
     * @return {?}
     */
    innerWidth(el) {
        let /** @type {?} */ width = el.offsetWidth;
        const /** @type {?} */ style = getComputedStyle(el);
        width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    width(el) {
        let /** @type {?} */ width = el.offsetWidth;
        const /** @type {?} */ style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getInnerHeight(el) {
        let /** @type {?} */ height = el.offsetHeight;
        const /** @type {?} */ style = getComputedStyle(el);
        height += parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
        return height;
    }
    /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    getOuterHeight(el, margin) {
        let /** @type {?} */ height = el.offsetHeight;
        if (margin) {
            const /** @type {?} */ style = getComputedStyle(el);
            height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }
        return height;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getHeight(el) {
        let /** @type {?} */ height = el.offsetHeight;
        const /** @type {?} */ style = getComputedStyle(el);
        height -= (parseFloat(style.paddingTop) + parseFloat(style.paddingBottom)
            + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth));
        return height;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getWidth(el) {
        let /** @type {?} */ width = el.offsetWidth;
        const /** @type {?} */ style = getComputedStyle(el);
        width -= (parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) +
            parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth));
        return width;
    }
    /**
     * @return {?}
     */
    getViewport() {
        const /** @type {?} */ win = window;
        const /** @type {?} */ d = document;
        const /** @type {?} */ e = d.documentElement;
        const /** @type {?} */ g = d.getElementsByTagName('body')[0];
        const /** @type {?} */ w = win.innerWidth || e.clientWidth || g.clientWidth;
        const /** @type {?} */ h = win.innerHeight || e.clientHeight || g.clientHeight;
        return { width: w, height: h };
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getOffset(el) {
        const /** @type {?} */ rect = el.getBoundingClientRect();
        return {
            top: rect.top + document.body.scrollTop,
            left: rect.left + document.body.scrollLeft,
        };
    }
    /**
     * @return {?}
     */
    getUserAgent() {
        return navigator.userAgent;
    }
    /**
     * @return {?}
     */
    isIE() {
        const /** @type {?} */ ua = window.navigator.userAgent;
        const /** @type {?} */ msie = ua.indexOf('MSIE ');
        if (msie > 0) {
            // IE 10 or older => return version number
            return true;
        }
        const /** @type {?} */ trident = ua.indexOf('Trident/');
        if (trident > 0) {
            // IE 11 => return version number
            return true;
        }
        const /** @type {?} */ edge = ua.indexOf('Edge/');
        if (edge > 0) {
            // Edge (IE 12+) => return version number
            return true;
        }
        // other browser
        return false;
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    appendChild(element, target) {
        if (this.isElement(target)) {
            target.appendChild(element);
        }
        else if (target.el && target.el.nativeElement) {
            target.el.nativeElement.appendChild(element);
        }
        else {
            throw new Error('Cannot append ' + target + ' to ' + element);
        }
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    removeChild(element, target) {
        if (this.isElement(target)) {
            target.removeChild(element);
        }
        else if (target.el && target.el.nativeElement) {
            target.el.nativeElement.removeChild(element);
        }
        else {
            throw new Error('Cannot remove ' + element + ' from ' + target);
        }
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    isElement(obj) {
        return (typeof HTMLElement === 'object' ? obj instanceof HTMLElement :
            obj && typeof obj === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string');
    }
    /**
     * @return {?}
     */
    calculateScrollbarWidth() {
        if (this.calculatedScrollbarWidth !== null) {
            return this.calculatedScrollbarWidth;
        }
        const /** @type {?} */ scrollDiv = document.createElement('div');
        scrollDiv.className = 'ui-scrollbar-measure';
        document.body.appendChild(scrollDiv);
        const /** @type {?} */ scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        this.calculatedScrollbarWidth = scrollbarWidth;
        return scrollbarWidth;
    }
    /**
     * @param {?} element
     * @param {?} methodName
     * @param {?=} args
     * @return {?}
     */
    invokeElementMethod(element, methodName, args) {
        (element)[methodName].apply(element, args);
    }
    /**
     * @return {?}
     */
    clearSelection() {
        if (window.getSelection) {
            if (window.getSelection().empty) {
                window.getSelection().empty();
            }
            else if (window.getSelection().removeAllRanges &&
                window.getSelection().rangeCount > 0 &&
                window.getSelection().getRangeAt(0).getClientRects().length > 0) {
                window.getSelection().removeAllRanges();
            }
        }
        else if (document['selection'] && document['selection'].empty) {
            try {
                document['selection'].empty();
            }
            catch (/** @type {?} */ error) {
                // ignore IE bug
            }
        }
    }
    /**
     * @return {?}
     */
    getBrowser() {
        if (!this.browser) {
            const /** @type {?} */ matched = this.resolveUserAgent();
            this.browser = {};
            if (matched.browser) {
                this.browser[matched.browser] = true;
                this.browser['version'] = matched.version;
            }
            if (this.browser['chrome']) {
                this.browser['webkit'] = true;
            }
            else if (this.browser['webkit']) {
                this.browser['safari'] = true;
            }
        }
        return this.browser;
    }
    /**
     * @return {?}
     */
    resolveUserAgent() {
        const /** @type {?} */ ua = navigator.userAgent.toLowerCase();
        const /** @type {?} */ match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
            /(webkit)[ \/]([\w.]+)/.exec(ua) ||
            /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
            /(msie) ([\w.]+)/.exec(ua) ||
            ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
            [];
        return {
            browser: match[1] || '',
            version: match[2] || '0',
        };
    }
}
DomHandler.zindex = 1000;
DomHandler.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 Component Name : Amexio Slider
 Component Selector :  <amexio-slider>
 Component Description : Slider with draggable input provide a way to input values
*/
class AmexioSliderComponent {
    /**
     * @param {?} el
     * @param {?} domHandler
     * @param {?} renderer
     * @param {?} ngZone
     */
    constructor(el, domHandler, renderer, ngZone) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /*
        Properties
        name : min-value
        datatype : number
        version : 4.0 onwards
        default :
        description : Min slider value
        */
        this.min = 0;
        /*
        Properties
        name : max-value
        datatype : number
        version : 4.0 onwards
        default :
        description : Max slider value
        */
        this.max = 100;
        /*
        Properties
        name : orientation
        datatype : string
        version : 4.0 onwards
        default : horizontal
        description : Vertical or Horizontal Orientation of slider
        */
        this.orientation = 'horizontal';
        /*
        Events
        name : onChange
        datatype : any
        version : 4.0 onwards
        default :
        description : Triggers when slider is moved
        */
        this.onChange = new EventEmitter();
        /*
        Events
        name : onSlideEnd
        datatype : any
        version : 4.0 onwards
        default :
        description : Triggers when slider reaches the end
        */
        this.onSlideEnd = new EventEmitter();
        this.handleIndex = 0;
        this.handleValues = [];
        this.onModelChange = () => { };
        this.onModelTouched = () => { };
    }
    /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    onMouseDown(event, index) {
        if (this.disabled) {
            return;
        }
        this.dragging = true;
        this.updateDomData();
        this.sliderHandleClick = true;
        this.handleIndex = index;
        this.bindDragListeners();
        event.preventDefault();
    }
    /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    onTouchStart(event, index) {
        const /** @type {?} */ touchobj = event.changedTouches[0];
        this.startHandleValue = (this.range) ? this.handleValues[index] : this.handleValue;
        this.dragging = true;
        this.handleIndex = index;
        if (this.orientation === 'horizontal') {
            this.startx = parseInt(touchobj.clientX, 10);
            this.barWidth = this.el.nativeElement.children[0].offsetWidth;
        }
        else {
            this.starty = parseInt(touchobj.clientY, 10);
            this.barHeight = this.el.nativeElement.children[0].offsetHeight;
        }
        event.preventDefault();
    }
    /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    onTouchMove(event, index) {
        const /** @type {?} */ touchobj = event.changedTouches[0];
        let /** @type {?} */ handleValue = 0;
        if (this.orientation === 'horizontal') {
            handleValue = Math.floor(((parseInt(touchobj.clientX, 10) - this.startx) * 100) / (this.barWidth)) + this.startHandleValue;
        }
        else {
            handleValue = Math.floor(((this.starty - parseInt(touchobj.clientY, 10)) * 100) / (this.barHeight)) + this.startHandleValue;
        }
        this.setValueFromHandle(event, handleValue);
        event.preventDefault();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBarClick(event) {
        if (this.disabled) {
            return;
        }
        if (!this.sliderHandleClick) {
            this.updateDomData();
            this.handleChange(event);
        }
        this.sliderHandleClick = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleChange(event) {
        const /** @type {?} */ handleValue = this.calculateHandleValue(event);
        this.setValueFromHandle(event, handleValue);
    }
    /**
     * @return {?}
     */
    bindDragListeners() {
        this.ngZone.runOutsideAngular(() => {
            if (!this.dragListener) {
                this.dragListener = this.renderer.listen('document', 'mousemove', (event) => {
                    if (this.dragging) {
                        this.ngZone.run(() => {
                            this.handleChange(event);
                        });
                    }
                });
            }
            if (!this.mouseupListener) {
                this.mouseupListener = this.renderer.listen('document', 'mouseup', (event) => {
                    this.mouseUpListMethod();
                });
            }
        });
    }
    /**
     * @return {?}
     */
    mouseUpListMethod() {
        if (this.dragging) {
            this.dragging = false;
            this.ngZone.run(() => {
                if (this.range) {
                    this.onSlideEnd.emit({ originalEvent: event, values: this.values });
                }
                else {
                    this.onSlideEnd.emit({ originalEvent: event, value: this.value });
                }
            });
        }
    }
    /**
     * @return {?}
     */
    unbindDragListeners() {
        if (this.dragListener) {
            this.dragListener();
        }
        if (this.mouseupListener) {
            this.mouseupListener();
        }
    }
    /**
     * @param {?} event
     * @param {?} handleValue
     * @return {?}
     */
    setValueFromHandle(event, handleValue) {
        const /** @type {?} */ newValue = this.getValueFromHandle(handleValue);
        if (this.range) {
            if (this.step) {
                this.handleStepChange(newValue, this.values[this.handleIndex]);
            }
            else {
                this.handleValues[this.handleIndex] = handleValue;
                this.updateValue(newValue, event);
            }
        }
        else {
            if (this.step) {
                this.handleStepChange(newValue, this.value);
            }
            else {
                this.handleValue = handleValue;
                this.updateValue(newValue, event);
            }
        }
    }
    /**
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    handleStepChange(newValue, oldValue) {
        const /** @type {?} */ diff = (newValue - oldValue);
        let /** @type {?} */ val = oldValue;
        if (diff < 0) {
            val = oldValue + Math.ceil((newValue - oldValue) / this.step) * this.step;
        }
        else if (diff > 0) {
            val = oldValue + Math.floor((newValue - oldValue) / this.step) * this.step;
        }
        this.updateValue(val);
        this.updateHandleValue();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (this.range) {
            this.values = value || [0, 0];
        }
        else {
            this.value = value || 0;
        }
        this.updateHandleValue();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    setDisabledState(val) {
        this.disabled = val;
    }
    /**
     * @return {?}
     */
    get rangeStartLeft() {
        return this.isVertical() ? 'auto' : this.handleValues[0] + '%';
    }
    /**
     * @return {?}
     */
    get rangeStartBottom() {
        return this.isVertical() ? this.handleValues[0] + '%' : 'auto';
    }
    /**
     * @return {?}
     */
    get rangeEndLeft() {
        return this.isVertical() ? 'auto' : this.handleValues[1] + '%';
    }
    /**
     * @return {?}
     */
    get rangeEndBottom() {
        return this.isVertical() ? this.handleValues[1] + '%' : 'auto';
    }
    /**
     * @return {?}
     */
    isVertical() {
        return this.orientation === 'vertical';
    }
    /**
     * @return {?}
     */
    updateDomData() {
        const /** @type {?} */ rect = this.el.nativeElement.children[0].getBoundingClientRect();
        this.initX = rect.left + this.domHandler.getWindowScrollLeft();
        this.initY = rect.top + this.domHandler.getWindowScrollTop();
        this.barWidth = this.el.nativeElement.children[0].offsetWidth;
        this.barHeight = this.el.nativeElement.children[0].offsetHeight;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    calculateHandleValue(event) {
        if (this.orientation === 'horizontal') {
            return ((event.pageX - this.initX) * 100) / (this.barWidth);
        }
        else {
            return (((this.initY + this.barHeight) - event.pageY) * 100) / (this.barHeight);
        }
    }
    /**
     * @return {?}
     */
    updateHandleValue() {
        if (this.range) {
            this.handleValues[0] = (this.values[0] < this.min ? 0 : this.values[0] - this.min) * 100 / (this.max - this.min);
            this.handleValues[1] = (this.values[1] > this.max ? 100 : this.values[1] - this.min) * 100 / (this.max - this.min);
        }
        else {
            if (this.value < this.min) {
                this.handleValue = 0;
            }
            else if (this.value > this.max) {
                this.handleValue = 100;
            }
            else {
                this.handleValue = (this.value - this.min) * 100 / (this.max - this.min);
            }
        }
    }
    /**
     * @param {?} val
     * @param {?=} valueEvent
     * @return {?}
     */
    updateValue(val, valueEvent) {
        if (this.range) {
            let /** @type {?} */ value = val;
            if (this.handleIndex === 0) {
                if (value < this.min) {
                    value = this.min;
                    this.handleValues[0] = 0;
                }
                else if (value > this.values[1]) {
                    value = this.values[1];
                    this.handleValues[0] = this.handleValues[1];
                }
            }
            else {
                if (value > this.max) {
                    value = this.max;
                    this.handleValues[1] = 100;
                }
                else if (value < this.values[0]) {
                    value = this.values[0];
                    this.handleValues[1] = this.handleValues[0];
                }
            }
            this.values[this.handleIndex] = Math.floor(value);
            this.onModelChange(this.values);
            this.onChange.emit({ event: valueEvent, values: this.values });
        }
        else {
            this.updateValueNoRange(val, valueEvent);
        }
    }
    /**
     * @param {?} val
     * @param {?=} valueEvent
     * @return {?}
     */
    updateValueNoRange(val, valueEvent) {
        if (val < this.min) {
            val = this.min;
            this.handleValue = 0;
        }
        else if (val > this.max) {
            val = this.max;
            this.handleValue = 100;
        }
        this.value = Math.floor(val);
        this.onModelChange(this.value);
        this.onChange.emit({ event: valueEvent, value: this.value });
    }
    /**
     * @param {?} handleValue
     * @return {?}
     */
    getValueFromHandle(handleValue) {
        return (this.max - this.min) * (handleValue / 100) + this.min;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unbindDragListeners();
    }
}
AmexioSliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-slider',
                template: `
    <div [ngStyle]="style" [class]="styleClass"
    [ngClass]="{'ui-slider ui-widget ui-widget-content ui-corner-all':true,'disable-component':disabled,
            'ui-slider-horizontal':orientation == 'horizontal',
            'ui-slider-vertical':orientation == 'vertical','ui-slider-animate':animate}"
         (click)="onBarClick($event)">
      <span *ngIf="range && orientation == 'horizontal'" class="ui-slider-range ui-widget-header ui-corner-all"
      [ngStyle]="{'left':handleValues[0] + '%',width: (handleValues[1] - handleValues[0] + '%')}"></span>
      <span *ngIf="range && orientation == 'vertical'" class="ui-slider-range ui-widget-header ui-corner-all"
      [ngStyle]="{'bottom':handleValues[0] + '%',height: (handleValues[1] - handleValues[0] + '%')}"></span>
      <span *ngIf="!range && orientation=='vertical'" class="ui-slider-range ui-slider-range-min ui-widget-header ui-corner-all"
      [ngStyle]="{'height': handleValue + '%'}"></span>
      <span *ngIf="!range && orientation=='horizontal'" class="ui-slider-range ui-slider-range-min ui-widget-header ui-corner-all"
      [ngStyle]="{'width': handleValue + '%'}"></span>
      <span *ngIf="!range" class="ui-slider-handle ui-state-default ui-corner-all ui-clickable"
      (mousedown)="onMouseDown($event)" (touchstart)="onTouchStart($event)" (touchmove)="onTouchMove($event)" (touchend)="dragging=false"
            [style.transition]="dragging ? 'none': null" [ngStyle]="{'left': orientation == 'horizontal' ? handleValue + '%' : null,
            'bottom': orientation == 'vertical' ? handleValue + '%' : null}"></span>
      <span *ngIf="range" (mousedown)="onMouseDown($event,0)"
      (touchstart)="onTouchStart($event,0)" (touchmove)="onTouchMove($event,0)" (touchend)="dragging=false"
      [style.transition]="dragging ? 'none': null" class="ui-slider-handle ui-state-default ui-corner-all ui-clickable"
            [ngStyle]="{'left': rangeStartLeft, 'bottom': rangeStartBottom}"
            [ngClass]="{'ui-slider-handle-active':handleIndex==0}"></span>
      <span *ngIf="range" (mousedown)="onMouseDown($event,1)"
      (touchstart)="onTouchStart($event,1)" (touchmove)="onTouchMove($event,1)"
      (touchend)="dragging=false"
      [style.transition]="dragging ? 'none': null"
      class="ui-slider-handle ui-state-default ui-corner-all ui-clickable"
            [ngStyle]="{'left': rangeEndLeft, 'bottom': rangeEndBottom}" [ngClass]="{'ui-slider-handle-active':handleIndex==1}"></span>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioSliderComponent), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioSliderComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: DomHandler },
    { type: Renderer2 },
    { type: NgZone }
];
AmexioSliderComponent.propDecorators = {
    animate: [{ type: Input }],
    disabled: [{ type: Input }],
    min: [{ type: Input, args: ['min-value',] }],
    max: [{ type: Input, args: ['max-value',] }],
    orientation: [{ type: Input }],
    step: [{ type: Input, args: ['step-value',] }],
    range: [{ type: Input }],
    style: [{ type: Input }],
    styleClass: [{ type: Input, args: ['style-class',] }],
    onChange: [{ type: Output }],
    onSlideEnd: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioSpinnerComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        /*
          Events
          name : show
          datatype : boolean
          version : none
          default : true
          description : if show  is true than and only than the spinner is enable, if false then it is disable.
          */
        this.show = true;
        this.alpha = '0.2';
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set color(v) {
        const /** @type {?} */ ischanges = (this._color !== v);
        this._color = v;
        if (ischanges) {
            this.assignColor();
        }
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.assignColor();
    }
    /**
     * @return {?}
     */
    assignColor() {
        if (this.type === 'spinnerround' && this.color) {
            let /** @type {?} */ newColor;
            const /** @type {?} */ r = parseInt(this.color.slice(1, 3), 16);
            const /** @type {?} */ g = parseInt(this.color.slice(3, 5), 16);
            const /** @type {?} */ b = parseInt(this.color.slice(5, 7), 16);
            if (this.alpha) {
                newColor = `rgba(${r}, ${g}, ${b}, ${this.alpha})`;
            }
            else {
                newColor = `rgba(${r}, ${g}, ${b})`;
            }
            const /** @type {?} */ inlinecss = 'margin: 60px auto;font-size: 10px;position: relative;text-indent: -9999em;border-top: 1.1em solid ' + newColor +
                '; border-right: 1.1em solid ' + newColor +
                ';border-left: 1.1em solid ;-webkit-transform: translateZ(0);-ms-transform: translateZ(0);border-bottom: 1.1em solid ' + newColor +
                ';transform: translateZ(0);  -webkit-animation: load8 1.1s infinite linear;animation: load8 1.1s infinite linear;';
            const /** @type {?} */ inlinecssafter = ' border-radius: 50%; width: 10em; height: 10em;';
            this.insertStyleSheetRule('.dynamicclass { ' + inlinecss + inlinecssafter + '}');
            this.insertStyleSheetRule('@-webkit-keyframes load8 { 0% {  -webkit-transform: rotate(0deg);  transform: rotate(0deg);} ' +
                '100%{-webkit-transform: rotate(360deg); transform: rotate(360deg);} }');
            this.renderer.addClass(this.element.nativeElement, 'dynamicclass');
        }
    }
    /**
     * @param {?} ruleText
     * @return {?}
     */
    insertStyleSheetRule(ruleText) {
        const /** @type {?} */ sheets = document.styleSheets;
        if (sheets.length === 0) {
            const /** @type {?} */ style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        const /** @type {?} */ sheet = sheets[sheets.length - 1];
        sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
    }
}
AmexioSpinnerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-spinner',
                template: `
    <div #loadindicator [ngStyle]="{'display': show ? 'block': 'none'}" 
    [style.color]='color' [style.font-size]= 'size'
     [ngClass]="{
            'rectangle-bounces' :type == 'rectanglebounce',
            'rings' :type == 'ring',
            'half-circles' :type == 'halfcircle',
            'fading-circles' :type == 'fadingcircle',
            'ball-spins' :type == 'ballspin',
            'fire-spins' :type == 'firespin',
            'three-bounces' :type == 'threebounce',
            'spinner-rounds' :type == 'spinnerround'}
            ">
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioSpinnerComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexioSpinnerComponent.propDecorators = {
    type: [{ type: Input, args: ['type',] }],
    color: [{ type: Input, args: ['color',] }],
    show: [{ type: Input }],
    size: [{ type: Input, args: ['size',] }],
    element: [{ type: ViewChild, args: ['loadindicator',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 20/12/17.
 */
class AmexioTagsInputComponent extends BaseFormValidator {
    /**
     * @param {?} dataService
     * @param {?} element
     * @param {?} renderer
     * @param {?} _cd
     */
    constructor(dataService, element, renderer, _cd) {
        super(renderer, element, _cd);
        this.dataService = dataService;
        this.element = element;
        this.renderer = renderer;
        /*
         Properties
         name : has-label
         datatype : boolean
         version : 4.0 onwards
         default : false
         description : flag to set label
         */
        this.haslabel = true;
        /*
         Events
         name : input
         datatype : any
         version : none
         default :
         description :	On input event field.
         */
        this.input = new EventEmitter();
        /*
        Events
        name : onChange
        datatype : any
        version : none
        default :
        description : on change event
        */
        this.onChange = new EventEmitter();
        /*
        Events
        name : focus
        datatype : any
        version : none
        default :
        description : On field focus event
        */
        this.focus = new EventEmitter();
        this.onSelections = [];
        this.activeindex = 0;
        this.selectedindex = 0;
        this.scrollposition = 30;
        this.isComponentValid = new EventEmitter();
        this.maskloader = true;
    }
    /**
     * @return {?}
     */
    get errormsg() {
        return this._errormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set errormsg(value) {
        this.helpInfoMsg = value + '<br/>';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isComponentValid.emit(this.allowblank);
        if (this.placeholder === '' || this.placeholder === null) {
            this.placeholder = 'Choose Option';
        }
        if (!this.triggerchar) {
            this.triggerchar = 1;
        }
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.responseData = response;
            }, (error) => {
            }, () => {
                this.setData(this.responseData);
            });
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateKey(event) {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUp(event) {
        this.filteredResult = [];
        this.showToolTip = false;
        const /** @type {?} */ keyword = event.target.value;
        if (keyword !== null && keyword !== ' ' && keyword.length >= this.triggerchar) {
            const /** @type {?} */ search_term = keyword.toLowerCase();
            this.viewData.forEach((item) => {
                if (item != null && item[this.key].toLowerCase().startsWith(search_term)) {
                    this.filteredResult.push(item);
                }
            });
            if (this.filteredResult.length > 0) {
                this.showToolTip = true;
                this.onBaseFocusEvent({});
            }
            else {
                this.showToolTip = this.onBaseBlurEvent({});
            }
        }
        if (event.keyCode === 40 || event.keyCode === 38 || event.keyCode === 13) {
            this.navigateUsingKey(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateUsingKey(event) {
        if (this.selectedindex > this.filteredResult.length) {
            this.selectedindex = 0;
        }
        if (event.keyCode === 40 || event.keyCode === 38 && this.selectedindex < this.filteredResult.length) {
            this.keyUpDownMethod(event);
        }
        if (event.keyCode === 13 && this.filteredResult[this.selectedindex]) {
            this.onItemSelect(this.filteredResult[this.selectedindex]);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    keyUpDownMethod(event) {
        if (!this.showToolTip) {
            this.showToolTip = true;
        }
        let /** @type {?} */ prevselectedindex = 0;
        if (this.selectedindex === 0) {
            this.selectedindex = 1;
        }
        else {
            prevselectedindex = this.selectedindex;
            if (event.keyCode === 40) {
                this.selectedindex++;
                if ((this.selectedindex > 5)) {
                    this.dropdownitems.nativeElement.scroll(0, this.scrollposition);
                    this.scrollposition = this.scrollposition + 30;
                }
            }
            else if (event.keyCode === 38) {
                this.keyUpMethod();
            }
        }
        if (this.filteredResult[this.selectedindex]) {
            this.filteredResult[this.selectedindex].selected = true;
        }
        if (this.filteredResult[prevselectedindex]) {
            this.filteredResult[prevselectedindex].selected = false;
        }
    }
    /**
     * @return {?}
     */
    keyUpMethod() {
        this.selectedindex--;
        if (this.scrollposition >= 0 && this.selectedindex > 1) {
            this.dropdownitems.nativeElement.scroll(0, this.scrollposition);
            this.scrollposition = this.scrollposition - 30;
        }
        if (this.selectedindex === 1) {
            this.scrollposition = 30;
        }
    }
    /**
     * @param {?} activerow
     * @return {?}
     */
    showAllData(activerow) {
        let /** @type {?} */ i = 0;
        this.viewData.forEach((item) => {
            if (item != null) {
                if (i === activerow) {
                    item.active = true;
                    this.currentActive = item;
                }
                else {
                    item.active = false;
                }
                item.activerow = activerow;
                this.filteredResult.push(item);
            }
            i++;
        });
        if (this.filteredResult.length > 0) {
            this.showToolTip = true;
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    onItemSelect(row) {
        this.value = row[this.valuefield];
        this.displayValue = row[this.displayfield];
        this.showToolTip = false;
    }
    /**
     * @param {?} input
     * @return {?}
     */
    onInput(input) {
        this.input.emit();
    }
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onFocus(elem) {
        this.inpHandle.nativeElement.placeholder = '';
        this.showToolTip = true;
        this.onBaseFocusEvent({});
        this.posixUp = this.getListPosition(elem);
        this.focus.emit(this.value);
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        const /** @type {?} */ dropdownHeight = 325;
        // must be same in dropdown.scss
        if (elementRef) {
            if (window.screen.height - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
                return true;
            }
            else {
                return false;
            }
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewData = responsedata;
        this.maskloader = false;
    }
    /**
     * @param {?} value
     * @param {?} ref
     * @return {?}
     */
    setValue(value, ref) {
        this.inpHandle.nativeElement.value = '';
        this.onSelections.push(value);
        this.onChange.emit(this.onSelections);
        if (this.onSelections.length > 0) {
            this.isValid = true;
            this.isComponentValid.emit(true);
        }
        this.showToolTip = false;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    removePill(item) {
        let /** @type {?} */ indexToRemove = null;
        this.onSelections.forEach((selectedVal, index) => {
            if (selectedVal === item) {
                indexToRemove = index;
            }
        });
        this.onSelections.splice(indexToRemove, 1);
        if (this.onSelections.length === 0) {
            this.isValid = false;
            this.isComponentValid.emit(false);
        }
        this.onChange.emit(this.onSelections);
    }
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
}
AmexioTagsInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tag-input', template: `
    <div class="inputgroup" #rootDiv>

        <label *ngIf="haslabel" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
        {{fieldlabel}}
      </label>


        <div class="tag-input" [ngClass]="{'loading-mask' : maskloader}">
            <div class="tag" *ngFor="let item of onSelections">
                {{item[key]}}
                <span class="closebtn" (click)="removePill(item)">&times;</span>
            </div>

            <input type="text" class="input-control" [ngClass]="{'input-control-error' : inp.invalid && (inp.dirty || inp.touched),'input-control-success' : inp.valid && (inp.dirty || inp.touched)}" (focus)="onFocus(rootDiv)" (input)="onInput(inp)" (keyup)="onKeyUp($event)"
                [attr.placeholder]="placeholder" [attr.disabled]="disabled ? true: null" [required]="allowblank ? true: null" #inp/>

        </div>


        <span #dropdownitems class="dropdown" [ngClass]="{'dropdown-up' : posixUp}" [ngStyle]="dropdownstyle" #tagDropRef>
        <ul class="dropdown-list">
          <li class="list-items" [ngClass]="{'list-items-selected':item.selected}"
              *ngFor="let item of filteredResult"
              (click)="setValue(item,inp)"><div>{{item[displayfield]}}</div></li>
        </ul>
      </span>

    </div>


    <span *ngIf="iconfeedback && (inp.invalid && (inp.dirty || inp.touched) || inp.valid)" class="input-control-feedback">
            <span *ngIf="inp.invalid && (inp.dirty || inp.touched)">&#9888;</span>
    <span *ngIf="inp.valid && (inp.dirty || inp.touched)"> &#10004;</span>

    </span>

    <span *ngIf="showToolTip && enablepopover" class="tooltiptext">
            <div [innerHTML]="helpInfoMsg"></div>
    </span>
  `,
            },] },
];
/** @nocollapse */
AmexioTagsInputComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
AmexioTagsInputComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    data: [{ type: Input }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    key: [{ type: Input }],
    triggerchar: [{ type: Input, args: ['trigger-char',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    input: [{ type: Output }],
    onChange: [{ type: Output }],
    focus: [{ type: Output }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    inpHandle: [{ type: ViewChild, args: ['inp',] }],
    tagDropRef: [{ type: ViewChild, args: ['tagDropRef',] }],
    dropdownitems: [{ type: ViewChild, args: ['dropdownitems', { read: ElementRef },] }],
    isComponentValid: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioTextAreaComponent extends ValueAccessorBase {
    constructor() {
        super();
        this.isComponentValid = new EventEmitter();
        /*
        Events
        name : onBlur
        datatype : any
        version : 4.0 onwards
        default :
        description : On blur event
        */
        this.onBlur = new EventEmitter();
        /*
         Events
         name : input
         datatype : any
         version : none
         default :
         description : 	On input event field.
         */
        this.input = new EventEmitter();
        /*
         Events
         name : focus
         datatype : any
         version : none
         default :
         description : On focus event field.
         */
        this.focus = new EventEmitter();
        /*
         Events
         name : change
         datatype : any
         version : none
         default :
         description : On field value change event
         */
        this.change = new EventEmitter();
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : none
        description : flag to set label
        */
        this.haslabel = true;
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    get errormsg() {
        return this._errormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set errormsg(value) {
        this.helpInfoMsg = value + '<br/>';
    }
    /**
     * @return {?}
     */
    get minerrormsg() {
        return this._minerrormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set minerrormsg(value) {
        this.helpInfoMsg = this.helpInfoMsg + '<b>Min Length<b/>: ' + value + '<br/>';
    }
    /**
     * @return {?}
     */
    get maxerrormsg() {
        return this._maxerrormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxerrormsg(value) {
        this.helpInfoMsg = this.helpInfoMsg + 'Max Length: ' + value;
    }
    /**
     * @return {?}
     */
    get pattern() {
        return this._pattern;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set pattern(value) {
        if (value != null) {
            this._pattern = value;
            this.regEx = new RegExp(this._pattern);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'textareainput');
        this.isComponentValid.emit(this.allowblank);
    }
    /**
     * @return {?}
     */
    onBlurEvent() {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.showToolTip = true;
        this.focus.emit(this.value);
    }
    /**
     * @return {?}
     */
    onInput() {
        this.isValid = this.isFieldValid();
        this.input.emit(this.value);
    }
    /**
     * @return {?}
     */
    onChangeEv() {
        this.change.emit(this.value);
    }
    /**
     * @return {?}
     */
    isFieldValid() {
        return (!this.allowblank && (this.value && (this.value.length > 0)) ||
            (this.value && this.value.length > 0)) || this.allowblank;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.isFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioTextAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-textarea-input',
                template: `

    <div class="inputgroup form-group">

      <label *ngIf="haslabel" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
        {{fieldlabel}}
      </label>

      <textarea type="text" class="input-control"
             [(ngModel)]="value"
             #inp="ngModel"
             [ngClass]="componentClass"
             (blur)="onBlurEvent()"
             (focus)="onFocus()"
             (input)="onInput()"
             [name]="name"
             [pattern]="regEx"
             #ref
             [attr.placeholder]="placeholder"
             [attr.rows]="rows"
             [attr.cols]="columns"
             [attr.disabled] = "disabled ? true: null"
             [required]="!allowblank">
      </textarea>

      <span *ngIf="iconfeedback && (inp.invalid && (inp.dirty || inp.touched) || inp.valid)" class="input-control-feedback">
            <span *ngIf="!isValid && inp.touched"><em class="fa fa-times"></em></span>
            <span *ngIf="isValid && inp.touched"><em class="fa fa-check"></em></span>
          </span>

      <span *ngIf="showToolTip && enablepopover" class="dropdown tooltiptext">
            <div  [innerHTML]="helpInfoMsg"></div>
      </span>
      <span class="inputfieldbar"></span>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioTextAreaComponent), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef(() => AmexioTextAreaComponent), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioTextAreaComponent.ctorParameters = () => [];
AmexioTextAreaComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    rows: [{ type: Input }],
    columns: [{ type: Input }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    isComponentValid: [{ type: Output }],
    onBlur: [{ type: Output }],
    input: [{ type: Output }],
    focus: [{ type: Output }],
    change: [{ type: Output }],
    inputRef: [{ type: ViewChild, args: ['ref', { read: ElementRef },] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    minerrormsg: [{ type: Input, args: ['min-error-msg',] }],
    maxerrormsg: [{ type: Input, args: ['max-error-msg',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    pattern: [{ type: Input, args: ['pattern',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    name: [{ type: Input, args: ['name',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ToolbaroneComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
ToolbaroneComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-toolbar-item',
                template: `
  <div [ngClass]="{'toolbaritemseperatorright':(seperatorposition === 'right'),'toolbaritemseperatorleft':(seperatorposition === 'left')}">
  <ng-content></ng-content>
  </div>
   `,
            },] },
];
/** @nocollapse */
ToolbaroneComponent.ctorParameters = () => [];
ToolbaroneComponent.propDecorators = {
    seperatorposition: [{ type: Input, args: ['seperator-position',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ToolbarComponent {
    constructor() {
        /*
          Events
          name : onClick
          datatype : none
          version : none
          default : none
          description : Callback to invoke on activated tab event.
          */
        this.onClick = new EventEmitter();
        this.toolbarposition = 'top';
        this.seperator = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.toolCollection = this.queryTool.toArray();
        for (const /** @type {?} */ i of this.toolCollection) {
            [i]['position'] = this.getToolbaritemposition([i]['position']);
        }
    }
    /**
     * @param {?} position
     * @return {?}
     */
    getToolbaritemposition(position) {
        if (position === 'right') {
            return 'main-right';
        }
        if (position === 'left') {
            return 'main-left';
        }
        if (position === 'center') {
            return 'main-center';
        }
        if (position === '') {
            return 'main-center';
        }
    }
    /**
     * @param {?} tool
     * @return {?}
     */
    onToolClick(tool) {
        if (!tool.disabled) {
            for (const /** @type {?} */ i of this.toolCollection) {
                if ([i] === tool) {
                    [i]['active'] = true;
                    this.onClick.emit(tool);
                }
                else {
                    [i]['active'] = false;
                }
            }
        }
    }
    /**
     * @param {?} toolnode
     * @return {?}
     */
    getSeperatotClass(toolnode) {
        let /** @type {?} */ cssName = '';
        if (this.seperator) {
            cssName = 'seperator-line';
        }
        cssName = cssName + toolnode.position;
        return cssName;
    }
    /**
     * @return {?}
     */
    getToolbarPosition() {
        if (this.toolbarposition === 'top') {
            return '';
        }
        if (this.toolbarposition === 'right') {
            return '';
        }
        if (this.toolbarposition === 'bottom') {
            return '';
        }
    }
}
ToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-toolbar',
                template: `


    <div class="toolbar">
        <div class="topnavmainbar">
            <div class="toolbar-item">
                <ng-content select="[position-left]"></ng-content>
                <ng-content select="amexio-panel-header"></ng-content>
                <ng-content select="amexio-form-header"></ng-content>
                <ng-content select="amexio-window-header"></ng-content>
            </div>
            <div class="toolbar-item">
                <ng-content select="[position-center]"></ng-content>
            </div>
            <div class="toolbar-item">
                <ng-content select="[position-right]"></ng-content>
            </div>
        </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
ToolbarComponent.ctorParameters = () => [];
ToolbarComponent.propDecorators = {
    seperator: [{ type: Input, args: ['seperator',] }],
    toolbarposition: [{ type: Input, args: ['toolbar-position',] }],
    onClick: [{ type: Output }],
    tabLocalData: [{ type: Input }],
    queryTool: [{ type: ContentChildren, args: [ToolbaroneComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ToolBarActionComponent {
    constructor() {
        /*
          Events
          name : navLinkClick
          datatype : any
          version : none
          default : none
          description : Fire when nav item is clicked,
          This event is fired when nav item type is defined as 'link/button/menu'
        
          */
        this.navLinkClick = new EventEmitter();
        this.actionComponent = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    onClick(clickEvent) {
        const /** @type {?} */ node = {
            title: this.title,
            type: this.type,
        };
        this.navLinkClick.emit({ data: node, event: clickEvent });
    }
    /**
     * @return {?}
     */
    checkActionComponent() {
        this.dropdown = this.queryDropDown.toArray();
        if (this.dropdown.length > 0) {
            this.actionComponent = 'dropdown';
            this.dropdown[0].fieldlabel = '';
        }
        this.button = this.queryButton.toArray();
        if (this.button.length > 0) {
            this.actionComponent = 'button';
        }
    }
}
ToolBarActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-toolbar-action',
                template: `
   <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
ToolBarActionComponent.ctorParameters = () => [];
ToolBarActionComponent.propDecorators = {
    queryDropDown: [{ type: ContentChildren, args: [AmexioDropDownComponent, { descendants: true },] }],
    queryButton: [{ type: ContentChildren, args: [AmexioButtonComponent, { descendants: true },] }],
    queryLabel: [{ type: ContentChildren, args: [AmexioLabelComponent, { descendants: true },] }],
    type: [{ type: Input }],
    title: [{ type: Input }],
    navLinkClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DropDownListComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.itemclick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDropDownListClick(event) {
        this.itemclick.emit(event);
    }
    /**
     * @param {?} rowindex
     * @return {?}
     */
    scroll(rowindex) {
        const /** @type {?} */ listitems = this.elementRef.nativeElement.getElementsByClassName('list-items')[rowindex];
        if (listitems) {
            listitems.scrollIntoView({ behavior: 'smooth' });
        }
    }
    /**
     * @return {?}
     */
    selectedItem() {
        return this.elementRef.nativeElement.getElementsByClassName('list-items list-items-selected');
    }
}
DropDownListComponent.decorators = [
    { type: Component, args: [{
                selector: 'dropdown-list-item',
                template: `
          <ul class="dropdown-list">
              <li  [ngClass]="{'list-items-selected': (i === highlightrow)}" 
                   class="list-items" 
                   [attr.valuefield]="item[valuefield]" 
                   [attr.displayfield]="item[displayfield]" 
                   *ngFor="let item of viewdata | async | filterpipe : displayfield : displayValue ; index as i"  
                  (mousedown)="onDropDownListClick(item)">
                  <ng-container *ngIf="!template">
                      <div>{{item[displayfield]}}</div>    
                  </ng-container>

                  <ng-container *ngIf="template">
                      <ng-template [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{ $implicit: { text : row }, row: item }">
                      </ng-template>
                  </ng-container>
    
              </li>
          </ul>
    `,
            },] },
];
/** @nocollapse */
DropDownListComponent.ctorParameters = () => [
    { type: ElementRef }
];
DropDownListComponent.propDecorators = {
    viewdata: [{ type: Input, args: ['data',] }],
    highlightrow: [{ type: Input, args: ['highlight-row',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    displayValue: [{ type: Input, args: ['display-value',] }],
    itemclick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class ListBaseComponent extends BaseInput {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} cd
     */
    constructor(renderer, element, cd) {
        super();
        this.renderer = renderer;
        this.element = element;
        this.cd = cd;
        this.self = false;
        this.itemClick = false;
        this.hide();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFocusEvent(event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'visible' };
        this.bindDocumentClickListener();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    blur(event) {
        this.itemClicked();
    }
    /**
     * @return {?}
     */
    itemClicked() {
        this.itemClick = true;
        this.hide();
        this.unbindDocumentClickListener();
        this.clearClicks();
    }
    /**
     * @return {?}
     */
    bindDocumentClickListener() {
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer
                .listen('document', 'click', (event) => this.handleDocumentListener(event));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleDocumentListener(event) {
        if (!this.self && !this.itemClick) {
            this.hide();
            this.unbindDocumentClickListener();
        }
        this.clearClicks();
        this.cd.markForCheck();
    }
    /**
     * @return {?}
     */
    clearClicks() {
        this.self = false;
        this.itemClick = false;
    }
    /**
     * @return {?}
     */
    unbindDocumentClickListener() {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    }
    /**
     * @return {?}
     */
    hide() {
        this.dropdownstyle = { visibility: 'hidden' };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 11/21/17.
 */
class AmexioTypeAheadComponent extends ListBaseComponent {
    /**
     * @param {?} dataService
     * @param {?} element
     * @param {?} renderer
     * @param {?} cd
     */
    constructor(dataService, element, renderer, cd) {
        super(renderer, element, cd);
        this.dataService = dataService;
        this.element = element;
        this.displayValue = '';
        this.onBlur = new EventEmitter();
        this.onInputOutput = new EventEmitter();
        this.onFocusOutput = new EventEmitter();
        this.change = new EventEmitter();
        this.onClick = new EventEmitter();
        this.isComponentValid = new EventEmitter();
        this.rowindex = 0;
        this.maskloader = true;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set fieldlabel(v) {
        if (v != null && v.length > 0) {
            this._fieldlabel = v;
            this.initComponent();
        }
    }
    /**
     * @return {?}
     */
    get fieldlabel() {
        return this._fieldlabel;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set haslabel(v) {
        this._haslabel = v;
    }
    /**
     * @return {?}
     */
    get haslabel() {
        return this._haslabel;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set key(v) {
        this._key = v;
        this.displayfield = this._key;
    }
    /**
     * @return {?}
     */
    get key() {
        return this._key;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.dropdown = this.dropdownlist.toArray();
        setTimeout(() => {
            this.dropdown.forEach((dropdown) => {
                dropdown.template = this.bodyTemplate;
            });
        }, 200);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["placeholder"] && !changes["placeholder"].isFirstChange()) {
            this.placeholder = changes["placeholder"].currentValue;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'typeaheadinput');
        if (!this.valuefield) {
            this.valuefield = this.displayfield;
        }
        this.isValid = this.allowblank;
        this.isComponentValid.emit(this.allowblank);
        if (this.placeholder === '' || this.placeholder == null) {
            this.placeholder = 'Choose Option';
        }
        if (!this.triggerchar) {
            this.triggerchar = 1;
        }
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.responseData = response;
            }, (error) => {
            }, () => {
                this.setData(this.responseData);
            });
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    input(event) {
        this.displayValue = event.target.value;
        this.rowindex = 0;
        if (this.displayValue.length >= 0 && !this.self && this.displayValue.length >= this.triggerchar) {
            this.dropdownstyle = { visibility: 'visible' };
            this.bindDocumentClickListener();
        }
        else {
            this.dropdownstyle = { visibility: 'hidden' };
        }
        this.onInputOutput.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focus(event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'hidden' };
        this.bindDocumentClickListener();
        this.onFocusOutput.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    keyup(event) {
        const /** @type {?} */ keycode = event.keyCode;
        if (keycode === 40) {
            this.rowindex++;
        }
        else if (keycode === 38) {
            this.rowindex--;
        }
        else if (keycode === 40 || keycode === 38) {
            this.rowindex = 0;
        }
        if (this.rowindex < 0) {
            this.rowindex = 0;
        }
        else if (this.rowindex >= this.viewdata.value.length) {
            this.rowindex = this.viewdata.value.length - 1;
        }
        if (keycode === 13) {
            const /** @type {?} */ data = this.dropdown[0].selectedItem();
            this.value = data[0].attributes['valuefield'].value;
            this.displayValue = data[0].attributes['displayfield'].value;
            this.itemClicked();
            this.isComponentValid.emit(true);
        }
        else if (keycode === 40 || keycode === 38) {
            this.dropdown[0].scroll(this.rowindex);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    blur(event) {
        super.blur(event);
        const /** @type {?} */ userinput = event.target.value;
        const /** @type {?} */ listitems = this.viewdata.value;
        listitems.forEach((item) => {
            if ((item[this.displayfield] + '').toLowerCase() === userinput.toLowerCase()) {
                this.displayValue = item[this.displayfield];
                this.value = item[this.valuefield];
                this.isComponentValid.emit(true);
            }
        });
        this.onBlur.emit(event);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onDropDownListItemClick(data) {
        if (this.valuefield) {
            this.value = data[this.valuefield];
        }
        else {
            this.value = data[this.displayfield];
        }
        this.displayValue = data[this.displayfield];
        this.onClick.emit(data);
    }
    /**
     * @param {?} v
     * @return {?}
     */
    writeValue(v) {
        super.writeValue(v);
        if (v && this.viewdata) {
            this.showValue();
        }
    }
    /**
     * @return {?}
     */
    showValue() {
        const /** @type {?} */ listitems = this.viewdata.value;
        listitems.forEach((item) => {
            if (item[this.valuefield] === this.value) {
                this.displayValue = item[this.displayfield];
                this.isComponentValid.emit(true);
            }
        });
    }
    /**
     * @return {?}
     */
    initComponent() {
        if (this.fieldlabel != null && this.fieldlabel.length > 0) {
            this.haslabel = true;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        if (event != null) {
            this.change.emit(event);
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewdata = of(responsedata);
        // SET USER SELECTION
        if (this.value != null) {
            const /** @type {?} */ valueKey = this.valuefield;
            const /** @type {?} */ displayKey = this.displayfield;
            const /** @type {?} */ val = this.value;
            this.viewdata.forEach((item) => {
                if (item[valueKey] === val) {
                    this.isValid = true;
                    this.displayValue = item[displayKey];
                }
            });
        }
        this.maskloader = false;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return ((!this.allowblank && this.value) || this.allowblank) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioTypeAheadComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-typeahead',
                template: `


    <div class="inputgroup form-group">

      <label *ngIf="haslabel" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
        {{fieldlabel}}
      </label>

      <input type="hidden" [(ngModel)]="value" [name]="name" #model="ngModel" required (ngModelChange)="onChange($event)">
  

      <div class="input-container">
              <input type="text" class="input-control"
                      [ngClass]="{'input-control-error': ((model.dirty || model.touched || (value && value.length>0)) && !model.valid),
                      'input-disabled' : disabled}"
                      [required]="!allowblank" 
                      [value]="displayValue"
                      [attr.placeholder]="placeholder"
                      [attr.disabled] = "disabled ? true: null"
                      (focus)="focus($event)"
                      (input)="input($event)"
                      (keyup)="keyup($event)"
                      (blur)="blur($event)"/>
              <em *ngIf="(iconfeedback && (model.dirty || model.touched) && model.valid)" class="fa fa-check"></em>
              <em *ngIf="(iconfeedback && (model.dirty || model.touched) && !model.valid)" class="fa fa-times icon-error"></em>
      </div>

      <input-help *ngIf="(enablepopover)" 
                      [error-msg]="errormsg" 
                      [min-msg]="minmsg" 
                      [max-msg]="maxmsg">
      </input-help>
  
      <dropdown-list-item class="dropdown" [ngStyle]="dropdownstyle"  
                          [data]="viewdata" [display-field]="displayfield" [value-field]="valuefield" 
                          [highlight-row]="rowindex" [display-value]="displayValue" 
                          (itemclick)="onDropDownListItemClick($event)">
      </dropdown-list-item>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: AmexioTypeAheadComponent,
                        multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef(() => AmexioTypeAheadComponent), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioTypeAheadComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
AmexioTypeAheadComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    data: [{ type: Input, args: ['data',] }],
    key: [{ type: Input, args: ['key',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    triggerchar: [{ type: Input, args: ['trigger-char',] }],
    name: [{ type: Input }],
    disabled: [{ type: Input }],
    onBlur: [{ type: Output }],
    onInputOutput: [{ type: Output, args: ['input',] }],
    onFocusOutput: [{ type: Output, args: ['focus',] }],
    change: [{ type: Output }],
    onClick: [{ type: Output }],
    isComponentValid: [{ type: Output }],
    model: [{ type: ViewChild, args: [NgModel,] }],
    dropdownlist: [{ type: ViewChildren, args: [DropDownListComponent,] }],
    bodyTemplate: [{ type: ContentChild, args: ['amexioBodyTmpl',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioInputHelperComponent {
    constructor() {
        this.help = [];
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set errormsg(v) {
        this._errormsg = v;
    }
    /**
     * @return {?}
     */
    get errormsg() {
        return this._errormsg;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set minmsg(v) {
        this._minmsg = v;
    }
    /**
     * @return {?}
     */
    get minmsg() {
        return this._minmsg;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set maxmsg(v) {
        this._maxmsg = v;
    }
    /**
     * @return {?}
     */
    get maxmsg() {
        return this._maxmsg;
    }
    /**
     * @return {?}
     */
    createHelpMsg() {
        if (this.errormsg && this.errormsg.length > 0) {
            this.help.push(this.errormsg);
        }
        if (this.errormsg && this.errormsg.length > 0) {
            this.help.push(this.errormsg);
        }
        if (this.errormsg && this.errormsg.length > 0) {
            this.help.push(this.errormsg);
        }
    }
}
AmexioInputHelperComponent.decorators = [
    { type: Component, args: [{
                selector: 'input-help',
                template: `
      <div class="input-helper">
          {{errormsg}} <br/>
          {{minmsg}} <br/>
          {{maxmsg}} <br/>
      </div>
    `,
                styles: [`
      .input-helper{background-color:#d3d3d3;display:block;z-index:1;overflow:auto;position:absolute;width:100%;max-height:200px;opacity:1;-webkit-box-shadow:0 1px 3px 0 #ced4da;box-shadow:0 1px 3px 0 #ced4da}
    `],
            },] },
];
/** @nocollapse */
AmexioInputHelperComponent.ctorParameters = () => [];
AmexioInputHelperComponent.propDecorators = {
    errormsg: [{ type: Input, args: ['error-msg',] }],
    minmsg: [{ type: Input, args: ['min-msg',] }],
    maxmsg: [{ type: Input, args: ['max-msg',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FilterPipe {
    /**
     * @param {?} items
     * @param {?} field
     * @param {?} value
     * @return {?}
     */
    transform(items, field, value) {
        if (!items) {
            return [];
        }
        if (!field || !value) {
            return items;
        }
        return items.filter((singleItem) => singleItem[field].toLowerCase().startsWith(value.toLowerCase()));
    }
}
FilterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'filterpipe',
            },] },
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const FORM_COMPONENTS = [
    AmexioTextInputComponent,
    AmexioCheckBoxComponent,
    AmexioDropDownComponent,
    AmexioTypeAheadComponent,
    AmexioInputHelperComponent,
    AmexioRadioGroupComponent,
    AmexioEmailInputComponent,
    AmexioNumberInputComponent,
    AmexioPasswordComponent,
    AmexioTextAreaComponent,
    AmexioToggleComponent,
    AmexioRatingComponent,
    AmexioButtonComponent,
    AmexioButtonGroupComponent,
    AmexioButtonDropdownComponent,
    AmexioSpiltButtonDropdownComponent,
    AmexioButtonDropDownItemComponent,
    AmexioCheckBoxGroupComponent,
    CheckboxComponent,
    AmexioFormIconComponent,
    AmexioSliderComponent,
    AmexioTagsInputComponent,
    AmexioDateTimePickerComponent,
    AmexioButtonDropDownItemComponent,
    AmexioButtonDropdownComponent,
    AmexioSpiltButtonDropdownComponent,
    AmexioFileUploadComponent,
    AmexioLabelComponent,
    AmexioFloatingButtonComponent,
    AmexioFloatingGroupButtonComponent,
    DropDownListComponent,
    AmexioDropDownitemsComponent,
    AmexioDropDownMenuComponent,
    ToolbarComponent,
    ToolbaroneComponent,
    ToolBarActionComponent,
    SearchboxtoolComponent,
    AmexioSearchAdvanceComponent,
    RecaptchaComponent,
    AmexioSpinnerComponent,
    AmexioCreditcardComponent,
    AmexioChipComponent,
    AmexioChipsComponent,
    FilterPipe,
];
class AmexioFormsModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioFormsModule,
            providers: [CommonDataService, IconLoaderService, LoadRecaptchaService],
        };
    }
}
AmexioFormsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AmexioLayoutModule,
                    HttpClientModule,
                ],
                exports: FORM_COMPONENTS,
                declarations: FORM_COMPONENTS,
                providers: [CommonDataService, IconLoaderService, DomHandler,
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const PANE_COMPONENTS = [
    AmexioHeaderComponent,
    AmexioFooterComponent,
    AmexioBodyComponent,
    AmexioFieldSetComponent,
    AmexioWindowPaneComponent,
    AmexioWindowHeaderComponent,
    AmexioStepsComponent,
    AmexioTabPillComponent,
    AmexioTabComponent,
    AmexioVerticalTabComponent,
    AmexioRightVerticalTabComponent,
    AmexioCarouselComponent,
    AmexioTemplateDirective,
    AmexioTemplateWrapperDirective,
    StepBlockComponent,
    AmexioPanelComponent,
    AmexioPanelHeaderComponent,
    AmexioIconPaneComponent,
    AmexiodialoguePaneComponent,
    AmexioFormComponent,
    AmexioFormActionComponent,
    AmexioFormHeaderComponent,
    AmexioFormBodyComponent,
    AmexioFormGroupDirective,
    AmexioTabActionComponent,
    AmexiotimelineComponent,
    AmexiotimelineeventComponent,
];
class AmexioPaneModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioPaneModule,
            providers: [CommonDataService, DeviceQueryService, IconLoaderService],
        };
    }
}
AmexioPaneModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AmexioFormsModule,
                    HttpClientModule,
                ],
                entryComponents: [AmexioTabPillComponent],
                exports: PANE_COMPONENTS,
                declarations: PANE_COMPONENTS,
                providers: [CommonDataService, DeviceQueryService, IconLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DATA_COMPONENTS = [
    AmexioTreeViewComponent,
    AmexioListBoxComponent,
    AmexioDatagridComponent,
    AmexioDataGridHeaderComponent,
    DataGridFilterComponent,
    AmexioPaginatorComponent,
    AmexioGridColumnComponent,
    AmexioProgressMultiBarComponent,
    AmexioProgressBarComponent,
    HorizontalTreeViewNodeComponent,
    HorizontalTreeViewComponent,
    AmexioFilterTreeComponent,
    TreeDataTableComponent,
    AmexioDataIconComponent,
    AmexioItemSelectorComponent,
];
class AmexioDataModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioDataModule,
            providers: [CommonDataService, IconLoaderService],
        };
    }
}
AmexioDataModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AmexioPaneModule,
                    AmexioLayoutModule,
                    HttpClientModule,
                ],
                exports: DATA_COMPONENTS,
                declarations: DATA_COMPONENTS,
                providers: [CommonDataService, IconLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioVideoPlayerComponent {
    constructor() {
        this.currentVolume = 1;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onVolumeChange(event) {
        this.videoPlayer.nativeElement.volume = this.currentVolume = event.target.value;
    }
    /**
     * @return {?}
     */
    updateMuteUI() {
        if (this.videoPlayer.nativeElement.muted) {
            this.isMuted = true;
        }
        else {
            this.isMuted = false;
        }
    }
    /**
     * @return {?}
     */
    onPlay() {
        if (!this.isPlaying) {
            this.videoPlayer.nativeElement.play();
            this.isPlaying = true;
        }
        else {
            this.videoPlayer.nativeElement.pause();
            this.isPlaying = false;
        }
    }
    /**
     * @return {?}
     */
    onTimeUpdate() {
        const /** @type {?} */ percentage = Math.floor((100 / this.videoPlayer.nativeElement.duration) * this.videoPlayer.nativeElement.currentTime);
        this.progressBar.nativeElement.value = percentage;
        // Update the progress bar's text (for browsers that don't support the progress element)
        this.progressBar.nativeElement.innerHTML = percentage + '% played';
        if (percentage === 100) {
            this.isPlaying = false;
        }
    }
    /**
     * @return {?}
     */
    replayVideo() {
        this.resetPlayer();
        this.onPlay();
    }
    /**
     * @return {?}
     */
    resetPlayer() {
        this.videoPlayer.nativeElement.pause();
        this.progressBar.nativeElement.value = 0;
        this.videoPlayer.nativeElement.currentTime = 0;
        this.isPlaying = false;
    }
    /**
     * @return {?}
     */
    onFullScreen() {
        const /** @type {?} */ elem = this.videoPlayer.nativeElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        }
        else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
        }
        else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        }
    }
    /**
     * @return {?}
     */
    onMute() {
        if (!this.isMuted) {
            this.videoPlayer.nativeElement.muted = true;
            this.isMuted = true;
            this.volumebar.nativeElement.value = 0;
        }
        else {
            this.videoPlayer.nativeElement.muted = false;
            this.isMuted = false;
            this.volumebar.nativeElement.value = this.currentVolume;
        }
    }
}
AmexioVideoPlayerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-video-player',
                template: `

      <video [style.width.px]="width" controls>
          <source [attr.src]="path">
          Your browser does not support HTML5 video.
      </video>
  `,
                styles: [`
    video{border:1px solid #4682b4;width:420px;height:231px;background:#000}progress{color:#4682b4;font-size:12px;width:220px;height:16px;border:none;margin-right:10px;background:#434343;border-radius:9px;vertical-align:middle}progress::-moz-progress-bar{color:#4682b4;background:#434343}progress[value]::-webkit-progress-bar{background-color:#434343;border-radius:2px;-webkit-box-shadow:0 2px 5px rgba(0,0,0,.25) inset;box-shadow:inset 0 2px 5px rgba(0,0,0,.25)}progress[value]::-webkit-progress-value{background-color:#4682b4}@media screen and (max-width:600px){video{border:1px solid #4682b4;width:98%;height:231px;background:#000}}
  `],
            },] },
];
/** @nocollapse */
AmexioVideoPlayerComponent.ctorParameters = () => [];
AmexioVideoPlayerComponent.propDecorators = {
    path: [{ type: Input }],
    extension: [{ type: Input }],
    width: [{ type: Input }],
    videoPlayer: [{ type: ViewChild, args: ['videoRef',] }],
    progressBar: [{ type: ViewChild, args: ['progressbar',] }],
    volumebar: [{ type: ViewChild, args: ['volumebar',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MEDIA_COMPONENTS = [
    AmexioVideoPlayerComponent,
    AmexioImageComponent,
];
class AmexioMediaModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioMediaModule,
            providers: [CommonDataService, DeviceQueryService],
        };
    }
}
AmexioMediaModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                ],
                exports: MEDIA_COMPONENTS,
                declarations: MEDIA_COMPONENTS,
                providers: [CommonDataService, DeviceQueryService, IconLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by kedarkokil on 26/09/18.
 */
class AmexioBreadcrumbComponent {
    /**
     * @param {?} element
     * @param {?} dataService
     */
    constructor(element, dataService) {
        this.element = element;
        this.dataService = dataService;
        /*
           Events
           name : onListItemClick
           datatype : any
           version : none
           default :
           description : On click event
           */
        this.onListItemClick = new EventEmitter();
        /*
           Events
           name : onClick
           datatype : any
           version : none
           default :
           description : On click event
           */
        this.onClick = new EventEmitter();
        this.buttonAngleRightCss = 'button_angle-right';
        this.displaykey = 'text';
        this.childarraykey = 'children';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.arrowKey = this.buttonAngleRightCss;
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.responseData = response;
            }, (error) => {
            }, () => {
                this.setData(this.responseData);
            });
        }
        else if (this.data) {
            this.setData(this.data);
        }
    }
    /**
     * @param {?} nodeArray
     * @return {?}
     */
    iconAddedMethod(nodeArray) {
        if (nodeArray && nodeArray.length > 0) {
            nodeArray.forEach((node) => {
                if (node[this.childarraykey]) {
                    node[this.childarraykey].forEach((element) => {
                        this.childIconCheckMethod(element);
                    });
                }
            });
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    childIconCheckMethod(element) {
        if (element.hasOwnProperty([this.childarraykey])) {
            element[this.childarraykey].forEach((childIcon) => {
                if (childIcon.icon == null || childIcon.icon === '') {
                    childIcon.icon = 'fa fa-file-o';
                }
            });
            if (element.icon == null || element.icon === '') {
                element.icon = 'fa fa-folder-o';
            }
            this.iconAddedMethod(element);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getSelectedItem(event) {
        const /** @type {?} */ arrayOnly = [event.data];
        this.childItem = arrayOnly;
        event.parentRef.show = true;
        event.parentRef.expand = false;
        this.arrowKey = this.buttonAngleRightCss;
        this.onListItemClick.emit(event.data);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getEventEmitClick(event) {
        this.onListItemClick.emit(event);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onArrowClick(item) {
        item.expand = !item.expand;
        if (item.expand) {
            this.arrowKey = 'button_angle-down';
        }
        else {
            this.arrowKey = this.buttonAngleRightCss;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onButtonClick(event) {
        event.show = false;
        event.expand = false;
        this.onClick.emit(event);
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        let /** @type {?} */ responsedata = httpResponse;
        // Check if key is added?
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.iconAddedMethod(this.data);
    }
    /**
     * @param {?} targetElement
     * @return {?}
     */
    onElementOutClick(targetElement) {
        let /** @type {?} */ parentFound = false;
        while (targetElement !== null && !parentFound) {
            if (targetElement === this.element.nativeElement) {
                parentFound = true;
            }
            targetElement = targetElement.parentElement;
        }
        if (!parentFound) {
            let /** @type {?} */ expandData;
            this.data.forEach((dataObject) => {
                if (dataObject) {
                    expandData = dataObject;
                }
                if (expandData && expandData.expand != null) {
                    expandData.expand = false;
                }
            });
        }
    }
}
AmexioBreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-breadcrumb', template: `
    <ng-container *ngIf="data ">

        <div *ngFor="let nodeObject of data">

            <div class="breadcrum-rightshift-css">
                <div class="breadcrumb-group">
                    <label (click)="onButtonClick(nodeObject)" class="label-icon-css">
                        <ng-container *ngIf="nodeObject && nodeObject.icon">
                            <span [ngClass]="nodeObject.icon"></span>
                        </ng-container>&nbsp;
                        <span>{{nodeObject[displaykey]}} &nbsp;&nbsp;</span>
                    </label>
                    <ng-container *ngIf="nodeObject[childarraykey]">
                        <amexio-form-icon (click)="onArrowClick(nodeObject)" class="arrow-group-css" [key]="arrowKey"></amexio-form-icon>
                    </ng-container>


                    <div class="context-menu-list1" *ngIf="nodeObject.expand">
                        <ng-container *ngFor="let node of nodeObject[childarraykey]">
                            <div class="context-menu-list-items1" [ngStyle]="{'cursor': node.disabled ? 'not-allowed':'pointer'}"
                                (click)="getSelectedItem({data:node,parentRef:nodeObject})">
                                <div class="dropdown-icon-css"> 
                                    <ng-container *ngIf="node.icon">
                                        <amexio-form-icon [ngClass]="node.icon"></amexio-form-icon>
                                    </ng-container>&nbsp;
                                </div>
                                <div class="dropdown-label-css">
                                    <span>{{node[displaykey]}}&nbsp;</span>
                                </div>
                            </div>
                        </ng-container>
                    </div>




                </div>

                <ng-container *ngIf="nodeObject.show">
                    <amexio-breadcrumb [data]="childItem" [display-key]="displaykey" [childarray-key]="childarraykey"
                        (onListItemClick)="getEventEmitClick($event)" (onClick)="onButtonClick($event)">
                    </amexio-breadcrumb>
                </ng-container>
            </div>
        </div>

    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioBreadcrumbComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: CommonDataService }
];
AmexioBreadcrumbComponent.propDecorators = {
    data: [{ type: Input }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    displaykey: [{ type: Input, args: ['display-key',] }],
    childarraykey: [{ type: Input, args: ['childarray-key',] }],
    onListItemClick: [{ type: Output }],
    onClick: [{ type: Output }],
    onElementOutClick: [{ type: HostListener, args: ['document:click', ['$event.target'],] }, { type: HostListener, args: ['document: touchstart', ['$event.target'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by sagar on 6/9/17.
 */
class DockbarComponent {
    constructor() {
        this.elementId = 'dockbar-item-id' + Math.floor(Math.random() * 90000) + 10000;
    }
    /**
     * @return {?}
     */
    onBarIconClick() {
        this.active = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DockbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dockbar-item', template: `
    <div *ngIf="active"  [style.width]="width"
    class="dockbar-active-content dockbar-height"
    [style.min-height]="height"  [style.max-height]="height">
      <ng-container *ngIf="active && title">
        <div class="dockbar-title">
          {{title}}
          <span class="dockbar-item-close-bar" (click)="onBarIconClick()">
            <amexio-nav-icon key="dockbar_close"></amexio-nav-icon>
            <!--
                        <i class="fa fa-times" aria-hidden="true"></i>
            -->
          </span>
        </div>
      </ng-container>
      <ng-content>
      </ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
DockbarComponent.ctorParameters = () => [];
DockbarComponent.propDecorators = {
    active: [{ type: Input }],
    label: [{ type: Input }],
    icon: [{ type: Input }],
    mda: [{ type: Input }],
    width: [{ type: Input }],
    title: [{ type: Input }],
    path: [{ type: Input }],
    height: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Created by Ketan Gote on 8/21/17.
 */
class DockedBarToolComponent {
    constructor() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        const /** @type {?} */ tabs = this.dockbarArray;
        tabs.forEach((tab) => {
            tab.active = false;
            if (tab.elementId === event.elementId) {
                tab.active = true;
            }
        });
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.dockbarArray = this.dockbars.toArray();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DockedBarToolComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dockbar', template: `
    <div class="dockbar" [style.min-height]="height">
      <ng-container *ngFor="let dockbar of dockbarArray">
        <button [ngClass]="{'active':dockbar.active}" (click)="onClick(dockbar)">

          <!--Normal image-->
          <ng-container *ngIf="dockbar.path">
            <img [src]="dockbar.path">
          </ng-container>

          <!--this is for fontawesome-->
          <ng-container *ngIf="(!(dockbar.icon && dockbar.mda) && dockbar.icon)">
            <amexio-image [icon-class]="dockbar.icon" [c-class]=""></amexio-image>
            <!--<i [ngClass]="dockbar.icon"></i>-->
          </ng-container>

          <!--if dockbar have label instead of icon -->
          <ng-container *ngIf="dockbar.label && dockbar.active">
            <p><strong class="dockbar-label-highlight">{{dockbar.label}}</strong></p>
          </ng-container>

          <ng-container *ngIf="dockbar.label && !dockbar.active">
            <p>{{dockbar.label}}</p>
          </ng-container>

        </button>
      </ng-container>
    </div>
    <div class="dockbar-content" [style.min-height]="height">
      <ng-content></ng-content>
    </div>

  `,
            },] },
];
/** @nocollapse */
DockedBarToolComponent.ctorParameters = () => [];
DockedBarToolComponent.propDecorators = {
    dockbars: [{ type: ContentChildren, args: [DockbarComponent,] }],
    height: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 21/12/17.
 */
class AmexioNavIconPaneComponent {
    /**
     * @param {?} iconLoaderService
     */
    constructor(iconLoaderService) {
        this.iconLoaderService = iconLoaderService;
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.iconClass = this.getIconClass();
    }
    /**
     * @return {?}
     */
    getIconClass() {
        if (this.iconLoaderService.iconMappings != null) {
            const /** @type {?} */ iconObject = this.iconLoaderService.iconMappings.find((obj) => obj.component === this.key);
            if (iconObject != null) {
                return iconObject[this.iconLoaderService.iconToUse.toString()];
            }
            else {
                return '';
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['key']) {
            this.key = changes["key"].currentValue;
            this.iconClass = this.getIconClass();
        }
    }
}
AmexioNavIconPaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav-icon', template: `
    <ng-container *ngIf="iconLoaderService.iconToUse == 'fa'">

      <ng-container *ngIf="customclass != null">
        <i class="{{customclass}}" aria-hidden="true" (click)="onClick.emit($event)"></i>
      </ng-container>
      <ng-container *ngIf="customclass == null">
        <i class="{{iconClass}}" aria-hidden="true" (click)="onClick.emit($event)"></i>
      </ng-container>

    </ng-container>

    <ng-container *ngIf="iconLoaderService.iconToUse == 'mat'">

      <ng-container *ngIf="customclass != null">
        <i class="material-icons" (click)="onClick.emit($event)">{{customclass}}</i>
      </ng-container>

      <ng-container *ngIf="customclass == null">
        <i class="material-icons" (click)="onClick.emit($event)">{{iconClass}}</i>
      </ng-container>


    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioNavIconPaneComponent.ctorParameters = () => [
    { type: IconLoaderService }
];
AmexioNavIconPaneComponent.propDecorators = {
    key: [{ type: Input }],
    customclass: [{ type: Input }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/8/17.
 */
class AmexioMenuBarComponent {
    /**
     * @param {?} matchMediaService
     * @param {?} dataService
     */
    constructor(matchMediaService, dataService) {
        this.matchMediaService = matchMediaService;
        this.dataService = dataService;
        /*
        Events
        name : nodeClick
        datatype : any
        version : none
        default : none
        description : Fire when menubar bar click.
        */
        this.nodeClick = new EventEmitter();
        this.xposition = false;
        this.expand = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.responseData = response;
            }, (error) => {
            }, () => {
                this.setData(this.responseData);
            });
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onClick(node) {
        if (this.matchMediaService.IsPhone() || this.matchMediaService.IsTablet()) {
            for (const /** @type {?} */ i of 'length') {
                if (this.data[i] === node) {
                    this.data[i].expand = !this.data[i].expand;
                }
                else {
                    this.data[i].expand = false;
                }
            }
        }
        this.nodeClick.emit(node);
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        // Check if key is added?
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            
        }
        this.data = httpResponse;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseOver(event) {
        if (!(this.matchMediaService.IsPhone() || this.matchMediaService.IsTablet())) {
            if ((this.matchMediaService.browserWindow().innerWidth - event.clientX) < 200) {
                this.xposition = true;
            }
            else {
                this.xposition = false;
            }
        }
        else {
            this.xposition = false;
        }
    }
}
AmexioMenuBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-menu',
                template: `
    <div class="menu-container">
      <div class="menubar">
        <ul class="menuheader">
          <li class="menulink">{{label}}</li>
          <div>
            <li *ngFor="let node of data" class="menulink">
              <a (click)="onClick(node)"  (mouseover)="onMouseOver($event)">
                <amexio-nav-icon *ngIf="node.icon" [customclass]="node.icon"></amexio-nav-icon>&nbsp;&nbsp;{{node.text}}</a>
              <!--<i *ngIf="node.icon" [ngClass]="node.icon" aria-hidden="true"></i>-->
              <ng-container *ngIf="(node.children && node.children[0].children)">

                <div *ngIf="(node.children && node.children.length>0)" class="menu-content"
                     [ngClass]="{'menu-content-display':node.expand,
                     ' menu-content-left': (node.children && node.children.length>3),'menu-right':xposition}">
                  <ul class="menu-content-cols">

                    <li class="col-menu-nodes"
                        [ngClass]="{'col-menu-nodes-fixed': (node.children && node.children.length<4),
                      'col-menu-nodes-percentage': (node.children && node.children.length>3)}"
                        *ngFor="let subnode of node.children">
                      <div class="content">
                        <div *ngIf="(subnode.text && subnode.text.length>0)" class="menu-links-header">
                          <amexio-nav-icon *ngIf="subnode.icon" [customclass]="subnode.icon"></amexio-nav-icon>&nbsp;&nbsp;{{subnode.text}}
                          <!--<i *ngIf="subnode.icon" [ngClass]="subnode.icon" aria-hidden="true"></i>-->
                        </div>
                        <div *ngIf="subnode.image" style="padding: 10px;">
                          <img [attr.src]="subnode.image">
                        </div>
                        <ul class="menu-content-cols">
                          <li *ngFor="let subinnernode of subnode.children" class="menulinks">
                            <div *ngIf="subinnernode.image" style="padding: 10px;">
                              <img [attr.src]="subinnernode.image">
                            </div>
                            <!--<i *ngIf="subinnernode.icon" class="fa fa-ravelry"
                            aria-hidden="true"></i>-->
                            <amexio-nav-icon *ngIf="subinnernode.icon" key="menubar_ravelry">
                            </amexio-nav-icon>
                            &nbsp;&nbsp;{{subinnernode.text}}{{subinnernode.template}}
                          </li>
                        </ul>
                      </div>
                    </li>

                  </ul>
                </div>

              </ng-container>


              <ng-container *ngIf="(node.children && !node.children[0].children)">
                <div class="menu-content" [ngClass]="{'menu-content-display':node.expand}">
                  <ul class="menu-content-cols">
                    <li class="col-menu-nodes col-menu-nodes-fixed">
                      <div class="content">
                        <ul class="menu-content-cols">
                          <li *ngFor="let subnode of node.children" class="menulinks">
                            <div *ngIf="subnode.image" style="padding: 10px;">
                              <img [attr.src]="subnode.image">
                            </div>
                            <!--<i *ngIf="subnode.icon" class="fa fa-ravelry" aria-hidden="true"></i>-->
                            <amexio-nav-icon *ngIf="subnode.icon"
                                             key="menubar_ravelry"></amexio-nav-icon>&nbsp;&nbsp;{{subnode.text}}
                          </li>
                        </ul>
                      </div>
                    </li>
                  </ul>
                </div>
              </ng-container>


            </li>
          </div>

        </ul>
      </div>
    </div>

  `, providers: [CommonDataService],
            },] },
];
/** @nocollapse */
AmexioMenuBarComponent.ctorParameters = () => [
    { type: DeviceQueryService },
    { type: CommonDataService }
];
AmexioMenuBarComponent.propDecorators = {
    data: [{ type: Input }],
    label: [{ type: Input }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    nodeClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 1/4/18.
 */
class AmexioNavActionComponent {
    constructor() {
        /*
        Events
        name : navLinkClick
        datatype : any
        version : none
        default : none
        description : Fire when nav item is clicked, This event is fired when nav item type is defined as 'link/button/menu'
        
        */
        this.navLinkClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        const /** @type {?} */ node = {};
        this.navLinkClick.emit({ node, event });
    }
}
AmexioNavActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav-action',
                template: `
    <a *ngIf="(type=='link')" class="top-nav-link" (click)="onClick($event)"><i *ngIf="icon" [ngClass]="icon"></i>{{title}}</a>

    <button *ngIf="(type=='button')" class="top-nav-button" (click)="onClick($event)">
    <i *ngIf="icon" [ngClass]="icon"></i>{{title}}</button>
  `,
            },] },
];
/** @nocollapse */
AmexioNavActionComponent.ctorParameters = () => [];
AmexioNavActionComponent.propDecorators = {
    type: [{ type: Input }],
    title: [{ type: Input }],
    icon: [{ type: Input }],
    navLinkClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 1/4/18.
 */
const noop$9 = () => {
};
class AmexioNavItemComponent {
    /**
     * @param {?} elementref
     */
    constructor(elementref) {
        this.elementref = elementref;
        /*
        Events
        name : onNavItemClick
        datatype : any
        version : none
        default : none
        description : Fire when nav item is clicked, This event is fired when nav item type is defined as 'link/button/menu'
        
        */
        this.onNavItemClick = new EventEmitter();
        this.mobilemode = false;
        this.isAction = false;
        this.isTextField = false;
        this.isMenu = false;
        this.isMenuContainer = false;
        this.innerValue = '';
        this.onTouchedCallback = noop$9;
        this.onChangeCallback = noop$9;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.type === 'link' || this.type === 'button') {
            this.isAction = true;
        }
        else if (this.type === 'textfield') {
            this.isTextField = true;
        }
        else if (this.type === 'menu') {
            this.isMenu = true;
        }
        else if (this.type === 'menucontainer') {
            this.isMenuContainer = true;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.right = this.elementref.nativeElement.getBoundingClientRect().right;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navItemClick(event) {
        this.onNavItemClick.emit(event);
    }
    /**
     * @param {?} flag
     * @return {?}
     */
    setMobileMode(flag) {
        this.mobilemode = flag;
    }
    /**
     * @param {?} navbarwidth
     * @return {?}
     */
    setNavbarWidth(navbarwidth) {
        this.navbarwidth = navbarwidth;
        if ((this.navbarwidth - this.elementref.nativeElement.getBoundingClientRect().left) < 165) {
            this.enablerightclass = true;
        }
    }
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
}
AmexioNavItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav-item',
                template: `

    <div class="topnavmainbarinneritems"  
    [ngClass]="{'topnavmainbarinneritems-mobile':mobilemode,
     'nav-dropdown-content-right':enablerightclass}" >
        <amexio-nav-action *ngIf="isAction" [type]="type" [title]="title" [icon]="icon" (navLinkClick)="navItemClick($event)"></amexio-nav-action>
        <amexio-nav-textfield *ngIf="isTextField" [(ngModel)]="value"  [title]="title"></amexio-nav-textfield>
        <amexio-nav-menu *ngIf="isMenu" [title]="title" [icon]="icon" [data]="data"  (navLinkClick)="navItemClick($event)">
        </amexio-nav-menu>
        <amexio-nav-menu *ngIf="isMenuContainer" [title]="title" [icon]="icon" [type]="type" (navLinkClick)="navItemClick($event)">
            <ng-content></ng-content>
        </amexio-nav-menu>
    </div>
  `,
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioNavItemComponent), multi: true,
                    }],
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
AmexioNavItemComponent.ctorParameters = () => [
    { type: ElementRef }
];
AmexioNavItemComponent.propDecorators = {
    type: [{ type: Input }],
    title: [{ type: Input }],
    icon: [{ type: Input }],
    data: [{ type: Input }],
    onNavItemClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/8/17.
 */
class AmexioNavBarComponent {
    /**
     * @param {?} matchMediaService
     */
    constructor(matchMediaService) {
        this.matchMediaService = matchMediaService;
        /*
        Properties
        name : enable-side-nav-position
        datatype : boolean
        version : 4.0 onwards
        default : none
        description : Indicate if side-nav-bar is present
        */
        this.sidenavspace = false;
        this.onNavLogoClick = new EventEmitter();
        this.onNavTitleClick = new EventEmitter();
        this.toggle = true;
        this.mobilemode = false;
        this.sidenav = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.logo) {
            this.loadNavItems();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
    }
    /**
     * @return {?}
     */
    onImageLoad() {
        this.loadNavItems();
    }
    /**
     * @return {?}
     */
    loadNavItems() {
        this.handleNavItems();
        this.navitemwidth = (5 +
            (this.navbaritems2.nativeElement.offsetWidth) +
            (this.navbaritems2.nativeElement.offsetWidth) +
            (this.navbaritems3.nativeElement.offsetWidth));
        this.handleDeviceSetting();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggleDrawerPanel(event) {
        this.toggle = !this.toggle;
    }
    /**
     * @return {?}
     */
    handleNavItems() {
        this.navItemComponents = this.navitems.toArray();
        this.navItemComponents.forEach((node) => node.onNavItemClick.subscribe((eventdata) => this.handleNavItemEvent(eventdata)));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleNavItemEvent(event) {
        if (event && event.data && event.data.node && !event.data.node.header && this.mobilemode) {
            this.toggle = false;
        }
    }
    /**
     * @param {?} navbarwidth
     * @return {?}
     */
    notifyNavItems(navbarwidth) {
        this.navItemComponents.forEach((node) => {
            node.setMobileMode(this.mobilemode);
            node.setNavbarWidth(navbarwidth);
        });
    }
    /**
     * @return {?}
     */
    handleDeviceSetting() {
        if (this.sidenavspace) {
            this.sideNavbar();
        }
        const /** @type {?} */ navbarwidth = this.navbar.nativeElement.offsetWidth;
        const /** @type {?} */ navbarheight = this.navbar.nativeElement.offsetHeight;
        if (!this.navfixeditem) {
            this.navfixeditem = this.navbarfixed.nativeElement.offsetWidth;
        }
        if (!this.navitemwidth) {
            let /** @type {?} */ navbaritems1Width = 0;
            let /** @type {?} */ navbaritems2Width = 0;
            let /** @type {?} */ navbaritems3Width = 0;
            if (this.navbaritems1) {
                navbaritems1Width = this.navbaritems1.nativeElement.offsetWidth;
            }
            if (this.navbaritems2) {
                navbaritems2Width = this.navbaritems2.nativeElement.offsetWidth;
            }
            if (this.navbaritems3) {
                navbaritems3Width = this.navbaritems3.nativeElement.offsetWidth;
            }
            this.navitemwidth = (this.navfixeditem + navbaritems1Width + navbaritems2Width + navbaritems3Width);
        }
        const /** @type {?} */ navbaravailablewidth = (navbarwidth - (this.navfixeditem + this.navitemwidth));
        if ((navbaravailablewidth < 100 || navbarheight > 100)) {
            this.mobilemode = true;
            this.toggle = false;
            this.notifyNavItems(navbarwidth);
        }
        else {
            this.mobilemode = false;
            this.toggle = true;
            this.notifyNavItems(navbarwidth);
        }
    }
    /**
     * @return {?}
     */
    sideNavbar() {
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.sidenav = true;
        }
        else {
            this.sidenav = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    resize(event) {
        this.handleDeviceSetting();
    }
}
AmexioNavBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav', template: `

    <nav #navbar class="topnav" [ngClass]="{'topnav-mobile':mobilemode}" (window:resize)="resize($event)">
        <div #navbarfixed class="topnavbarunit1" [ngClass]="{'topnavbarunit1-mobile':mobilemode}" >
            <div class="float-left"  [ngStyle]="{'padding-left':sidenav ? '40px':'0px'}">
                <img alt="title" style="cursor: pointer" (click)="onNavLogoClick.emit($event)"  (load)="onImageLoad()" *ngIf="logo" [attr.src]="logo" class="navbar-logo">
                <amexio-label (onClick)="onNavTitleClick.emit($event)" [enable-click]="true"  size="medium-bold">{{title}}</amexio-label>
            </div>
            <div *ngIf="mobilemode" class="float-right mobilebar" (click)="toggleDrawerPanel($event)">
                <em *ngIf="!toggle"  class="fa fa-caret-down fa-2x"></em>
                <em *ngIf="toggle"  class="fa fa-caret-up fa-2x"></em>
            </div>
        </div>
        <div #navbaritems *ngIf="toggle" class="topnavbarunit2"  [ngClass]="{'topnavbarunit2-mobile':mobilemode}" >
            <div class="topnavmainbar"    [ngClass]="{'topnavmainbar-mobile':mobilemode}" >
                <div #navbaritems1 class="topnavmainbaritems" [ngClass]="{'topnavmainbaritems-mobile':mobilemode}" >
                    <ng-content select="[position-left]"></ng-content>
                </div>
                <div #navbaritems2 class="topnavmainbaritems"  [ngClass]="{'topnavmainbaritems-mobile':mobilemode}" >
                    <ng-content select="[position-center]"></ng-content>
                </div>
                <div #navbaritems3 class="topnavmainbaritems"   [ngClass]="{'topnavmainbaritems-mobile':mobilemode}" >
                  <ng-content select="[position-right]"></ng-content>
                </div>

              </div>
        </div>

      </nav>
  `,
            },] },
];
/** @nocollapse */
AmexioNavBarComponent.ctorParameters = () => [
    { type: DeviceQueryService }
];
AmexioNavBarComponent.propDecorators = {
    title: [{ type: Input }],
    logo: [{ type: Input }],
    sidenavspace: [{ type: Input, args: ['enable-side-nav-position',] }],
    onNavLogoClick: [{ type: Output }],
    onNavTitleClick: [{ type: Output }],
    navitems: [{ type: ContentChildren, args: [AmexioNavItemComponent,] }],
    navbar: [{ type: ViewChild, args: ['navbar', { read: ElementRef },] }],
    navbarfixed: [{ type: ViewChild, args: ['navbarfixed', { read: ElementRef },] }],
    navbaritems: [{ type: ViewChild, args: ['navbaritems', { read: ElementRef },] }],
    navbaritems1: [{ type: ViewChild, args: ['navbaritems1', { read: ElementRef },] }],
    navbaritems2: [{ type: ViewChild, args: ['navbaritems2', { read: ElementRef },] }],
    navbaritems3: [{ type: ViewChild, args: ['navbaritems3', { read: ElementRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 1/4/18.
 */
class AmexioNavMenuComponent {
    constructor() {
        /*
        Events
        name : navLinkClick
        datatype : any
        version : none
        default : none
        description : Fire when nav item is clicked, This event is fired when nav item type is defined as 'link/button/menu'
        
        */
        this.navLinkClick = new EventEmitter();
        this.mobilemode = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} flag
     * @return {?}
     */
    setMobileMode(flag) {
        this.mobilemode = flag;
    }
    /**
     * @param {?} _node
     * @param {?} _event
     * @return {?}
     */
    onClick(_node, _event) {
        const /** @type {?} */ n = {
            title: this.title,
            data: this.data,
            icon: this.icon,
            node: _node,
            mobilemode: this.mobilemode,
        };
        this.navLinkClick.emit(this.dataObject(n, _event));
    }
    /**
     * @param {?} n
     * @param {?} _event
     * @return {?}
     */
    dataObject(n, _event) {
        return { data: n, event: _event };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onHeaderClick(event) {
        const /** @type {?} */ node = {
            header: true,
            title: this.title,
            icon: this.icon,
        };
        this.onClick(node, event);
    }
}
AmexioNavMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav-menu',
                template: `
  <div class="nav-dropdown">
    <a class="nav-dropbtn"  (click)="onHeaderClick($event)">
      <i *ngIf="icon" [ngClass]="icon"></i>{{title}}<i class="dropdownicon fa fa-angle-down"></i>
    </a>
    <div class="nav-dropdown-content">
      <a *ngFor="let node of data" (click)="onClick(node, $event)">
      <i *ngIf="icon" [ngClass]="node.icon"></i>&nbsp;{{node.text}}</a>

      <div *ngIf="type==='menucontainer'" class="nav-menu-container" >
      <a *ngFor="let node of data" (click)="onClick(node, $event)">
      <i *ngIf="icon" [ngClass]="node.icon"></i>&nbsp;{{node.text}}</a>
      <ng-content ></ng-content>
      </div>
    </div>
  </div>



  `,
            },] },
];
/** @nocollapse */
AmexioNavMenuComponent.ctorParameters = () => [];
AmexioNavMenuComponent.propDecorators = {
    type: [{ type: Input }],
    title: [{ type: Input }],
    data: [{ type: Input }],
    icon: [{ type: Input }],
    navLinkClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const noop$10 = () => {
};
class AmexioNavTextFieldComponent {
    constructor() {
        this.innerValue = '';
        this.onTouchedCallback = noop$10;
        this.onChangeCallback = noop$10;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
}
AmexioNavTextFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav-textfield',
                template: `
  <input type="text" class="top-nav-input-control" [(ngModel)]="value"/>

  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AmexioNavTextFieldComponent), multi: true,
                    }],
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
AmexioNavTextFieldComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const KEY_CODE_notify = {
    esc: 27,
};
KEY_CODE_notify[KEY_CODE_notify.esc] = "esc";
class AmexioNotificationComponent {
    /**
     * @param {?} ref
     */
    constructor(ref) {
        this.ref = ref;
        /*
        Properties
        name : closable
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : User can close the window.
        */
        this.closable = true;
        this.notificationVertialCss = 'notification-vertical-';
        this.notificationHorizontalCss = ' notification-horizontal-';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    keyEvent(event) {
        if (this.closeonescape === true) {
            this.messageData.length = 0;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.autodismissmsg) {
            if (!this.autodismissmsginterval) {
                this.autodismissmsginterval = 1500;
            }
            if (this.messageData !== null) {
                setInterval(() => {
                    this.messageData.shift();
                    this.ref.markForCheck();
                }, this.autodismissmsginterval);
            }
        }
        if (this.verticalposition === null) {
            this.verticalposition = 'top';
        }
        else if (this.horizontalposition === null) {
            this.horizontalposition = 'right';
        }
        this.positionclass = this.notificationVertialCss + this.verticalposition + this.notificationHorizontalCss + this.horizontalposition;
    }
    /**
     * @param {?} msg
     * @return {?}
     */
    closeNotification(msg) {
        const /** @type {?} */ count = this.messageData.length;
        for (let /** @type {?} */ i = 0; i < count; i++) {
            if (this.messageData[i] === msg) {
                this.messageData.splice(msg, 1);
            }
        }
    }
}
AmexioNotificationComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-notification', template: `
    <div class="notification-content" [ngClass]="positionclass">

      <ng-container *ngIf="!notificationTemplate">
        <div class="notification" *ngFor="let msg of messageData" [style.color]="foregroundColor" [style.background-color]="backgroundColor">
          <span class="float-right" (click)="closeNotification(msg)">
            <ng-container *ngIf="closable">
              <amexio-nav-icon key="notify_close"></amexio-nav-icon>
            </ng-container>
          </span>

          <table>
            <ng-container *ngIf="icon">
              <th>
                <amexio-nav-icon style=" padding-right: 18px;" [ngClass]="icon">
                </amexio-nav-icon>
              </th>
            </ng-container>

            <th style=" text-align: left;">

              <span>{{msg}}</span>&nbsp;&nbsp;&nbsp;&nbsp;
            </th>

          </table>

        </div>
      </ng-container>

      <ng-container *ngIf="notificationTemplate">
        <div class="notification" *ngFor="let msg of messageData" [style.color]="foregroundColor" [style.background-color]="backgroundColor">

          <span class="float-right" (click)="closeNotification(msg)">
            <ng-container *ngIf="closable">
              <amexio-nav-icon key="notify_close"></amexio-nav-icon>
            </ng-container>
          </span>

          <table>
            <ng-container *ngIf="icon">
              <th>
                <amexio-nav-icon style=" padding-right: 18px;" [ngClass]="icon">
                </amexio-nav-icon>
              </th>
            </ng-container>
            <th style=" text-align: left;">
              <ng-template [ngTemplateOutlet]="notificationTemplate" [ngTemplateOutletContext]="{data:msg}">
              </ng-template>
            </th>
          </table>
        </div>
      </ng-container>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioNotificationComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
AmexioNotificationComponent.propDecorators = {
    messageData: [{ type: Input, args: ['data',] }],
    icon: [{ type: Input, args: ['icon',] }],
    closable: [{ type: Input }],
    verticalposition: [{ type: Input, args: ['vertical-position',] }],
    horizontalposition: [{ type: Input, args: ['horizontal-position',] }],
    autodismissmsg: [{ type: Input, args: ['auto-dismiss-msg',] }],
    autodismissmsginterval: [{ type: Input, args: ['auto-dismiss-msg-interval',] }],
    closeonescape: [{ type: Input, args: ['close-on-escape',] }],
    backgroundColor: [{ type: Input, args: ['background-color',] }],
    foregroundColor: [{ type: Input, args: ['foreground-color',] }],
    notificationTemplate: [{ type: ContentChild, args: ['amexioNotificationTemp',] }],
    keyEvent: [{ type: HostListener, args: ['window:keyup.esc', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/1/17.
 */
class AmexioSideNavComponent {
    /**
     * @param {?} dataService
     * @param {?} matchMediaService
     * @param {?} element
     */
    constructor(dataService, matchMediaService, element) {
        this.dataService = dataService;
        this.matchMediaService = matchMediaService;
        this.element = element;
        /*
           Events
           name : nodeClick
           datatype : none
           version : none
           default : none
           description : Fire when sidenav bar menu click
           */
        this.nodeClick = new EventEmitter();
        /*
           Events
           name : onDrag
           datatype : none
           version : 4.2.9
           default : none
           description : Fire when you drag node
           */
        this.onDrag = new EventEmitter();
        this.position = 'left';
        this.smalldevice = false;
        this.sidenavexpandedinsmalldevice = false;
        this.width = '20%';
        const /** @type {?} */ that = this;
        this.displaykey = 'text';
        this.childarraykey = 'children';
        /*---------------------------------------------------
             TAP INTO LISTENERS FOR WHEN DEVICE WIDTH CHANGES
             ---------------------------------------------------*/
        this.matchMediaService.OnPhone((mediaQueryList) => {
            that.handleDeviceSettings(false);
        });
        this.matchMediaService.OnTablet((mediaQueryList) => {
            that.handleDeviceSettings(false);
        });
        this.matchMediaService.OnDesktop((mediaQueryList) => {
            that.handleDeviceSettings(false);
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((response) => {
                this.responseData = response;
            }, (error) => {
            }, () => {
                this.setData(this.responseData);
            });
        }
        if (this.position == null) {
            this.position = 'left';
        }
        if (!this.height) {
            this.height = '100%';
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onClick(node) {
        this.nodeClick.emit(node);
        this.activateNode(this.data, node);
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        // Check if key is added?
        let /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            const /** @type {?} */ dr = this.datareader.split('.');
            for (const /** @type {?} */ ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.activateNode(this.data, null);
        this.handleDeviceSettings(false);
    }
    /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    activateNode(data, node) {
        for (const /** @type {?} */ i of data) {
            if (node === i && !i[this.childarraykey]) {
                i['active'] = true;
            }
            else {
                i['active'] = false;
            }
            if (i[this.childarraykey]) {
                this.activateNode(i[this.childarraykey], node);
            }
        }
    }
    /**
     * @return {?}
     */
    toggleSideNav() {
        this.handleDeviceSettings(!this.isSideNavExpand);
    }
    /**
     * @return {?}
     */
    close() {
        this.handleDeviceSettings(false);
    }
    /**
     * @param {?} expand
     * @return {?}
     */
    handleDeviceSettings(expand) {
        if (this.position !== 'relative') {
            if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
                this.smalldevice = true;
                if (expand) {
                    this.width = '80%';
                    this.isSideNavExpand = true;
                    this.sidenavexpandedinsmalldevice = true;
                }
                else {
                    this.width = '0%';
                    this.isSideNavExpand = false;
                    this.sidenavexpandedinsmalldevice = false;
                }
            }
            else {
                this.width = '20%';
                this.smalldevice = false;
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getNodeDragEvent(event) {
        this.onDrag.emit(event);
    }
}
AmexioSideNavComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-side-nav', template: `
    <div *ngIf="(position !='relative' && smalldevice)"
         [ngClass]="{'sidenav-mobile-bar-left':(position=='left' && position!='relative'),'sidenav-mobile-bar-right':(position=='right' && position!='relative')}"
         class="sidenav-mobile-bar" (click)="toggleSideNav()">
      <amexio-nav-icon key="sidenav_bar"></amexio-nav-icon>
    </div>
    <div [ngStyle]="{'width':width}" style="height: 100%" [ngClass]="{'left':(position=='left' && position!='relative'),'right':(position=='right' && position!='relative')}">
      <div class="sidenav" [ngStyle]="{'height':height}">
        <ul>
          <li>
            <div *ngIf="sidenavtitle" class="title">
              <ng-container *ngIf="titleimage">
                <p><img [attr.src]="titleimage" alt=" Title image" style="width: 60px;height: 60px;padding-left: 80px;"/></p>
              </ng-container>
              <ng-container *ngIf="sidenavtitle">
                <p>{{sidenavtitle}}</p>
              </ng-container>
              <span *ngIf="sidenavexpandedinsmalldevice" style="padding-right: 10px; float: right" (click)="close()">
                <amexio-nav-icon key="sidenav_close"></amexio-nav-icon>
              </span>
            </div>
          </li>

          <amexio-sidenav-node  *ngFor="let node of data" 
                                [enable-border]="(node && node[childarraykey] && (node[childarraykey].length>0))" 
                                [active]="(node && node.active)" 
                                [icon]="node.icon"
                                [badge]="node.badge"
                                [enable-drag]="enabledrag"
                                (nodeClick)="onClick($event)"
                                (onDrag)="getNodeDragEvent($event)"
                                [expand]="node?.expand"
                                [label]="node[displaykey]"
                                [node]="node"
                                [data]="node[childarraykey]">
          </amexio-sidenav-node>


          <ng-content></ng-content>
        </ul>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioSideNavComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: DeviceQueryService },
    { type: ElementRef }
];
AmexioSideNavComponent.propDecorators = {
    data: [{ type: Input }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    position: [{ type: Input }],
    titleimage: [{ type: Input }],
    nodeClick: [{ type: Output }],
    onDrag: [{ type: Output }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    sidenavtitle: [{ type: Input, args: ['title',] }],
    enabledrag: [{ type: Input, args: ['enable-drag',] }],
    displaykey: [{ type: Input, args: ['display-key',] }],
    childarraykey: [{ type: Input, args: ['child-array-key',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioSideNavInnerNodeComponent {
    constructor() {
        this.onClick = new EventEmitter();
        this.onDrag = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onNodeClick(node) {
        node.expand = !node.expand;
        this.getOnClick(node);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getOnClick(node) {
        this.onClick.emit(node);
        this.activateNode(this.data, node);
    }
    /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    activateNode(data, node) {
        for (const /** @type {?} */ i of data) {
            if (node === i && !i[this.childarraykey]) {
                i['active'] = true;
            }
            else {
                i['active'] = false;
            }
            if (i[this.childarraykey]) {
                this.activateNode(i[this.childarraykey], node);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragStartEvent(event) {
        if (this.enabledrag) {
            event.event.dataTransfer.setData('dragData', JSON.stringify(event.data));
            this.onDrag.emit(event);
        }
    }
}
AmexioSideNavInnerNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-sidenav-innernode',
                template: `
    <ul>
      <li *ngFor="let node of data">

        <div [attr.draggable]="enabledrag" (dragstart)="dragStartEvent({event:$event,data:node})" class="defaultnode"
          [ngClass]="{'activenode':node.active}" (click)="onNodeClick(node)">
          <span *ngIf="node.icon">
            <amexio-nav-icon class="node-icon" [customclass]="node.icon"></amexio-nav-icon>
          </span>
          <span>{{node[displaykey]}}</span>
          <ng-container *ngIf="node.badge">
            <span class="nav-badge">{{node.badge}}</span>
          </ng-container>
          <ng-container *ngIf="node[childarraykey] && (node[childarraykey].length>0)">
            <span style="padding-right: 10px; float: right" *ngIf="node.expand">
              <amexio-nav-icon key="itemselector_caretup"></amexio-nav-icon>
            </span>

            <span style="padding-right: 10px;float: right;" *ngIf="!node.expand">
              <amexio-nav-icon key="itemselector_caretdown"></amexio-nav-icon>
            </span>
          </ng-container>
        </div>
        <div class="submenu-details" [ngClass]="{'sidenav-submenu-expanded':node.expand}">
          <amexio-sidenav-innernode *ngIf="node[childarraykey] && (node[childarraykey].length>0)" 
              [enable-drag]="enabledrag" 
              (onDrag)="dragStartEvent($event)"  
            [display-key]="displaykey"
            [child-array-key]="childarraykey" [data]="node[childarraykey]" (onDrag)="dragStartEvent($event)" (onClick)="getOnClick($event)">
          </amexio-sidenav-innernode>
        </div>
      </li>
    </ul>
  `,
            },] },
];
AmexioSideNavInnerNodeComponent.propDecorators = {
    displaykey: [{ type: Input, args: ['display-key',] }],
    icon: [{ type: Input, args: ['icon',] }],
    childarraykey: [{ type: Input, args: ['child-array-key',] }],
    data: [{ type: Input, args: ['data',] }],
    onClick: [{ type: Output }],
    enabledrag: [{ type: Input, args: ['enable-drag',] }],
    onDrag: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/1/17.
 */
class SideNavNodeComponent {
    constructor() {
        /*
           Events
           name : nodeClick
           datatype : none
           version : none
           default : none
           description : Fire when sidenav bar menu click
           */
        this.nodeClick = new EventEmitter();
        /*
           Events
           name : onDrag
           datatype : none
           version : 4.2.9
           default : none
           description : Fire when you drag node
           */
        this.onDrag = new EventEmitter();
        this.expand = false;
        this.displaykey = 'text';
        this.childarraykey = 'children';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.node && !this.label) {
            this.expand = true;
            this.collapsable = false;
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onClick(node) {
        this.expand = !this.expand;
        this.nodeClick.emit(node);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onNodeClick(node) {
        this.nodeClick.emit(node);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragStartEvent(event) {
        if (this.enabledrag) {
            event.event.dataTransfer.setData('dragData', JSON.stringify(event.data));
            this.onDrag.emit(event);
        }
    }
}
SideNavNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-sidenav-node', template: `
    <li>
      <div *ngIf="enableborder" class="border"></div>
      <div *ngIf="label || badge || icon" [attr.draggable]="enabledrag" (dragstart)="dragStartEvent({event:$event,data:node})" class="headernode" [ngClass]="{'activenode':active}"
         (click)="onClick(nodedata)">
        <amexio-nav-icon  *ngIf="icon" class="node-icon" [customclass]="icon"></amexio-nav-icon>
        <span>{{label}} </span>

          <span *ngIf="badge" class="nav-badge" >{{badge}}</span>

        <ng-container *ngIf="(node  && (node.length>0)) || collapsable" >
          <span style="padding-right: 10px; float: right" *ngIf="expand" ><amexio-nav-icon key="sidenav-angle-up"></amexio-nav-icon></span>
          <span style="padding-right: 10px;float: right" *ngIf="!expand" ><amexio-nav-icon key="sidenav-angle-down"></amexio-nav-icon></span>
        </ng-container>
   
      </div>
      <div *ngIf="node"  class="sidenav-submenu-details sidenav-submenu-expanded"  [ngClass]="{'sidenav-submenu-expanded':expand}">
        <amexio-sidenav-innernode *ngIf="node && (node.length>0)" 
            (onClick)="onNodeClick($event)"
            [display-key]="displaykey" 
            [child-array-key]="childarraykey"  
            [enable-drag]="enabledrag" 
            (onDrag)="dragStartEvent($event)"  
            [data]="node">
        </amexio-sidenav-innernode>
      </div>

      <div class="sidenav-submenu-details" style="padding-right: 20px;"  [ngClass]="{'sidenav-submenu-expanded':expand}" >
          <ng-content></ng-content>
      </div> 
    </li>
  `,
            },] },
];
/** @nocollapse */
SideNavNodeComponent.ctorParameters = () => [];
SideNavNodeComponent.propDecorators = {
    nodedata: [{ type: Input, args: ['node',] }],
    badge: [{ type: Input, args: ['badge',] }],
    icon: [{ type: Input, args: ['icon',] }],
    label: [{ type: Input, args: ['label',] }],
    enableborder: [{ type: Input, args: ['enable-border',] }],
    active: [{ type: Input, args: ['active',] }],
    collapsable: [{ type: Input, args: ['collapsable',] }],
    node: [{ type: Input, args: ['data',] }],
    enabledrag: [{ type: Input, args: ['enable-drag',] }],
    nodeClick: [{ type: Output }],
    onDrag: [{ type: Output }],
    displaykey: [{ type: Input, args: ['display-key',] }],
    childarraykey: [{ type: Input, args: ['child-array-key',] }],
    expand: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const NAV_COMPONENTS = [
    AmexioSideNavComponent,
    SideNavNodeComponent,
    AmexioNavBarComponent,
    AmexioNavItemComponent,
    AmexioNotificationComponent,
    AmexioNavActionComponent,
    AmexioNavTextFieldComponent,
    AmexioNavMenuComponent,
    AmexioNavItemComponent,
    DockbarComponent,
    DockedBarToolComponent,
    AmexioMenuBarComponent,
    AmexioNavIconPaneComponent,
    AmexioBreadcrumbComponent,
    AmexioSideNavInnerNodeComponent,
];
class AmexioNavModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioNavModule,
            providers: [CommonDataService, DeviceQueryService, IconLoaderService],
        };
    }
}
AmexioNavModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AmexioMediaModule,
                    AmexioLayoutModule,
                    AmexioFormsModule,
                    HttpClientModule,
                ],
                exports: NAV_COMPONENTS,
                declarations: NAV_COMPONENTS,
                providers: [CommonDataService, DeviceQueryService, IconLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const Icon = {
    fontawesome: 'fa',
    material: 'mat',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GridConstants {
}
GridConstants.Tablet = 'tab';
GridConstants.Desktop = 'desktop';
GridConstants.Mobile = 'mobile';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioGridModel {
    constructor() {
        this.name = '';
        this.desktop = [];
        this.mobile = [];
        this.tab = [];
        this.layoutType = '';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GridConfig {
    /**
     * @param {?} layoutName
     * @param {?} layoutType
     */
    constructor(layoutName, layoutType) {
        this.amexiogridmodel = new AmexioGridModel();
        this.amexiogridmodel.layoutType = layoutType;
        this.amexiogridmodel.name = layoutName;
        return this;
    }
    /**
     * @param {?} layout
     * @return {?}
     */
    addlayout(layout) {
        this.count = layout.length;
        if (this.amexiogridmodel.layoutType === '') {
            this.amexiogridmodel.layoutType = GridConstants.Desktop;
        }
        this.amexiogridmodel[this.amexiogridmodel.layoutType].push(layout);
        return this;
    }
    /**
     * @return {?}
     */
    getLayout() {
        return this.amexiogridmodel;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AmexioWidgetModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioWidgetModule,
            providers: [CommonDataService, DeviceQueryService, IconLoaderService],
        };
    }
}
AmexioWidgetModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    AmexioFormsModule,
                    AmexioNavModule,
                    AmexioDataModule,
                    AmexioLayoutModule,
                    AmexioMediaModule,
                    AmexioPaneModule,
                    HttpClientModule,
                ],
                entryComponents: [AmexioTabPillComponent],
                exports: [
                    AmexioFormsModule,
                    AmexioNavModule,
                    AmexioDataModule,
                    AmexioLayoutModule,
                    AmexioMediaModule,
                    AmexioPaneModule,
                ],
                declarations: [],
                providers: [CommonDataService, DeviceQueryService, IconLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class DashBoardTitleComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() { }
}
DashBoardTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dashboard-title', template: ` `,
            },] },
];
/** @nocollapse */
DashBoardTitleComponent.ctorParameters = () => [];
DashBoardTitleComponent.propDecorators = {
    title: [{ type: Input }],
    position: [{ type: Input }],
    color: [{ type: Input }],
    fontname: [{ type: Input, args: ['font-name',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    bold: [{ type: Input }],
    italic: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 7/25/17.
 */
class DataPointCenterComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DataPointCenterComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-center', template: `

    <div [ngClass]="cclass" [attr.align]="contentalign" [style.background-color]="backgroundcolor"
         [style.color]="fontcolor" [style.width]="width" [style.height]="height">
      <ng-content></ng-content>
    </div>`,
            },] },
];
/** @nocollapse */
DataPointCenterComponent.ctorParameters = () => [];
DataPointCenterComponent.propDecorators = {
    contentalign: [{ type: Input, args: ['content-align',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    cclass: [{ type: Input, args: ['c-class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 8/16/17.
 */
class DataPointsComponent {
    constructor() {
        this.colspan = 1;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.amexiocolor !== '') {
            this.dpClass = this.amexiocolor;
        }
        if (this.west) {
            this.colspan++;
        }
        if (this.east) {
            this.colspan++;
        }
    }
}
DataPointsComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-datapoints', template: `

  <div class="datapoints" [ngClass]="dpClass">
      <table width="100%" [style.background-color]="backgroundcolor" [style.color]="fontcolor">
        <tr *ngIf="north">
          <td [attr.colspan]="colspan">
            <ng-content select="amexio-north"></ng-content>
          </td>
        </tr>
        <tr>
          <td *ngIf="west">
            <ng-content select="amexio-west"></ng-content>
          </td>
          <td *ngIf="center">
            <ng-content select="amexio-center"></ng-content>
          </td>
          <td *ngIf="east">
            <ng-content select="amexio-east"></ng-content>
          </td>
        </tr>
        <tr *ngIf="south">
          <td [attr.colspan]="colspan">
            <ng-content select="amexio-south"></ng-content>
          </td>
        </tr>
      </table>
    </div>


  `, styles: [`
    .amexio-datapoints {

    }
  `],
            },] },
];
/** @nocollapse */
DataPointsComponent.ctorParameters = () => [];
DataPointsComponent.propDecorators = {
    north: [{ type: Input }],
    south: [{ type: Input }],
    west: [{ type: Input }],
    center: [{ type: Input }],
    east: [{ type: Input }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    amexiocolor: [{ type: Input, args: ['amexio-color',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 7/25/17.
 */
class DataPointEastComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.cclass == null) {
            this.cclass = 'datapoint-east';
        }
    }
}
DataPointEastComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-east', template: `

    <div [ngClass]="cclass" class="datapoint-east" [attr.align]="contentalign" [style.background-color]="backgroundcolor"
         [style.color]="fontcolor" [style.width]="width" [style.height]="height">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
DataPointEastComponent.ctorParameters = () => [];
DataPointEastComponent.propDecorators = {
    contentalign: [{ type: Input, args: ['content-align',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    cclass: [{ type: Input, args: ['c-class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 7/25/17.
 */
class DataPointNorthComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.cclass == null) {
            this.cclass = 'datapoints-north';
        }
    }
}
DataPointNorthComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-north', template: `

    <div [ngClass]="cclass" [attr.align]="contentalign" [style.background-color]="backgroundcolor"
         [style.color]="fontcolor" [style.width]="width" [style.height]="height">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
DataPointNorthComponent.ctorParameters = () => [];
DataPointNorthComponent.propDecorators = {
    contentalign: [{ type: Input, args: ['content-align',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    cclass: [{ type: Input, args: ['c-class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 7/25/17.
 */
class DataPointSouthComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.cclass == null) {
            this.cclass = 'datapoint-south';
        }
    }
}
DataPointSouthComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-south', template: `

    <div [ngClass]="cclass" [attr.align]="contentalign" [style.background-color]="backgroundcolor"
         [style.color]="fontcolor" [style.width]="width" [style.height]="height">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
DataPointSouthComponent.ctorParameters = () => [];
DataPointSouthComponent.propDecorators = {
    contentalign: [{ type: Input, args: ['content-align',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    cclass: [{ type: Input, args: ['c-class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 7/25/17.
 */
class DataPointWestComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.cclass == null) {
            this.cclass = 'datapoint-west';
        }
    }
}
DataPointWestComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-west', template: `

    <div [ngClass]="cclass" [attr.align]="contentalign" [style.background-color]="backgroundcolor"
         [style.color]="fontcolor" [style.width]="width" [style.height]="height">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
DataPointWestComponent.ctorParameters = () => [];
DataPointWestComponent.propDecorators = {
    contentalign: [{ type: Input, args: ['content-align',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    cclass: [{ type: Input, args: ['c-class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DashboardLoaderService {
    constructor() {
        this.chartPackage = {
            AreaChart: 'corechart',
            Bar: 'bar',
            BarChart: 'corechart',
            ColumnChart: 'corechart',
            PieChart: 'corechart',
            Gantt: 'gantt',
            Gauge: 'gauge',
            GeoChart: 'geochart',
            Histogram: 'corechart',
            Line: 'line',
            LineChart: 'corechart',
            Map: 'map',
            Timeline: 'timeline',
            BubbleChart: 'corechart',
            CandlestickChart: 'corechart',
            ComboChart: 'corechart',
            TreeMap: 'treemap',
        };
        this.googleScriptLoadingNotifier = new EventEmitter();
        this.isScriptLoading = false;
    }
    /**
     * @param {?} chartName
     * @return {?}
     */
    loadCharts(chartName) {
        return new rxjs_1((observer) => {
            this.loadScript().subscribe((val) => console.log(), (error) => console.error(error), () => {
                this.loadRequiredChart(observer, chartName);
            });
        });
    }
    /**
     * @return {?}
     */
    loadScript() {
        return new rxjs_1((observer) => {
            if (!this.isScriptLoading) {
                // check if previously its loaded
                if (typeof google !== 'undefined' && google.charts) {
                    // check if chart package has been loaded using chartPackagename ?
                    this.loadBaseChart(observer);
                }
                else {
                    this.isScriptLoading = true;
                    const /** @type {?} */ script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = 'https://www.gstatic.com/charts/loader.js';
                    script.async = true;
                    script.defer = true;
                    script.onload = () => {
                        this.isScriptLoading = false;
                        this.googleScriptLoadingNotifier.emit(true);
                        this.loadBaseChart(observer);
                    };
                    script.onerror = () => {
                        observer.error('Could Not Load google Script');
                    };
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
            }
            else {
                this.googleScriptLoadingNotifier.subscribe((loaded) => {
                    if (loaded) {
                        this.loadBaseChart(observer);
                    }
                });
            }
        });
    }
    /**
     * Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    loadBaseChart(observer) {
        google.charts.load('current', { packages: ['corechart'] });
        google.charts.setOnLoadCallback(() => {
            observer.complete();
        });
    }
    /**
     * Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    loadRequiredChart(observer, chartName) {
        if (google.visualization.hasOwnProperty(chartName)) {
            observer.complete();
        }
        else {
            google.charts.load('current', { packages: [this.chartPackage[chartName]] });
            google.charts.setOnLoadCallback(() => {
                observer.complete();
            });
        }
    }
}
DashboardLoaderService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
DashboardLoaderService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class GaugeChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.gaugeData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                width: this.width,
                height: this.height,
                redFrom: this.redcolorfrom,
                redTo: this.redcolorto,
                yellowFrom: this.yellowcolorfrom,
                yellowTo: this.yellowcolorto,
                scalevalue: this.scalevalue,
            };
            if (this.gaugeData) {
                this.chart = new google.visualization.Gauge(this.gaugedashboard.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.gaugeData, this.options);
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartTitleArray = this.chartTitleComp.toArray();
        // take first component
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('Gauge').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
GaugeChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dashboard-gauge', template: `
    <div *ngIf="showChart" #gaugedashboard
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
GaugeChartComponent.ctorParameters = () => [
    { type: DashboardLoaderService }
];
GaugeChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    redcolorfrom: [{ type: Input, args: ['red-color-from',] }],
    redcolorto: [{ type: Input, args: ['red-color-to',] }],
    yellowcolorfrom: [{ type: Input, args: ['yellow-color-from',] }],
    yellowcolorto: [{ type: Input, args: ['yellow-color-to',] }],
    scalevalue: [{ type: Input, args: ['scale-value',] }],
    chartTitleComp: [{ type: ContentChildren, args: [DashBoardTitleComponent,] }],
    gaugedashboard: [{ type: ViewChild, args: ['gaugedashboard',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DASHBOARD = [
    DashBoardTitleComponent,
    DataPointCenterComponent,
    DataPointsComponent,
    DataPointEastComponent,
    DataPointNorthComponent,
    DataPointSouthComponent,
    DataPointWestComponent,
    GaugeChartComponent,
];
class AmexioDashBoardModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioDashBoardModule,
            providers: [CommonDataService, DashboardLoaderService],
        };
    }
}
AmexioDashBoardModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                ],
                exports: DASHBOARD,
                declarations: DASHBOARD,
                providers: [CommonDataService, DashboardLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class ChartAreaComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
ChartAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-area-properties', template: ``,
            },] },
];
/** @nocollapse */
ChartAreaComponent.ctorParameters = () => [];
ChartAreaComponent.propDecorators = {
    chartbackgroundcolor: [{ type: Input, args: ['chart-background-color',] }],
    leftposition: [{ type: Input, args: ['left-position',] }],
    topposition: [{ type: Input, args: ['top-position',] }],
    chartwidth: [{ type: Input, args: ['chart-width',] }],
    chartheight: [{ type: Input, args: ['chart-height',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class ChartLegendComponent {
    constructor() {
        /*
        Properties
        name : bold
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : Set true for Legend text in bold
        */
        this.bold = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
ChartLegendComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-legend', template: ` `,
            },] },
];
/** @nocollapse */
ChartLegendComponent.ctorParameters = () => [];
ChartLegendComponent.propDecorators = {
    position: [{ type: Input }],
    alignment: [{ type: Input }],
    color: [{ type: Input }],
    fontname: [{ type: Input, args: ['font-name',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    bold: [{ type: Input }],
    maxlines: [{ type: Input, args: ['max-lines',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class ChartTitleComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
ChartTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-title', template: ` `,
            },] },
];
/** @nocollapse */
ChartTitleComponent.ctorParameters = () => [];
ChartTitleComponent.propDecorators = {
    title: [{ type: Input }],
    position: [{ type: Input }],
    color: [{ type: Input }],
    fontname: [{ type: Input, args: ['font-name',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    bold: [{ type: Input }],
    italic: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ChartLoaderService {
    constructor() {
        this.chartPackage = {
            AreaChart: 'corechart',
            Bar: 'bar',
            BarChart: 'corechart',
            ColumnChart: 'corechart',
            PieChart: 'corechart',
            Gantt: 'gantt',
            Gauge: 'gauge',
            GeoChart: 'geochart',
            Histogram: 'corechart',
            Line: 'line',
            LineChart: 'corechart',
            Map: 'map',
            Timeline: 'timeline',
            BubbleChart: 'corechart',
            CandlestickChart: 'corechart',
            ComboChart: 'corechart',
            TreeMap: 'treemap',
        };
        this.googleScriptLoadingNotifier = new EventEmitter();
        this.isScriptLoading = false;
    }
    /**
     * @param {?} chartName
     * @return {?}
     */
    loadCharts(chartName) {
        return new rxjs_1((observer) => {
            this.loadScript().subscribe((val) => console.log(), (error) => console.error(error), () => {
                this.loadRequiredChart(observer, chartName);
            });
        });
    }
    /**
     * @return {?}
     */
    loadScript() {
        return new rxjs_1((observer) => {
            if (!this.isScriptLoading) {
                // check if previously its loaded
                if (typeof google !== 'undefined' && google.charts) {
                    // check if chart package has been loaded using chartPackagename ?
                    this.loadBaseChart(observer);
                }
                else {
                    this.isScriptLoading = true;
                    const /** @type {?} */ script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = 'https://www.gstatic.com/charts/loader.js';
                    script.async = true;
                    script.defer = true;
                    script.onload = () => {
                        this.isScriptLoading = false;
                        this.googleScriptLoadingNotifier.emit(true);
                        this.loadBaseChart(observer);
                    };
                    script.onerror = () => {
                        observer.error('Could Not Load google Script');
                    };
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
            }
            else {
                this.googleScriptLoadingNotifier.subscribe((loaded) => {
                    if (loaded) {
                        this.loadBaseChart(observer);
                    }
                });
            }
        });
    }
    /**
     * Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    loadBaseChart(observer) {
        google.charts.load('current', { packages: ['corechart'] });
        google.charts.setOnLoadCallback(() => {
            observer.complete();
        });
    }
    /**
     * Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    loadRequiredChart(observer, chartName) {
        if (google.visualization.hasOwnProperty(chartName)) {
            observer.complete();
        }
        else {
            google.charts.load('current', { packages: [this.chartPackage[chartName]] });
            google.charts.setOnLoadCallback(() => {
                observer.complete();
            });
        }
    }
}
ChartLoaderService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ChartLoaderService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class AreaChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.areaData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.createTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.createChartLegend() : 'none',
                chartArea: this.chartAreaComponent ? this.createChartArea() : null,
            };
            if (this.areaData) {
                this.chart = new google.visualization.AreaChart(this.areachart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.areaData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    createTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    createChartLegend() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    createChartArea() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('AreaChart').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
AreaChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-area', template: `
    <div *ngIf="showChart" #areachart
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
AreaChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
AreaChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    areachart: [{ type: ViewChild, args: ['areachart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class BarChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        // showing stack chart
        /*
        Properties
        name : stacked
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : If set to true, stacks the elements for all series at each domain value.default value is false
        */
        this.stacked = false;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this.showChart = true;
            this._data = data;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            // bind the data
            this.barData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                isStacked: this.stacked,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.createChartLegend() : 'none',
                chartArea: this.chartAreaComponent ? this.createChartBar() : null,
                hAxis: {
                    title: this.xaxistitle, minvalue: 0,
                },
                vAxis: {
                    title: this.yaxistitle,
                },
            };
            if (this.barData) {
                this.chart = new google.visualization.BarChart(this.barchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.barData, this.options);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    createChartLegend() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    createChartBar() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('BarChart').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
BarChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-bar', template: `
    <div *ngIf="showChart" #barchart
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
BarChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
BarChartComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    stacked: [{ type: Input }],
    xaxistitle: [{ type: Input, args: ['x-axis-title',] }],
    yaxistitle: [{ type: Input, args: ['y-axis-title',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    barchart: [{ type: ViewChild, args: ['barchart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class HorizontalAxisComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
HorizontalAxisComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-horizontal-axis', template: ` `,
            },] },
];
/** @nocollapse */
HorizontalAxisComponent.ctorParameters = () => [];
HorizontalAxisComponent.propDecorators = {
    title: [{ type: Input }],
    titlecolor: [{ type: Input, args: ['title-color',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class VerticalAxisComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
VerticalAxisComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-vertical-axis', template: ` `,
            },] },
];
/** @nocollapse */
VerticalAxisComponent.ctorParameters = () => [];
VerticalAxisComponent.propDecorators = {
    title: [{ type: Input }],
    titlecolor: [{ type: Input, args: ['title-color',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class BubbleChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        /*
        Properties
        name : axis-color
        datatype : any
        version : 4.0 onwards
        default : none
        description : An object that specifies a mapping between color column values and
        colors or a gradient scale.example:['#FF0000', '#00FF00'] or ['yellow', 'red']
        */
        this.axiscolor = [];
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.bubbleData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.createTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.createChartLegend() : 'none',
                chartArea: this.chartAreaComponent ? this.createChartBackground() : null,
                vAxis: this.verticalComponent ? this.createChartVertical() : null,
                hAxis: this.horizontalComponent ? this.createchartHorizontal() : null,
                bubble: { textStyle: { fontsize: 11 } },
                axiscolor: { colors: this.axiscolor },
            };
            if (this.bubbleData) {
                this.chart = new google.visualization.BubbleChart(this.bubblechart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.bubbleData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    createTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    createChartLegend() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    createChartBackground() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    createChartVertical() {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    createchartHorizontal() {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('BubbleChart').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
BubbleChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-bubble',
                template: `
      <div *ngIf="showChart" #bubblechart
           [style.width]="width"
           [style.height]="height" (window:resize)="onResize($event)">
        <div *ngIf="!hasLoaded" class="lmask">
        </div>
      </div>
  `,
                styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }
  .lmask.fixed {
    position: fixed;
  }
  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }
  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }
  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
BubbleChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
BubbleChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    axiscolor: [{ type: Input, args: ['axis-color',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    horizontalComp: [{ type: ContentChildren, args: [HorizontalAxisComponent,] }],
    verticalComp: [{ type: ContentChildren, args: [VerticalAxisComponent,] }],
    bubblechart: [{ type: ViewChild, args: ['bubblechart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class CandlestickChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.candlestickData = google.visualization.arrayToDataTable(this._data, true);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTileTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: 'none',
                chartArea: this.chartAreaComponent ? this.chartLegendStyle() : null,
                vAxis: this.verticalComponent ? this.chartVerticalStyle() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalStyle() : null,
            };
            if (this.candlestickData) {
                this.chart = new google.visualization.CandlestickChart(this.candlestick.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.candlestickData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTileTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    chartVerticalStyle() {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    chartHorizontalStyle() {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        // take first component
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('CandlestickChart').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
CandlestickChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-candlestick', template: `
    <div *ngIf="showChart" #candlestick
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
CandlestickChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
CandlestickChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    horizontalComp: [{ type: ContentChildren, args: [HorizontalAxisComponent,] }],
    verticalComp: [{ type: ContentChildren, args: [VerticalAxisComponent,] }],
    candlestick: [{ type: ViewChild, args: ['candlestick',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class CandlestickWaterfallChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.candlestickData = google.visualization.arrayToDataTable(this._data, true);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: 'none',
                chartArea: this.chartAreaComponent ? this.chartLegendStyle() : null,
                vAxis: this.verticalComponent ? this.chartVerticalComponent() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalComponent() : null,
                bar: { groupWidth: this.barwidth ? this.barwidth : null },
                // Remove space between bars.
                candlestick: this.chartColorStyle(),
            };
            if (this.candlestickData) {
                this.chart = new google.visualization.CandlestickChart(this.candlestickwaterfall.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.candlestickData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    chartVerticalComponent() {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    chartHorizontalComponent() {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    chartColorStyle() {
        return {
            fallingColor: this.fallingcolor ? { strokeWidth: 0, fill: this.fallingcolor ? this.fallingcolor : null } : null,
            // red
            risingColor: this.risingcolor ? { strokeWidth: 0, fill: this.risingcolor ? this.risingcolor : null } : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        // take first component
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('CandlestickChart').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
CandlestickWaterfallChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-candlestick-waterfall', template: `
    <div *ngIf="showChart" #candlestickwaterfall
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
CandlestickWaterfallChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
CandlestickWaterfallChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    barwidth: [{ type: Input, args: ['bar-width',] }],
    fallingcolor: [{ type: Input, args: ['falling-color',] }],
    risingcolor: [{ type: Input, args: ['rising-color',] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    horizontalComp: [{ type: ContentChildren, args: [HorizontalAxisComponent,] }],
    verticalComp: [{ type: ContentChildren, args: [VerticalAxisComponent,] }],
    candlestickwaterfall: [{ type: ViewChild, args: ['candlestickwaterfall',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class ColumnChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        // showing stack chart
        /*
        Properties
        name : stacked
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : If set to true, stacks the elements for all series at each domain value.default value is false
        */
        this.stacked = false;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.columnData = this.createTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                isStacked: this.stacked,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackGroundColor() : null,
            };
            if (this.columnData) {
                this.chart = new google.visualization.ColumnChart(this.columnchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.columnData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackGroundColor() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @param {?} array
     * @return {?}
     */
    createTable(array) {
        // create Duplicate Array for data arrangement
        const /** @type {?} */ dupArray = array.slice();
        const /** @type {?} */ data = new google.visualization.DataTable();
        const /** @type {?} */ labelObject = dupArray[0];
        // remove first object of array
        dupArray.shift();
        labelObject.forEach((datatypeObject) => {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        });
        const /** @type {?} */ finalArray = [];
        dupArray.forEach((rowObject) => {
            finalArray.push(rowObject);
        });
        data.addRows(finalArray);
        return data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('ColumnChart').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
ColumnChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-column', template: `
    <div  *ngIf="showChart" #columnchart
         [style.width]="width"
         [style.height]="height"
         (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
ColumnChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
ColumnChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    stacked: [{ type: Input }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    columnchart: [{ type: ViewChild, args: ['columnchart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class ComboChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.comboData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackground() : null,
                vAxis: this.verticalComponent ? this.chartVerticalStyle() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalStyle() : null,
                seriesType: 'bars',
                series: { 4: { type: 'line' } },
            };
            if (this.comboData) {
                this.chart = new google.visualization.ComboChart(this.combochart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.comboData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    /**
     * @return {?}
     */
    chartTitleStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackground() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    chartVerticalStyle() {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    chartHorizontalStyle() {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('ComboChart').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
ComboChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-combo', template: `
    <div *ngIf="showChart" #combochart
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
ComboChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
ComboChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    horizontalComp: [{ type: ContentChildren, args: [HorizontalAxisComponent,] }],
    verticalComp: [{ type: ContentChildren, args: [VerticalAxisComponent,] }],
    combochart: [{ type: ViewChild, args: ['combochart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class DonutChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.donutData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chariTitleTextStyle() : null,
                pieHole: 0.4,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundColor() : null,
            };
            if (this.donutData) {
                this.chart = new google.visualization.PieChart(this.donutchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.donutData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    }
    /**
     * @return {?}
     */
    chariTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackgroundColor() {
        return { backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('PieChart').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
DonutChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-donut', template: `
    <div *ngIf="showChart" #donutchart
         [style.width]="width"
         [style.height]="height"
         (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
DonutChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
DonutChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    donutchart: [{ type: ViewChild, args: ['donutchart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2017-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class GanttChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        /*
        Properties
        name : critical-path-enabled
        datatype : boolean
        version : 4.3 onwards
        default : false
        description : If you set the criticalPathEnabled option to true, it show critical path line
        */
        this.criticalPathEnabled = false;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.data && this.showChart) {
            this.hasLoaded = true;
            this.options = { gantt: { criticalPathEnabled: this.criticalPathEnabled,
                    criticalPathStyle: { stroke: '#e64a19',
                        strokeWidth: 5 } },
                innerGridTrack: { fill: this.innerGridTrackColor ? this.innerGridTrackColor : '' },
                innerGridDarkTrack: { fill: this.innerGridDarkTrack ? this.innerGridDarkTrack : '' },
            };
            if (google && google.visualization) {
                this.chart = new google.visualization.Gantt(this.ganttchart.nativeElement);
                this.chart.draw(this.createTable(this._data), this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
            else {
                this.hasLoaded = false;
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    /**
     * @param {?} array
     * @return {?}
     */
    createTable(array) {
        const /** @type {?} */ copyOfArray = array.slice();
        const /** @type {?} */ data = new google.visualization.DataTable();
        const /** @type {?} */ labelObject = copyOfArray[0];
        copyOfArray.shift();
        labelObject.forEach((datatypeObject) => {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        });
        const /** @type {?} */ newArray = [];
        copyOfArray.forEach((rowObject) => {
            newArray.push(rowObject);
        });
        data.addRows(newArray);
        return data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('Gantt').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
}
GanttChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-gantt', template: `
    <div *ngIf='showChart' #gantt
         [style.width]='width'
    >
      <div *ngIf='!hasLoaded' class='lmask'>
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
GanttChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
GanttChartComponent.propDecorators = {
    width: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    criticalPathEnabled: [{ type: Input, args: ['critical-path-enabled',] }],
    innerGridTrackColor: [{ type: Input, args: ['inner-grid-track-color',] }],
    innerGridDarkTrack: [{ type: Input, args: ['inner-grid-dark-track-color',] }],
    ganttchart: [{ type: ViewChild, args: ['gantt',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class HistogramChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.histogramData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.charttitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackground() : null,
            };
            if (this.histogramData) {
                this.chart = new google.visualization.Histogram(this.histogramchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.histogramData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    /**
     * @return {?}
     */
    charttitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackground() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('Histogram').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
}
HistogramChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-histogram',
                template: `
      <div *ngIf="showChart" #histogramchart
           [style.width]="width"
           [style.height]="height"
      >
        <div *ngIf="!hasLoaded" class="lmask">
        </div>
      </div>
  `,
                styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }
  .lmask.fixed {
    position: fixed;
  }
  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }
  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }
  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
HistogramChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
HistogramChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    histogramchart: [{ type: ViewChild, args: ['histogramchart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class LineChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.lineData = this.createTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundStyle() : null,
            };
            if (this.lineData) {
                this.chart = new google.visualization.LineChart(this.linechart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.lineData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackgroundStyle() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @param {?} array
     * @return {?}
     */
    createTable(array) {
        // create Duplicate Array for data arrangement
        const /** @type {?} */ dupArray = array.slice();
        const /** @type {?} */ data = new google.visualization.DataTable();
        const /** @type {?} */ labelObject = dupArray[0];
        // remove first object of array
        dupArray.shift();
        labelObject.forEach((datatypeObject) => {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        });
        const /** @type {?} */ finalArray = [];
        dupArray.forEach((rowObject) => {
            finalArray.push(rowObject);
        });
        data.addRows(finalArray);
        return data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('LineChart').subscribe((value) => console.log(), (error) => console.error(error), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
LineChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-line', template: `
    <div *ngIf="showChart" #linechart
         [style.width]="width"
         [style.height]="height"
         (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>

  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
LineChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
LineChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    linechart: [{ type: ViewChild, args: ['linechart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class PieChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.pieData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.charttitleTextStyle() : null,
                is3D: this.is3d,
                pieHole: this.piehole,
                startangle: this.startangle,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLengendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundStyle() : null,
            };
            if (this.pieData) {
                this.chart = new google.visualization.PieChart(this.piechart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.pieData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    }
    /**
     * @return {?}
     */
    charttitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLengendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackgroundStyle() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('PieChart').subscribe((value) => console.log(), (error) => console.error(error), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
PieChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-pie', template: `

        <div *ngIf="showChart" #piechart
             [style.width]="width"
             [style.height]="height"
             (window:resize)="onResize($event)">
          <div *ngIf="!hasLoaded" class="lmask">
          </div>
        </div>
  `,
                styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }
  .lmask.fixed {
    position: fixed;
  }
  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }
  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }
  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
PieChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
PieChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    is3d: [{ type: Input }],
    piehole: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    startangle: [{ type: Input, args: ['start-angle',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    piechart: [{ type: ViewChild, args: ['piechart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class ScatterChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.scatterData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundColor() : null,
                vAxis: this.verticalComponent ? this.chartVerticalStyle() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalStyle() : null,
            };
            if (this.scatterData) {
                this.chart = new google.visualization.ScatterChart(this.scatterchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.scatterData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackgroundColor() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    chartVerticalStyle() {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    chartHorizontalStyle() {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('ScatterChart').subscribe((value) => console.log(), (error) => console.error(error), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
ScatterChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-scatter', template: `
    <div *ngIf="showChart" #scatterchart
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
ScatterChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
ScatterChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    horizontalComp: [{ type: ContentChildren, args: [HorizontalAxisComponent,] }],
    verticalComp: [{ type: ContentChildren, args: [VerticalAxisComponent,] }],
    scatterchart: [{ type: ViewChild, args: ['scatterchart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
class TimeLineChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.data && this.showChart) {
            this.chart = new google.visualization.Timeline(this.timelinechart.nativeElement);
            this.hasLoaded = true;
            this.chart.draw(this.createTable(this._data));
            google.visualization.events.addListener(this.chart, 'click', this.onClick);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @param {?} array
     * @return {?}
     */
    createTable(array) {
        // create Duplicate Array for data arrangement
        const /** @type {?} */ dupArray = array.slice();
        const /** @type {?} */ data = new google.visualization.DataTable();
        const /** @type {?} */ labelObject = dupArray[0];
        // remove first object of array
        dupArray.shift();
        labelObject.forEach((datatypeObject) => {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        });
        const /** @type {?} */ finalArray = [];
        dupArray.forEach((rowObject) => {
            finalArray.push(rowObject);
        });
        data.addRows(finalArray);
        return data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('Timeline').subscribe((value) => console.log(), (error) => console.error(error), () => {
            this.drawChart();
        });
    }
}
TimeLineChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-timeline', template: `
    <div *ngIf="showChart" #timelinechart
         [style.width]="width"
    >
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
TimeLineChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
TimeLineChartComponent.propDecorators = {
    width: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    timelinechart: [{ type: ViewChild, args: ['timelinechart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const CHART_COMPONENTS = [
    AreaChartComponent, BarChartComponent, ChartAreaComponent,
    ChartLegendComponent, ChartTitleComponent, ColumnChartComponent,
    DonutChartComponent, GanttChartComponent, HistogramChartComponent, LineChartComponent,
    PieChartComponent, TimeLineChartComponent, ComboChartComponent,
    VerticalAxisComponent,
    HorizontalAxisComponent,
    BubbleChartComponent,
    ScatterChartComponent, CandlestickChartComponent, CandlestickWaterfallChartComponent,
];
class AmexioChartsModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioChartsModule,
            providers: [CommonDataService, ChartLoaderService],
        };
    }
}
AmexioChartsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                ],
                exports: CHART_COMPONENTS,
                declarations: CHART_COMPONENTS,
                providers: [CommonDataService, ChartLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MapLoaderService {
    constructor() {
        this.chartPackage = {
            AreaChart: 'corechart',
            Bar: 'bar',
            BarChart: 'corechart',
            ColumnChart: 'corechart',
            PieChart: 'corechart',
            Gantt: 'gantt',
            Gauge: 'gauge',
            GeoChart: 'geochart',
            Histogram: 'corechart',
            Line: 'line',
            LineChart: 'corechart',
            Map: 'map',
            Timeline: 'timeline',
            BubbleChart: 'corechart',
            CandlestickChart: 'corechart',
            ComboChart: 'corechart',
            TreeMap: 'treemap',
        };
        this.googleScriptLoadingNotifier = new EventEmitter();
        this.isScriptLoading = false;
    }
    /**
     * @param {?} chartName
     * @return {?}
     */
    loadCharts(chartName) {
        return new rxjs_1((observer) => {
            this.loadScript().subscribe((val) => console.log(), (error) => console.error(error), () => {
                this.loadRequiredChart(observer, chartName);
            });
        });
    }
    /**
     * @return {?}
     */
    loadScript() {
        return new rxjs_1((observer) => {
            if (!this.isScriptLoading) {
                // check if previously its loaded
                if (typeof google !== 'undefined' && google.charts) {
                    // check if chart package has been loaded using chartPackagename ?
                    this.loadBaseChart(observer);
                }
                else {
                    this.isScriptLoading = true;
                    const /** @type {?} */ script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = 'https://www.gstatic.com/charts/loader.js';
                    script.async = true;
                    script.defer = true;
                    script.onload = () => {
                        this.isScriptLoading = false;
                        this.googleScriptLoadingNotifier.emit(true);
                        this.loadBaseChart(observer);
                    };
                    script.onerror = () => {
                        observer.error('Could Not Load google Script');
                    };
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
            }
            else {
                this.googleScriptLoadingNotifier.subscribe((loaded) => {
                    if (loaded) {
                        this.loadBaseChart(observer);
                    }
                });
            }
        });
    }
    /**
     *  Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    loadBaseChart(observer) {
        google.charts.load('current', { packages: ['corechart'] });
        google.charts.setOnLoadCallback(() => {
            observer.complete();
        });
    }
    /**
     *  Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    loadRequiredChart(observer, chartName) {
        if (google.visualization.hasOwnProperty(chartName)) {
            observer.complete();
        }
        else {
            google.charts.load('current', { packages: [this.chartPackage[chartName]] });
            google.charts.setOnLoadCallback(() => {
                observer.complete();
            });
        }
    }
}
MapLoaderService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
MapLoaderService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MapPropertiesComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
MapPropertiesComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-map-properties', template: ``,
            },] },
];
/** @nocollapse */
MapPropertiesComponent.ctorParameters = () => [];
MapPropertiesComponent.propDecorators = {
    chartbackgroundcolor: [{ type: Input, args: ['chart-background-color',] }],
    leftposition: [{ type: Input, args: ['left-position',] }],
    topposition: [{ type: Input, args: ['top-position',] }],
    chartwidth: [{ type: Input, args: ['chart-width',] }],
    chartheight: [{ type: Input, args: ['chart-height',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GeoChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        /*
          not in use
        */
        this.countryname = false;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.geomapData = google.visualization.arrayToDataTable(this._data);
            this.showChartExist();
            if (this.geomapData) {
                this.chart = new google.visualization.GeoChart(this.geochart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.geomapData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    showChartExist() {
        this.options = {
            displayMode: this.countryname ? 'text' : null,
            region: this.regioncode ? this.regioncode : null,
            backgroundcolor: this.backgroundcolor ? this.backgroundcolor : null,
            unusedregioncolor: this.unusedregioncolor ? this.unusedregioncolor : null,
            chartArea: this.chartAreaComponent ? {
                backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
                left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
                top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
                height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
                width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
            } : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartAreaArray = this.chartAreaComp.toArray();
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('GeoChart').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
}
GeoChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-map-geo-chart', template: `
    <div *ngIf="showChart" #geochart
         [style.width]="width"
         [style.height]="height"
    >
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }
`],
            },] },
];
/** @nocollapse */
GeoChartComponent.ctorParameters = () => [
    { type: MapLoaderService }
];
GeoChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    countryname: [{ type: Input, args: ['country-name',] }],
    regioncode: [{ type: Input, args: ['region-code',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    unusedregioncolor: [{ type: Input, args: ['unused-region-color',] }],
    chartAreaComp: [{ type: ContentChildren, args: [MapPropertiesComponent,] }],
    geochart: [{ type: ViewChild, args: ['geochart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MapTitleComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
MapTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-map-title', template: ` `,
            },] },
];
/** @nocollapse */
MapTitleComponent.ctorParameters = () => [];
MapTitleComponent.propDecorators = {
    title: [{ type: Input }],
    position: [{ type: Input }],
    color: [{ type: Input }],
    fontname: [{ type: Input, args: ['font-name',] }],
    bold: [{ type: Input }],
    italic: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by sagar on 18/8/17.
 */
class TreeMapComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.treemapData = google.visualization.arrayToDataTable(this._data);
            this.initializeOptions();
            if (this.treemapData) {
                this.chart = new google.visualization.TreeMap(this.treemapmap.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.treemapData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    initializeOptions() {
        this.options = {
            title: this.mapTitleComponent ? this.mapTitleComponent.title : null,
            titleTextStyle: this.mapTitleComponent ? this.mapTitleTextStyle() : null,
            mincolor: this.mincolor ? this.mincolor : null, midcolor: this.midcolor ? this.midcolor : null,
            maxcolor: this.maxcolor ? this.maxcolor : null, headerHeight: 15, fontcolor: 'black',
            showscale: this.showscale ? this.showscale : false,
            maxpostdepth: this.maxpostdepth ? this.maxpostdepth : 1,
        };
    }
    /**
     * @return {?}
     */
    mapTitleTextStyle() {
        return {
            color: this.mapTitleComponent.color ? this.mapTitleComponent.color : null,
            fontName: this.mapTitleComponent.fontname ? this.mapTitleComponent.fontname : null,
            bold: this.mapTitleComponent.bold ? this.mapTitleComponent.bold : null,
            italic: this.mapTitleComponent.italic ? this.mapTitleComponent.italic : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.mapTitleArray = this.maptleComp.toArray();
        if (this.mapTitleArray.length === 1) {
            this.mapTitleComponent = this.mapTitleArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('TreeMap').subscribe((value) => console.log(), (errror) => console.error(errror), () => {
            this.drawChart();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
TreeMapComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-map-treemap', template: `
    <div *ngIf="showChart" #treemapmap
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)"
    >
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
TreeMapComponent.ctorParameters = () => [
    { type: MapLoaderService }
];
TreeMapComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    mincolor: [{ type: Input, args: ['min-color',] }],
    midcolor: [{ type: Input, args: ['mid-color',] }],
    maxcolor: [{ type: Input, args: ['max-color',] }],
    showscale: [{ type: Input, args: ['show-scale',] }],
    maxpostdepth: [{ type: Input, args: ['max-post-depth',] }],
    maptleComp: [{ type: ContentChildren, args: [MapTitleComponent,] }],
    treemapmap: [{ type: ViewChild, args: ['treemapmap',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MAP_COMPONENTS = [
    MapPropertiesComponent,
    GeoChartComponent,
    TreeMapComponent,
    MapTitleComponent,
];
class AmexioMapModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioMapModule,
            providers: [CommonDataService, MapLoaderService],
        };
    }
}
AmexioMapModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                ],
                exports: MAP_COMPONENTS,
                declarations: MAP_COMPONENTS,
                providers: [CommonDataService, MapLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 18/1/18.
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Pratik Kelwalkar
 *
 */
class MultiMediaCarouselComponent {
    constructor() {
        /*
        Properties
        name : has-details
        datatype :  boolean
        version : 4.0 onwards
        default : none
        description : Provide a embedded view for more information on the media
        
        */
        this.hasDetail = true;
        /*
        Events
        name : onVideoLoad
        datatype : none
        version : none
        default : none
        description :
        */
        this.onVideoLoad = new EventEmitter();
        this.right = false;
        this.left = false;
        this.elementId = 'multi-media-ee-carousel-' + Math.floor(Math.random() * 90000) + 10000;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.carouselStyle == null) {
            this.carouselStyle = 'horizontal';
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['data'] != null) {
            this.data = changes['data'].currentValue;
        }
    }
    /**
     * @return {?}
     */
    leftClick() {
        const /** @type {?} */ ts = document.getElementById(this.elementId);
        ts.scrollLeft -= 350;
        if (ts.scrollLeft === 0) {
            document.getElementById(this.elementId + 'leftarrow').style.visibility = 'hidden';
        }
        document.getElementById(this.elementId + 'rightarrow').style.visibility = 'visible';
    }
    /**
     * @return {?}
     */
    rightClick() {
        const /** @type {?} */ ts = document.getElementById(this.elementId);
        ts.scrollLeft += 350;
        if ((ts.scrollWidth - ts.offsetWidth - ts.scrollLeft) <= 0) {
            document.getElementById(this.elementId + 'rightarrow').style.visibility = 'hidden';
        }
        document.getElementById(this.elementId + 'leftarrow').style.visibility = 'visible';
    }
    /**
     * @return {?}
     */
    closeDetailPage() {
        this.data.forEach((item) => {
            item.selected = null;
        });
        this.displayDetail = false;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    openDetailsSection(item) {
        this.videoUrl = item.video;
        this.currentDetailsImagePath = item.details_img;
        this.currentDetailsTitle = item.title;
        this.currentDetailsDesc = item.desc;
        this.currentContent = item.content;
        this.seasonNo = item.seasonNo;
        this.matchPercentage = item.matchPercentage;
        this.ageLimit = item.ageLimit;
        this.releaseYear = item.releaseYear;
        this.data.forEach((item1) => {
            item1.selected = null;
        });
        item.selected = 'selected';
        this.displayDetail = true;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    loadVideo(item) {
        this.onVideoLoad.emit(item.video);
    }
    /**
     * @param {?} video
     * @return {?}
     */
    playVideo(video) {
        this.onVideoLoad.emit(video);
    }
}
MultiMediaCarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-media-ee-carousel',
                template: `
    <div class="section-header" style="z-index: 1;">{{title}}</div>
    <div class="contain row">

      <div class="left-arrow" [attr.id]="elementId+'leftarrow'" style="cursor: pointer"> <div [ngClass]="{'controls' : carouselStyle=='horizontal','controls-v' : carouselStyle=='vertical'}" (click)="leftClick();"><em class="fa fa-chevron-left fa-2x" aria-hidden="true"></em></div> </div>

      <div class="row1" [attr.id]="elementId">
        <div class="row__inner">
          <ng-container *ngIf="data">
            <div class="tile" *ngFor="let item of data;let i = index">
              <div class="tile__media" (click)="loadVideo(item)">
                <img alt="title" class="tile__img" [attr.src]="item.img" />
              </div>
              <div class="{{item.selected}}">
                <em [ngStyle]="{'visibility':item.selected ? 'visible':'hidden'}" class="fa fa-caret-down" aria-hidden="false"></em>
              </div>
              <div [ngClass]="{'tile__details' : carouselStyle=='horizontal','tile__details_v' : carouselStyle=='vertical'}">
                <div class="textonly">

                  <div class="playpanel">
                    <div style="cursor: pointer" (click)="loadVideo(item)" class="playbutton"><em class="fa fa-play" aria-hidden="true"></em></div>
                  </div>

                  <span class="carousel-title" *ngIf="item.title">{{item.title}}</span><br>
                  <span class="match">{{item.matchPercentage}} Match</span> {{item.releaseYear}} <span class="age mini">{{item.ageLimit}}</span> {{item.seasonNo}}<br>
                  <div class="subtitle">{{item.desc}}</div>

                </div>
                <div class="actionpanel"   *ngIf="item.content">
                  <div style="cursor: pointer;" (click)="openDetailsSection(item)"><em class="fa fa-chevron-down fa-2x" aria-hidden="true"></em></div>
                </div>


              </div>
            </div>
          </ng-container>
        </div>
      </div>

      <ng-container *ngIf="carouselStyle=='horizontal'">
        <div class="right-arrow" [attr.id]="elementId+'rightarrow'" style="cursor: pointer"> <div [ngClass]="{'controls' : carouselStyle=='horizontal','controls-v' : carouselStyle=='vertical'}" (click)="rightClick();"><em class="fa fa-chevron-right fa-2x" aria-hidden="true"></em></div></div>
      </ng-container>

      <ng-container *ngIf="carouselStyle=='vertical'">
        <div class="right-arrow-tall" [attr.id]="elementId+'rightarrow'" style="cursor: pointer"> <div [ngClass]="{'controls' : carouselStyle=='horizontal','controls-v' : carouselStyle=='vertical'}" (click)="rightClick();"><em class="fa fa-chevron-right fa-2x" aria-hidden="true"></em></div></div>
      </ng-container>

    </div>

    <div [attr.id]="elementId+'carousel-detail-content'" class="collapse" *ngIf="hasDetail && displayDetail">
      <amexio-ee-content [bg-image-url]="currentDetailsImagePath"
                         [title]="currentDetailsTitle" [description]="currentDetailsDesc"
                         [contents]="currentContent" [link]="videoUrl"
                         (onWatchClick)="playVideo(videoUrl)" (onCloseClick)="closeDetailPage()"
                         [rate]="rate" [watch]="true" [my-list]="true"
                         [close]="true" [season-no]="seasonNo" [release-year]="releaseYear" [age-limit]="ageLimit" [match-percentage]="matchPercentage"
      ></amexio-ee-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
MultiMediaCarouselComponent.ctorParameters = () => [];
MultiMediaCarouselComponent.propDecorators = {
    data: [{ type: Input }],
    carouselStyle: [{ type: Input, args: ['carousel-type',] }],
    hasDetail: [{ type: Input, args: ['has-details',] }],
    title: [{ type: Input }],
    onVideoLoad: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ContentComponent {
    constructor() {
        /*
        Properties
        name : watch
        datatype :  any
        version : 4.0 onwards
        default : false
        description : Enable watch button.*/
        this.enableWatch = false;
        /*
        Properties
        name : my-list
        datatype : none
        version : 4.0 onwards
        default : false
        description : Enable MyList button.
        */
        this.enableMyList = false;
        /*
        Events
        name :  onWatchClick
        datatype :  none
        version : none
        default : none
        description : Get watch button click.
        */
        this.onWatchClick = new EventEmitter();
        /*
        Properties
        name : onAddListClick
        datatype :  none
        version : none
        default : none
        description : Get add list button click.
        
        */
        this.onAddListClick = new EventEmitter();
        /*
        Properties
        name : onLikeClick
        datatype :  none
        version : none
        default : none
        description : Get like click.
        
        */
        this.onLikeClick = new EventEmitter();
        /*
        Properties
        name : onUnlikeLikeClick
        datatype :  none
        version : none
        default : none
        description : Get unlike click.
        
        */
        this.onUnlikeLikeClick = new EventEmitter();
        /*
        Properties
        name : onCloseClick
        datatype :  any
        version :none
        default : none
        description : Get close content click.
        
        */
        this.onCloseClick = new EventEmitter();
        this.closeEnable = false;
        this.smallScreen = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (window.innerWidth < 768) {
            this.smallScreen = true;
            this.size = 'small';
        }
        else {
            this.smallScreen = false;
            this.size = 'default';
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["videoLink"] && !changes["videoLink"].isFirstChange()) {
            this.videoLink = changes["videoLink"].currentValue;
        }
    }
    /**
     * @return {?}
     */
    playVideo() {
        this.onWatchClick.emit(this.videoLink);
    }
    /**
     * @return {?}
     */
    addToList() {
        this.overviewData = {
            'title': this.title, 'description': this.description, 'Video Link': this.videoLink, 'rate': this.rate,
        };
        this.onAddListClick.emit(this.overviewData);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        if (event.target.innerWidth < 995) {
            this.size = 'small';
            this.smallScreen = true;
        }
        else {
            this.size = 'default';
            this.smallScreen = false;
        }
    }
    /**
     * @return {?}
     */
    getClassName() {
        if (this.smallScreen) {
            return 'button-small';
        }
        else {
            return 'button';
        }
    }
    /**
     * @return {?}
     */
    unlikeClick() {
        this.overviewData = {
            title: this.title, rate: this.rate,
        };
        this.onUnlikeLikeClick.emit(this.overviewData);
    }
    /**
     * @return {?}
     */
    likeClick() {
        this.overviewData = {
            title: this.title, rate: this.rate,
        };
        this.onLikeClick.emit(this.overviewData);
    }
    /**
     * @return {?}
     */
    closeDetailPage() {
        this.onCloseClick.emit(this.title);
    }
}
ContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-ee-content', template: `
    <div class="main-content" [ngStyle]="{'background-image':'url('+bgImgUrl+')'}" (window:resize)="onResize($event)">
       <span *ngIf="closeEnable" class="close-button">
        <i class="fa fa-times fa-lg" (click)="closeDetailPage()" aria-hidden="true"></i>
      </span>
      <div class="content-area" >
        <span class="content-title">{{title}}</span><br>
        <span><span class="match" *ngIf="matchPercentage">{{matchPercentage}} Match</span> {{releaseYear}} <span
          class="age" *ngIf="ageLimit">{{ageLimit}}</span> {{seasonNo}}</span><br>
        <p style="word-wrap: break-word;">{{description}}<br>

        <ng-container *ngIf="contents">
              <span>
                <li *ngFor="let data of contents"><strong
                  style="color: #999;">{{data.key}}: </strong> <strong>  {{data.value}}</strong></li><br>
          </span>
        </ng-container>
        <ul class="inline-list">
          <li *ngIf="enableWatch">
            <span class="content-button" (click)="playVideo()">
            <i class="fa fa-play"></i> &nbsp;&nbsp; Play</span>
            <!-- <amexio-ee-btn [cClass]="'buttoncustom'"
            [label]="'Play'" [type]="'danger'" [icon]="'fa fa-play'"
            [tooltipMessage]="'play'" [size]="size" (onClick)="playVideo()">
            </amexio-ee-btn> -->
          </li>
          <li *ngIf="enableMyList">
            <span class="content-button" (click)="addToList()">
            <i class="fa fa-plus"></i>&nbsp;&nbsp; MY LIST</span>
            <!-- <amexio-ee-btn [cClass]="'secondarybutton'" [label]="'MY LIST'"
            [icon]="'fa fa-plus'" [type]="'secondary'" [tooltipMessage]="'My List'"
            [size]="size" (onClick)="addToList()"></amexio-ee-btn> -->
          </li>
          <li>
            <a style="color: white!important;" [ngClass]="getClassName()" (click)="likeClick()"><i class="fa fa-thumbs-o-up fa-lg"
                                                                   aria-hidden="true"></i>
            </a>
          </li>
          <li><a style="color: white!important;" [ngClass]="getClassName()" (click)="unlikeClick()"><i class="fa fa-thumbs-o-down fa-lg "
                                                                       aria-hidden="true"></i></a></li>

        </ul>
        <ng-container *ngIf="rate && max">
          <amexio-rating-input [(ngModel)]="rate"
                               [max]="max" name="rate"
                               [read-only]="isReadonly">
          </amexio-rating-input>
        </ng-container>
      </div>
    </div>`,
            },] },
];
/** @nocollapse */
ContentComponent.ctorParameters = () => [];
ContentComponent.propDecorators = {
    bgImgUrl: [{ type: Input, args: ['bg-image-url',] }],
    title: [{ type: Input }],
    description: [{ type: Input }],
    contents: [{ type: Input }],
    videoLink: [{ type: Input, args: ['link',] }],
    rate: [{ type: Input }],
    max: [{ type: Input }],
    isReadonly: [{ type: Input }],
    enableWatch: [{ type: Input, args: ['watch',] }],
    enableMyList: [{ type: Input, args: ['my-list',] }],
    ageLimit: [{ type: Input, args: ['age-limit',] }],
    releaseYear: [{ type: Input, args: ['release-year',] }],
    seasonNo: [{ type: Input, args: ['season-no',] }],
    matchPercentage: [{ type: Input, args: ['match-percentage',] }],
    closeEnable: [{ type: Input, args: ['close',] }],
    onWatchClick: [{ type: Output }],
    onAddListClick: [{ type: Output }],
    onLikeClick: [{ type: Output }],
    onUnlikeLikeClick: [{ type: Output }],
    onCloseClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 18/1/18.
 */
class AmexioYoutubePlayerComponent {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        /*
        Events
        name :onCloseVideoPlayer
        datatype : none
        version : none
        default : none
        description : it is fired on video player close event
        
        */
        this.onCloseVideoPlayer = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.height == null) {
            this.height = 450;
        }
        if (this.width == null) {
            this.width = 98;
            this.closePadding = 97;
        }
        else {
            this.closePadding = this.width - 1;
        }
        if (this.url != null) {
            this.sanitizedUrl = this.sanitizer.bypassSecurityTrustResourceUrl(this.url);
        }
    }
    /**
     * @return {?}
     */
    routeBackToApp() {
        this.onCloseVideoPlayer.emit(this.url);
    }
}
AmexioYoutubePlayerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-ee-youtube-player', template: `
    <div>
      <span class="close-button" [ngStyle]="{'padding-left':closePadding+'%'}">
        <i class="fa fa-times fa-lg" (click)="routeBackToApp()" aria-hidden="true"></i>
      </span>
      <div class="text-center">
        <iframe [height]="height+'px'" [width]="width+'%'"
                [src]="sanitizedUrl" frameborder="0"
                allowfullscreen>
        </iframe>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioYoutubePlayerComponent.ctorParameters = () => [
    { type: DomSanitizer }
];
AmexioYoutubePlayerComponent.propDecorators = {
    url: [{ type: Input }],
    height: [{ type: Input }],
    width: [{ type: Input }],
    onCloseVideoPlayer: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const ENTERPRISE_COMPONENTS = [
    MultiMediaCarouselComponent,
    ContentComponent,
    AmexioYoutubePlayerComponent,
];
class AmexioEnterpriseModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioEnterpriseModule,
            providers: [CommonDataService, DeviceQueryService],
        };
    }
}
AmexioEnterpriseModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AmexioFormsModule,
                    HttpClientModule,
                ],
                exports: ENTERPRISE_COMPONENTS,
                declarations: ENTERPRISE_COMPONENTS,
                providers: [CommonDataService, DeviceQueryService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { AmexioWidgetModule, CommonDataService, DeviceQueryService, IconLoaderService, Icon, AmexioCreditCardModel, GridConfig, GridConstants, AmexioFormsModule, LoadRecaptchaService, COMPONENT_CLASS_MAP, AmexioButtonComponent, AmexioButtonGroupComponent, AmexioNavModule, AmexioSideNavComponent, SideNavNodeComponent, AmexioNavBarComponent, KEY_CODE_notify, AmexioNotificationComponent, AmexioLayoutModule, AmexioAccordionHeaderComponent, AmexioAccordionTabComponent, AmexioAccordionComponent, AccordionService, AmexioBorderLayoutItemComponent, AmexioBorderLayoutComponent, AmexioBoxComponent, AmexioCardComponent, AmexioColumnComponent, AmexioGridComponent, AmexioGridItemComponent, AmexioRowComponent, AmexioGridLayoutService, AmexioDataModule, AmexioListBoxComponent, AmexioTreeViewComponent, AmexioPaginatorComponent, TreeDataTableComponent, AmexioDashBoardModule, DashboardLoaderService, DashBoardTitleComponent, DataPointCenterComponent, DataPointsComponent, DataPointEastComponent, DataPointNorthComponent, DataPointSouthComponent, DataPointWestComponent, GaugeChartComponent, AmexioChartsModule, AreaChartComponent, BarChartComponent, BubbleChartComponent, CandlestickChartComponent, CandlestickWaterfallChartComponent, ChartAreaComponent, ChartLegendComponent, ChartTitleComponent, ColumnChartComponent, ComboChartComponent, DonutChartComponent, GanttChartComponent, HistogramChartComponent, HorizontalAxisComponent, LineChartComponent, PieChartComponent, ScatterChartComponent, TimeLineChartComponent, VerticalAxisComponent, ChartLoaderService, AmexioMapModule, MapPropertiesComponent, GeoChartComponent, TreeMapComponent, MapTitleComponent, MapLoaderService, AmexioPaneModule, AmexioFooterComponent, AmexioBodyComponent, AmexioCarouselComponent, AmexioTemplateDirective, AmexioTemplateWrapperDirective, AmexiodialoguePaneComponent, AmexioFieldSetComponent, AmexioFormActionComponent, AmexioFormBodyComponent, AmexioFormComponent, AmexioFormHeaderComponent, AmexioHeaderComponent, AmexioPanelHeaderComponent, AmexioStepsComponent, StepBlockComponent, AmexioRightVerticalTabComponent, AmexioTabActionComponent, TOP_COMPONENT_CLASS_MAP, BOTTOM_COMPONENT_CLASS_MAP, AmexioTabComponent, AmexioTabPillComponent, AmexioVerticalTabComponent, AmexiotimelineComponent, AmexiotimelineeventComponent, KEY_CODE_window, AmexioWindowPaneComponent, AmexioWindowHeaderComponent, AmexioEnterpriseModule, MultiMediaCarouselComponent, ContentComponent, AmexioYoutubePlayerComponent, AmexioMediaModule, AmexioVideoPlayerComponent, BaseInput as Éµk, BaseFormValidator as Éµi, DropDownListComponent as Éµn, EventBaseComponent as Éµj, AmexioInputHelperComponent as Éµo, ListBaseComponent as Éµm, ListBaseDatepickerComponent as Éµbg, ValueAccessorBase as Éµe, AmexioGridColumnComponent as Éµcn, AmexioDatagridComponent as Éµcm, DataGridFilterComponent as Éµcp, AmexioDataGridHeaderComponent as Éµco, AmexioDataIconComponent as Éµcv, AmexioItemSelectorComponent as Éµcw, AmexioProgressMultiBarComponent as Éµcq, AmexioProgressBarComponent as Éµcr, AmexioFilterTreeComponent as Éµcu, HorizontalTreeViewNodeComponent as Éµcs, HorizontalTreeViewComponent as Éµct, AmexioSearchAdvanceComponent as Éµbr, SearchboxtoolComponent as Éµbq, AmexioButtonDropdownComponent as Éµw, AmexioButtonDropDownItemComponent as Éµx, AmexioSpiltButtonDropdownComponent as Éµy, CheckboxComponent as Éµba, AmexioCheckBoxGroupComponent as Éµz, AmexioCheckBoxComponent as Éµf, AmexioChipComponent as Éµbv, AmexioChipsComponent as Éµbw, AmexioCreditcardComponent as Éµbu, AmexioDateTimePickerComponent as Éµbf, AmexioDropDownMenuComponent as Éµbm, AmexioDropDownitemsComponent as Éµbl, AmexioDropDownComponent as Éµh, AmexioEmailInputComponent as Éµq, AmexioFileUploadComponent as Éµbh, AmexioFloatingButtonComponent as Éµbj, AmexioFloatingGroupButtonComponent as Éµbk, AmexioFormValidator as Éµg, AmexioFormIconComponent as Éµbb, AmexioLabelComponent as Éµbi, AmexioNumberInputComponent as Éµr, AmexioPasswordComponent as Éµs, AmexioRadioGroupComponent as Éµp, AmexioRatingComponent as Éµv, RecaptchaComponent as Éµbs, AmexioSliderComponent as Éµbc, DomHandler as Éµbd, AmexioSpinnerComponent as Éµbt, AmexioTagsInputComponent as Éµbe, AmexioTextAreaComponent as Éµt, AmexioTextInputComponent as Éµd, AmexioToggleComponent as Éµu, ToolbarComponent as Éµbn, ToolBarActionComponent as Éµbp, ToolbaroneComponent as Éµbo, AmexioTypeAheadComponent as Éµl, AmexioLayoutComponent as Éµb, AmexioLayoutItemComponent as Éµc, AmexioIconLayoutComponent as Éµa, AmexioImageComponent as Éµby, AmexioBreadcrumbComponent as Éµch, DockbarComponent as Éµcd, DockedBarToolComponent as Éµce, AmexioNavIconPaneComponent as Éµcg, AmexioMenuBarComponent as Éµcf, AmexioNavActionComponent as Éµca, AmexioNavItemComponent as Éµbz, AmexioNavMenuComponent as Éµcc, AmexioNavTextFieldComponent as Éµcb, AmexioSideNavInnerNodeComponent as Éµci, AmexioFormGroupDirective as Éµcl, AmexioIconPaneComponent as Éµck, AmexioPanelComponent as Éµcj, FilterPipe as Éµbx };
//# sourceMappingURL=amexio-ng-extensions.js.map
